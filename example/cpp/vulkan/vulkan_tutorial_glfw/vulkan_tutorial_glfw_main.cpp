#include <stdafx.h>


// Vulkan

//! Vulkan is included by GLFW library
//#include <vulkan/vulkan.h>


// GLFW

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>


// GLM

#define GLM_ENABLE_EXPERIMENTAL

#define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/hash.hpp>


// STB

#define STB_IMAGE_IMPLEMENTATION
//#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>


// TINYOBJLOADER

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>


// STL

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <tuple>
#include <array>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <chrono>
#include <cmath>
#include <math.h>


const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;


const std::string MODEL_PATH = "../../../../../model/viking_room/viking_room.obj";
const std::string TEXTURE_PATH = "../../../../../model/viking_room/viking_room.png";



struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    bool operator==(const Vertex& other) const {
        return pos == other.pos && color == other.color && texCoord == other.texCoord;
    }

    static VkVertexInputBindingDescription getBindingDescription( void );
    static std::array<VkVertexInputAttributeDescription, 3> getAttributeDescriptions( void );
};


namespace std {
    template<> struct hash<Vertex> {
        size_t operator()(Vertex const& vertex) const {
            return ((hash<glm::vec3>()(vertex.pos) ^
                   (hash<glm::vec3>()(vertex.color) << 1)) >> 1) ^
                   (hash<glm::vec2>()(vertex.texCoord) << 1);
        }
    };
}


VkVertexInputBindingDescription Vertex::getBindingDescription( void ) {
    
    VkVertexInputBindingDescription bindingDescription = {};
    bindingDescription.binding   = 0;
    bindingDescription.stride    = sizeof(Vertex);
    bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

    return bindingDescription;
}

std::array<VkVertexInputAttributeDescription, 3> Vertex::getAttributeDescriptions( void ) {
    std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions = {};

    attributeDescriptions[0].binding  = 0;
    attributeDescriptions[0].location = 0;
    attributeDescriptions[0].format   = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[0].offset   = offsetof(Vertex, pos);

    attributeDescriptions[1].binding  = 0;
    attributeDescriptions[1].location = 1;
    attributeDescriptions[1].format   = VK_FORMAT_R32G32B32_SFLOAT;
    attributeDescriptions[1].offset   = offsetof(Vertex, color);

    attributeDescriptions[2].binding = 0;
    attributeDescriptions[2].location = 2;
    attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
    attributeDescriptions[2].offset = offsetof(Vertex, texCoord);

    return attributeDescriptions;
}

const std::vector<Vertex> cube_vertices = {
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 1.0f}}
};

const std::vector<uint32_t> cube_indices = {
    0, 1, 2, 0, 2, 3,
    4, 5, 6, 4, 6, 7,
    8, 9, 10, 8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23
};

struct UniformBufferObject {
    alignas(16) glm::mat4 model;
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
};

namespace VulkanLoader {

#ifdef _DEBUG
const bool debug_true = true;
#else
const bool debug_true = false;
#endif


class CException 
    : public std::runtime_error 
{
public:

    explicit CException( const char *what ) : std::runtime_error( what ) {}
    explicit CException( const std::string &what ) : std::runtime_error( what ) {}
};


std::vector<char> readFile(const std::string& filename) {
    std::ifstream file(filename, std::ios::ate | std::ios::binary);

    if (!file.is_open()) {
        throw CException("failed to open file!");
    }

    size_t fileSize = (size_t) file.tellg();
    std::vector<char> buffer(fileSize);
    file.seekg(0);
    file.read(buffer.data(), fileSize);
    file.close();

    return buffer;
}


struct TDeviceQueueInfo {
    std::vector<int> _graphics;        //!< indices of queue with `VK_QUEUE_GRAPHICS_BIT`
    std::vector<int> _compute;         //!< indices of queue with `VK_QUEUE_COMPUTE_BIT`
    std::vector<int> _transfer;        //!< indices of queue with `VK_QUEUE_TRANSFER_BIT`
    std::vector<int> _sparse_binding;  //!< indices of queue with `VK_QUEUE_SPARSE_BINDING_BIT`
    std::vector<int> _surface_support; //!< `vkGetPhysicalDeviceSurfaceSupportKHR`
};

struct TSwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR        _capabilities;
    std::vector<VkSurfaceFormatKHR> _formats;
    std::vector<VkPresentModeKHR>   _presentModes;
};

struct TPhysicalDevice {
    VkPhysicalDevice         _physical_device;   //!< device handle
    int                      _rate;              //!< device rating
    TDeviceQueueInfo         _queue;             //!< queue family information
    std::set<std::string>    _extensions;        //!< available device extension
    TSwapChainSupportDetails _swapcahin_support; //!< swap chain details
};


/******************************************************************//**
* \brief   Vulkan application object.
*
* The setup of the Vulkan application follows widely the official
* Vulkan tutorial.
* [https://vulkan-tutorial.com/Introduction]
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
class CAppliction {

public: // public types

   using TPhysicalDevices = std::vector<TPhysicalDevice>;

public: // public operations
    
    CAppliction( bool verbose );
    virtual ~CAppliction();

    bool Verbose( void ) const { return _verbose; }

    void scene(bool load_model)
    {
        _load_model = load_model;
    }

    void layers( 
        const std::vector<std::string> &layerNames,         //!< explicit names of validation layer which should be added
        bool                            all_layers,         //!< enable all existing validation layers
        const std::vector<std::string> &excludeLayerNames ) //!< exclude this validations layers in any case
    { 
      _requestedValidationLayers = layerNames;
      _enableAllValidationLayers = all_layers;
      _excludedValidationLayers  = excludeLayerNames;
    }

    void settings(bool enable_depth_test, bool enable_face_culling)
    {
        _enable_depth_test   = enable_depth_test;
        _enable_face_culling = enable_face_culling;
    }

    void extensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            surface_extensions,   //!< automatically add surface extensions 
        bool                            validation_warnings,  //!< add validation warnings 
        bool                            debug_extensions,     //!< automatically add debug extensions 
        bool                            debug_information)    //!< automatically enable additional debug information
    { 
        _requestedExtensions      = extensions;
        _enableSurfaceExtensions  = surface_extensions;
        _enableValidationWarnings = validation_warnings;
        _enableDebugExtensions    = debug_extensions;
        _enableDebugInformation   = debug_information;

        // add surface extension to the requested extensions
        const std::string surface_ext_name = "VK_KHR_surface";
        if ( _enableSurfaceExtensions ) {
            if ( std::find( _requestedExtensions.begin(), _requestedExtensions.end(), surface_ext_name.c_str() ) == _requestedExtensions.end() )
                _requestedExtensions.push_back( surface_ext_name.c_str() );
            // "VK_KHR_win32_surface" ???
        }
    }

     void deviceExtensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            swapchain_extensions) //!< automatically add swapchain extensions 
    { 
        _requestedDeviceExtensions = extensions;
        _enableSwapchainExtension  = swapchain_extensions;

        // add swapchain device extension  to requested device extensions
        const std::string swapchain_ext_name = "VK_KHR_swapchain";
        if ( _enableSwapchainExtension ) {
            if ( std::find( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), swapchain_ext_name.c_str() ) == _requestedDeviceExtensions.end() )
              _requestedDeviceExtensions.push_back( swapchain_ext_name.c_str() );
        }
    }

    void run( void ); //!< Run Vulkan application

private: // private operations

    void initWindow( void );              //!< Initialize GLFW and create GLFW window
    void initVulkan( void );              //!< Set up Vulkan
    void mainLoop( void );                //!< Event loop
    void cleanup( void );                 //!< Cleanup GLFW
    void resize( int width, int height ); //!< Resize notification
    
    void recreateSwapChain( void );                  //!< recreate the entire swapchain (e.g. when the window was resized)
    void cleanupSwapChain( void );                   //!< cleanup everything which will be recreated till swapchain is recreated
    void createInstance( void );                     //!< initialize the Vulkan library by creating an instance
    void setupDebugCallback( void );                 //!< initialize the Vulkan debug call back which is notified by validation layers
    void createSurface( void );                      //!< Create window surface
    void pickPhysicalDevice( void );                 //!< look for and select a graphics card in the system that supports the features we need.
    void createLogicalDevice( void );                //!< create the logical device
    void createSwapChain( void );                    //!< create the swap chain (images)
    void createImageViews( void );                   //!< create the image view objects
    void createRenderPass( void );                   //!< create render passes
    void createDescriptorSetLayout( void );          //!< create descriptors
    void createGraphicsPipeline( void );             //!< setup the graphics pipeline
    void createFramebuffers( void );                 //!< create the framebuffers
    void createCommandPool( void );                  //!< create the command pool
    void createColorResources(void);                 //!< create the color image
    void createDepthResources(void);                 //!< create the depth image
    void loadModel(void);                            //!< load scene
    void createVertexBuffer( void );                 //!< create vertex buffers
    void createTextureImage( void );                 //!< create texture image
    void createTextureImageView( void );             //!< create texture image view
    void createTextureSampler( void );               //!< create texture sampler
    void createIndexBuffer( void );                  //!< create index buffers
    void createUniformBuffers( void );               //!< create uniform buffers
    void createDescriptorPool( void );               //!< create descriptor pool 
    void createDescriptorSets( void );               //!< create descriptor sets
    void createCommandBuffers( void );               //!< create command buffers
    void createSyncObjects( void );                  //!< create semaphores and fences
    void updateUniformBuffer( uint32_t imageIndex ); //!< update the uniform buffer for the current image

    void drawFrame( void ); //! do the drawing

    //! evaluate if a device is suitable
    int rateDeviceSuitability( VkPhysicalDevice device, const std::set<std::string> &device_extensions, const TSwapChainSupportDetails &swapChainSupport );
    
    void                     deviceInformation( VkPhysicalDevice device, std::ostream &stream );                               //!< get the device information
    TDeviceQueueInfo         findQueueFamilies( VkPhysicalDevice device );                                                     //!< find the queue families from an device
    bool                     checkDeviceExtensionSupport( const std::set<std::string> &device_extensions );                    //!< check if the required device extensions are valid on a given device
    TSwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);                                                   //!< populate swapchain details
    VkSurfaceFormatKHR       chooseSwapSurfaceFormat( const std::vector<VkSurfaceFormatKHR>& availableFormats );               //!< choose the surface format
    VkPresentModeKHR         chooseSwapPresentMode( const std::vector<VkPresentModeKHR> availablePresentModes );               //!< choose the presentation mode
    VkExtent2D               chooseSwapExtent( const VkSurfaceCapabilitiesKHR& capabilities );                                 //!< choose the swapchain 2D extent
    VkShaderModule           createShaderModule( const std::vector<char>& code );                                              //!< create shader module from byte code
    uint32_t                 findMemoryType( VkPhysicalDevice device, uint32_t typeFilter, VkMemoryPropertyFlags properties ); //!< evaluate type of memory
    VkCommandBuffer          beginSingleTimeCommands( void );                                                                  //!< begin executing a command buffer 
    void                     endSingleTimeCommands( VkCommandBuffer commandBuffer );                                           //!< end execute command buffer

    //! abstracting buffer creation
    void createBuffer( VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer &buffer, VkDeviceMemory &bufferMemory );
    //! Copy from copy buffer to the other buffer 
    void copyBuffer( VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size );
    //!  image generation
    void createImage( uint32_t width, uint32_t height, uint32_t mipLevels, VkSampleCountFlagBits numSamples, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage &image, VkDeviceMemory &imageMemory );
    //! image view generation
    void createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, uint32_t mipLevels, VkImageView &imageView);
    //! handle image layout transition
    void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels);
    //! copy buffer to image
    void copyBufferToImage( VkBuffer buffer, VkImage image, uint32_t width, uint32_t height );
    //! find supported format
    VkFormat findSupportedFormat(const std::vector<VkFormat> &candidates, VkImageTiling tiling, VkFormatFeatureFlags features);
    //! find depth format
    VkFormat findDepthFormat();
    //! has stencil components
    bool hasStencilComponent(VkFormat format);
    //! generate mipmaps
    void generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels);
    //! maximum sample count
    VkSampleCountFlagBits getMaxUsableSampleCount(void);


    VkResult CreateDebugReportCallbackEXT(
        VkInstance                                 instance,
        const VkDebugReportCallbackCreateInfoEXT * pCreateInfo,
        const VkAllocationCallbacks              * pAllocator,
        VkDebugReportCallbackEXT                 * pCallback ) const;

    void DestroyDebugReportCallbackEXT(
      VkInstance                    instance,
      VkDebugReportCallbackEXT      callback,
      const VkAllocationCallbacks * pAllocator ) const;

    static VKAPI_ATTR VkBool32 VKAPI_CALL DebugCallback(
        VkDebugReportFlagsEXT        flags,
        VkDebugReportObjectTypeEXT   objType,
        uint64_t                     obj,
        size_t                       location,
        int32_t                      code,
        const char                 * layerPrefix,
        const char                 * msg,
        void                       * userData );

    static void framebufferResizeCallback( GLFWwindow* window, int width, int height );

private: // private attributes

    bool                     _verbose                   = false; //!< flag which controls log messages
    bool                     _enableAllValidationLayers = false; //!< flag which controls the usage of validation layers
    bool                     _enableValidationWarnings  = false; //!< flag which controls warning information
    bool                     _enableSurfaceExtensions   = false; //!< flag which controls automatically enabling of surface extensions
    bool                     _enableDebugExtensions     = false; //!< flag which controls automatically enabling of debug extensions
    bool                     _enableDebugInformation    = false; //!< flag which controls additional debug information
    bool                     _enableSwapchainExtension  = false; //!< flag which controls automatically enabling of swapchain device extensions
    bool                     _enable_depth_test         = false; //!< flag which controls the depth test
    bool                     _enable_face_culling       = false; //!< flag which controls the face culling
    bool                     _load_model                = false; //!< flag which controls loading of obj model
    std::vector<std::string> _requestedValidationLayers;         //!< list of requested validation layers
    std::vector<std::string> _excludedValidationLayers;          //!< list of excluded validation layers
    std::vector<std::string> _requestedExtensions;               //!< list of requested extensions, "VK_EXT_debug_report" is automatically added if any validation layer is requested
    std::vector<std::string> _requestedDeviceExtensions;         //!< list of requested device extensions

    GLFWwindow                         *_wnd = nullptr;          //!< GLFW window
    std::vector<std::string>            _glfwExtensionNames;     //!< available GLFW extension names to interface with the window system
    std::vector<VkExtensionProperties>  _extensions;             //!< available vulkan extensions
    std::vector<std::string>            _extensionNames;         //!< available vulkan extension names
    std::vector<VkLayerProperties>      _validationLayers;       //!< available vulkan validation layers
    std::vector<std::string>            _validationLayersNames;  //!< available vulkan validation layer names

    std::vector<Vertex>                 _vertices;               //!< model vertices
    std::vector<uint32_t>               _indices;                //!< model indices

    VkDebugReportCallbackEXT _debubCallback = nullptr;
    
    size_t                       _currentFrame = 0;                         //!< current frame semaphore index
    bool                         _framebufferResized = false;               //!< state which indicates that the widow has been resized
    
    TPhysicalDevices             _physicalDevices;                          //!< Vulkan physical device handles
    VkSampleCountFlagBits        _msaaSamples = VK_SAMPLE_COUNT_1_BIT;      //!< samples for multisample antialiasing

    VkInstance                   _instance                = VK_NULL_HANDLE; //!< Vulkan instance handle
    VkSurfaceKHR                 _surface                 = VK_NULL_HANDLE; //!< Vulkan surface handle
    VkDevice                     _device                  = VK_NULL_HANDLE; //!< Vulkan logical device handle 
    VkQueue                      _graphicsQueue           = VK_NULL_HANDLE; //!< Vulkan graphics queue handle 
    VkQueue                      _presentQueue            = VK_NULL_HANDLE; //!< Vulkan presentation queue handle 
    VkSwapchainKHR               _swapChain               = VK_NULL_HANDLE; //!< Vulkan swap chain handle 
    std::vector<VkImage>         _swapChainImages;                          //!< Vulkan swap chain image handles
    VkSurfaceFormatKHR           _surfaceFormat;                            //!< selected surface format
    VkPresentModeKHR             _presentMode;                              //!< selected presentation mode
    VkExtent2D                   _extent;                                   //!< selected 2D extent
    std::vector<VkImageView>     _swapChainImageViews;                      //!< Vulkan swap chain image handles
    VkRenderPass                 _renderPass              = VK_NULL_HANDLE; //!< Vulkan render pass handle
    VkDescriptorSetLayout        _descriptorSetLayout     = VK_NULL_HANDLE; //!< Vulkan descriptor set layout
    VkDescriptorPool             _descriptorPool          = VK_NULL_HANDLE; //!< Vulkan descriptor set pool
    std::vector<VkDescriptorSet> _descriptorSets;                           //!< Vulkan descriptor sets
    VkPipelineLayout             _pipelineLayout          = VK_NULL_HANDLE; //!< Vulkan pipeline layout handle
    VkPipeline                   _graphicsPipeline        = VK_NULL_HANDLE; //!< Vulkan graphics pipeline handle
    std::vector<VkFramebuffer>   _swapChainFramebuffers;                    //!< Vulkan frame buffers
    VkCommandPool                _commandPool             = VK_NULL_HANDLE; //!< Vulkan command pool
    std::vector<VkCommandBuffer> _commandBuffers;                           //!< Vulkan command buffers
    std::vector<VkSemaphore>     _imageAvailableSemaphores;                 //!< Vulkan semaphore
    std::vector<VkSemaphore>     _renderFinishedSemaphores;                 //!< Vulkan semaphore
    std::vector<VkFence>         _inFlightFences;                           //!< Vulkan fence
    std::vector<VkBuffer>        _vertexBuffers;                            //!< Vulkan vertex buffer
    std::vector<VkDeviceMemory>  _vertexBufferMemories;                     //!< Vulkan memories used for vertex buffers
    std::vector<VkBuffer>        _indexBuffers;                             //!< Vulkan index buffer
    std::vector<VkDeviceMemory>  _indexBufferMemories;                      //!< Vulkan memories used for index buffers
    std::vector<VkBuffer>        _uniformBuffers;                           //!< Vulkan uniform buffer
    std::vector<VkDeviceMemory>  _uniformBuffersMemories;                   //!< Vulkan memories used for uniform buffers
    std::vector<VkImage>         _depthImage;                               //!< Vulkan depth image 
    std::vector<VkDeviceMemory>  _depthImageMemories;                       //!< Vulkan memories used for depth images
    std::vector<VkImageView>     _depthImageView;                           //!< Vulkan depth image view
    std::vector<VkImage>         _colorImage;                               //!< Vulkan color image 
    std::vector<VkDeviceMemory>  _colorImageMemories;                       //!< Vulkan memories used for color images
    std::vector<VkImageView>     _colorImageView;                           //!< Vulkan color image view
    std::vector<VkImage>         _textureImage;                             //!< Vulkan texture image 
    std::vector<uint32_t>        _textureImageMipmapLevel;                  //!< mipmap levels
    std::vector<VkDeviceMemory>  _textureImageMemories;                     //!< Vulkan memories used for texture images
    std::vector<VkImageView>     _textureImageView;                         //!< Vulkan texture image view
    std::vector<VkSampler>       _textureSampler;                           //!< Vulkan texture sampler
};


/******************************************************************//**
* \brief   ctor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::CAppliction( 
  bool verbose ) //!< control of log messages
  : _verbose( verbose )
{}


/******************************************************************//**
* \brief   dtor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::~CAppliction()
{}


/******************************************************************//**
* \brief   Validation layer debug call back
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
VKAPI_ATTR VkBool32 VKAPI_CALL CAppliction::DebugCallback(
    VkDebugReportFlagsEXT       flags,
    VkDebugReportObjectTypeEXT  objType,
    uint64_t                    obj,
    size_t                      location,
    int32_t                     code,
    const char                 *layerPrefix,
    const char                 *msg,
    void                       *userData ) {

    std::cerr << "validation layer: " << msg << std::endl << std::endl;
    return VK_FALSE;
}


/******************************************************************//**
* \brief   Run Vulkan application
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::run( void ) {
     
    if ( _requestedValidationLayers.empty() && _enableAllValidationLayers == false )
        _enableAllValidationLayers = debug_true;

    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}

/******************************************************************//**
* \brief   Initialize GLFW and create GLFW window
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initWindow( void ) {

    //! glfwInit() initializes the GLFW library. 
    if ( glfwInit() == GLFW_FALSE )
        throw CException( "error initializing GLFW" ); 

    //! Because GLFW was originally designed to create an OpenGL context,
    //! we need to tell it to not create an OpenGL context with a subsequent call:
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        
    //! Because handling resized windows takes special care that we'll look into later,
    //! disable it for now with another window hint call:
    //glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    //! The first three parameters specify the width, height and title of the window.
    //! The fourth parameter allows you to optionally specify a monitor to open the window on
    //! and the last parameter is only relevant to OpenGL.
    _wnd = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan window", nullptr, nullptr);
    if ( _wnd == nullptr )
        throw CException( "error initializing window" ); 

    //! window pointer for callbacks
    glfwSetWindowUserPointer(_wnd, this);

    //! resize call back 
    glfwSetFramebufferSizeCallback(_wnd, framebufferResizeCallback);
}


/******************************************************************//**
* \brief   Set up Vulkan
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initVulkan( void ) {

    createInstance();
    setupDebugCallback();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createDescriptorSetLayout();
    createGraphicsPipeline();  
    createCommandPool();
    createColorResources();
    createDepthResources();
    createFramebuffers();
    createTextureImage();
    createTextureImageView();
    createTextureSampler();
    loadModel();
    createVertexBuffer();
    createIndexBuffer();
    createUniformBuffers();
    createDescriptorPool();
    createDescriptorSets();
    createCommandBuffers();
    createSyncObjects();

    if ( _physicalDevices.empty() )
        return;
    
    if ( Verbose() ) {

        TPhysicalDevice &physicalDevice = _physicalDevices[0];

        std::cout << std::endl;
        std::cout << "instance handle:               " << std::hex << _instance      << "h" << std::endl;
        std::cout << "surface handle:                " << std::hex << _surface       << "h" << std::endl;
        std::cout << "device handle:                 " << std::hex << _device        << "h" << std::endl;
        std::cout << "graphics queue handle:         " << std::hex << _graphicsQueue << "h; index: " << std::dec << physicalDevice._queue._graphics[0] << std::endl;
        std::cout << "presentation queue handle:     " << std::hex << _presentQueue  << "h; index: " << std::dec << physicalDevice._queue._surface_support[0] << std::endl;
        std::cout << "swap chain handle:             " << std::hex << _swapChain     << "h" << std::endl;
        std::cout << "swap chain image handles:      " << std::hex << _swapChainImages[0] << "h";
        for ( size_t i= 1; i < _swapChainImages.size(); ++ i )
            std::cout << ", " << std::hex << _swapChainImages[i] << "h";
        std::cout << std::endl;
        std::cout << "swap chain color space:        " << std::dec <<_surfaceFormat.colorSpace << std::endl;
        std::cout << "swap chain format:             " << std::dec <<_surfaceFormat.format << std::endl;
        std::cout << "swap chain presentation mode:  " << std::hex << _presentMode << "h" << std::endl;
        std::cout << "swap chain 2D extent:          " << std::dec << "(" << _extent.width << ", " << _extent.height << ")" << std::endl;
        std::cout << "swap chain image view handles: " << std::hex << _swapChainImageViews[0] << "h";
        for ( size_t i= 1; i < _swapChainImageViews.size(); ++ i )
            std::cout << ", " << std::hex << _swapChainImageViews[i] << "h";
        std::cout << std::endl;
        std::cout << "render pass handle:            " << std::hex << _renderPass << "h" << std::endl;
        std::cout << "descriptor set layout handle:  " << std::hex << _descriptorSetLayout << "h" << std::endl;
        std::cout << "descriptor pool handle:        " << std::hex << _descriptorPool << "h" << std::endl;
        std::cout << "pipeline layout handle:        " << std::hex << _pipelineLayout << "h" << std::endl;
        std::cout << "graphics pipeline handle:      " << std::hex << _graphicsPipeline << "h" << std::endl;
        std::cout << "swap chain framebuffers:       " << std::hex << _swapChainFramebuffers[0] << "h";
        for ( size_t i= 1; i < _swapChainFramebuffers.size(); ++ i )
            std::cout << ", " << std::hex << _swapChainFramebuffers[i] << "h";
        std::cout << std::endl;
        std::cout << "command pool handle:           " << std::hex << _commandPool << "h" << std::endl;
        std::cout << "command buffer handles:        " << std::hex << _commandBuffers[0] << "h";
        for ( size_t i= 1; i < _commandBuffers.size(); ++ i )
            std::cout << ", " << std::hex << _commandBuffers[i] << "h";
        std::cout << std::endl;
        std::cout << "image semaphore handles:       " << std::hex << _imageAvailableSemaphores[0] << "h";
        for ( size_t i= 1; i < _imageAvailableSemaphores.size(); ++ i )
            std::cout << ", " << std::hex << _imageAvailableSemaphores[i] << "h";
        std::cout << std::endl;
        std::cout << "render semaphore handles:      " << std::hex << _renderFinishedSemaphores[0] << "h";
        for ( size_t i= 1; i < _renderFinishedSemaphores.size(); ++ i )
            std::cout << ", " << std::hex << _renderFinishedSemaphores[i] << "h";
        std::cout << std::endl;
        std::cout << "in fight fence handles:        " << std::hex << _inFlightFences[0] << "h";
        for ( size_t i= 1; i < _inFlightFences.size(); ++ i )
            std::cout << ", " << std::hex << _inFlightFences[i] << "h";
        std::cout << std::endl;

        std::cout << std::dec << std::endl;
    }
}


/******************************************************************//**
* \brief   Event loop
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::mainLoop( void ) {

    //! To keep the application running until either an error occurs or the window is closed, we need to add an event loop 
    while (!glfwWindowShouldClose(_wnd)) {
        glfwPollEvents();

        drawFrame();

        //! we should wait for the logical device to finish operations before exiting mainLoop and destroying the window:
        vkDeviceWaitIdle(_device);

        //glfwWaitEvents();
    }
}


/******************************************************************//**
* \brief   Cleanup GLFW
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::cleanup( void ) {

    cleanupSwapChain();

    if ( _device != VK_NULL_HANDLE ) {

        if ( _descriptorSetLayout != VK_NULL_HANDLE )
            vkDestroyDescriptorSetLayout(_device, _descriptorSetLayout, nullptr);
        _descriptorSetLayout = VK_NULL_HANDLE;

        for (auto textureSampler : _textureSampler) {
             vkDestroySampler(_device, textureSampler, nullptr);
        }
        _textureSampler.clear();

        for (auto textureImageView : _textureImageView) {
             vkDestroyImageView(_device, textureImageView, nullptr);
        }
        _textureImageView.clear();

        for (auto textureImage : _textureImage) {
             vkDestroyImage(_device, textureImage, nullptr);
        }
        _textureImage.clear();
        _textureImageMipmapLevel.clear();

        for (auto textureImageMemory : _textureImageMemories) {
             vkFreeMemory(_device, textureImageMemory, nullptr);
        }
        _textureImageMemories.clear();

        for (auto indexBuffer : _indexBuffers) {
             vkDestroyBuffer(_device, indexBuffer, nullptr);
        }
        _indexBuffers.clear();

        for (auto indexBufferMemory : _indexBufferMemories) {
             vkFreeMemory(_device, indexBufferMemory, nullptr);
        }
        _indexBufferMemories.clear();

        for (auto vertexBuffer : _vertexBuffers) {
             vkDestroyBuffer(_device, vertexBuffer, nullptr);
        }
        _vertexBuffers.clear();

        for (auto vertexBufferMemory : _vertexBufferMemories) {
             vkFreeMemory(_device, vertexBufferMemory, nullptr);
        }
        _vertexBufferMemories.clear();

        for (auto inFghtFence : _inFlightFences) {
             vkDestroyFence(_device, inFghtFence, nullptr);
        }
        _inFlightFences.clear();

        for (auto finishSemaphore : _renderFinishedSemaphores) {
             vkDestroySemaphore(_device, finishSemaphore, nullptr);
        }
        _renderFinishedSemaphores.clear();

        for (auto imageSemaphore : _imageAvailableSemaphores) {
             vkDestroySemaphore(_device, imageSemaphore, nullptr);
        }
        _imageAvailableSemaphores.clear();

        if ( _commandPool != VK_NULL_HANDLE )
            vkDestroyCommandPool(_device, _commandPool, nullptr);
        _commandPool = VK_NULL_HANDLE;

        // device should be destroyed
        vkDestroyDevice(_device, nullptr);
        _device = VK_NULL_HANDLE;
    }
  
    if ( _instance != VK_NULL_HANDLE ) {

        // destroy surface
        vkDestroySurfaceKHR(_instance, _surface, nullptr);
        _surface = VK_NULL_HANDLE;

        DestroyDebugReportCallbackEXT( _instance, _debubCallback, nullptr );  
        _debubCallback = nullptr;

        //! The VkInstance should be only destroyed right before the program exits. It can be destroyed in cleanup with the vkDestroyInstance function:
        //! The parameters for the vkDestroyInstance function are straightforward. As mentioned in the previous chapter,
        //! the allocation and deallocation functions in Vulkan have an optional allocator callback that we'll ignore by passing `nullptr` to it.
        //! All of the other Vulkan resources that we'll create in the following chapters should be cleaned up before the instance is destroyed.
        vkDestroyInstance(_instance, nullptr);
        _instance = VK_NULL_HANDLE;
    }

    //! Once the window is closed, we need to clean up resources by destroying it and terminating GLFW itself. 
    glfwDestroyWindow(_wnd);
    _wnd = nullptr;
    glfwTerminate();
}


/******************************************************************//**
* \brief Resize notification.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::framebufferResizeCallback( 
    GLFWwindow* window, //!< GLFW window handle (pointer)
    int         width,  //!< new width of the window
    int         height  //!< new height of the window
    ) {

    if ( window == nullptr )
        return;
    CAppliction *appPtr = (CAppliction*)glfwGetWindowUserPointer( window );
    if ( appPtr == nullptr )
        return;

    appPtr->resize( width, height );
}


/******************************************************************//**
* \brief Resize notification  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::resize( 
    int width, //!< new width of the window
    int height //!< new height of the window
    ) {

  _framebufferResized = true;
}


/******************************************************************//**
* \brief Recreate the entire swapchain (e.g. when the window was resized). 
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::recreateSwapChain( void ) {
    
    if ( _device == VK_NULL_HANDLE )
        return;

    //! We first call `vkDeviceWaitIdle`, because just like in the last chapter, we shouldn't touch resources that may still be in use.
    //! Obviously, the first thing we'll have to do is recreate the swap chain itself.
    //! The image views need to be recreated because they are based directly on the swap chain images.
    // !The render pass needs to be recreated because it depends on the format of the swap chain images.
    // !It is rare for the swap chain image format to change during an operation like a window resize, but it should still be handled.
    // !Viewport and scissor rectangle size is specified during graphics pipeline creation, so the pipeline also needs to be rebuilt.
    // !It is possible to avoid this by using dynamic state for the viewports and scissor rectangles.
    //! Finally, the framebuffers and command buffers also directly depend on the swap chain images.

    vkDeviceWaitIdle(_device);

    // pause till the window is minimized
    int width = 0, height = 0;
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(_wnd, &width, &height);
        glfwWaitEvents();
    }

    //pickPhysicalDevice();
    // update swap chain information
    TSwapChainSupportDetails details = querySwapChainSupport(_physicalDevices[0]._physical_device);
    _physicalDevices[0]._swapcahin_support = details;
    
    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createColorResources();
    createDepthResources();
    createFramebuffers();
    createUniformBuffers();
    createDescriptorPool();
    createDescriptorSets();
    createCommandPool();
    createCommandBuffers();
}


/******************************************************************//**
* \brief Cleanup everything which will be recreated till swapchain
* is recreated.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::cleanupSwapChain( void ) {

    if ( _device == VK_NULL_HANDLE )
        return;

    for (auto depthImageView : _depthImageView) {
        vkDestroyImageView(_device, depthImageView, nullptr);
    }
    _depthImageView.clear();

    for (auto depthImage : _depthImage) {
        vkDestroyImage(_device, depthImage, nullptr);
    }
    _depthImage.clear();

    for (auto depthImageMemory : _depthImageMemories) {
        vkFreeMemory(_device, depthImageMemory, nullptr);
    }
    _depthImageMemories.clear();

    for (auto colorImageView : _colorImageView) {
        vkDestroyImageView(_device, colorImageView, nullptr);
    }
    _colorImageView.clear();

    for (auto colorImage : _colorImage) {
        vkDestroyImage(_device, colorImage, nullptr);
    }
    _colorImage.clear();

    for (auto colorImageMemory : _colorImageMemories) {
        vkFreeMemory(_device, colorImageMemory, nullptr);
    }
    _colorImageMemories.clear();

    for (auto uniformBuffer : _uniformBuffers) {
        vkDestroyBuffer(_device, uniformBuffer, nullptr);
    }
    _uniformBuffers.clear();

    for (auto uniformBufferMemory : _uniformBuffersMemories) {
          vkFreeMemory(_device, uniformBufferMemory, nullptr);
    }
    _uniformBuffersMemories.clear();

    if ( _descriptorPool != VK_NULL_HANDLE )
        vkDestroyDescriptorPool(_device, _descriptorPool, nullptr);
    _descriptorPool = VK_NULL_HANDLE;

    //! You don't need to explicitly clean up descriptor sets, because they will be automatically freed when the descriptor pool is destroyed.
    _descriptorSets.clear();


    for (auto framebuffer : _swapChainFramebuffers) {
        vkDestroyFramebuffer(_device, framebuffer, nullptr);
    }
    _swapChainFramebuffers.clear();

    if ( _commandPool != VK_NULL_HANDLE )
        vkFreeCommandBuffers(_device, _commandPool, static_cast<uint32_t>(_commandBuffers.size()), _commandBuffers.data());
    _commandBuffers.clear();

    if ( _graphicsPipeline != VK_NULL_HANDLE )
        vkDestroyPipeline(_device, _graphicsPipeline, nullptr);
    _graphicsPipeline = VK_NULL_HANDLE;

    if ( _pipelineLayout != VK_NULL_HANDLE )
        vkDestroyPipelineLayout(_device, _pipelineLayout, nullptr);
    _pipelineLayout = VK_NULL_HANDLE;

    if ( _renderPass != VK_NULL_HANDLE )
        vkDestroyRenderPass(_device, _renderPass, nullptr);
    _renderPass = VK_NULL_HANDLE;

    for (auto imageView : _swapChainImageViews) {
          vkDestroyImageView(_device, imageView, nullptr);
    }
    _swapChainImageViews.clear();

    if ( _swapChain != VK_NULL_HANDLE )
        vkDestroySwapchainKHR(_device, _swapChain, nullptr);
    _swapChain = VK_NULL_HANDLE;
}


/******************************************************************//**
* \brief usable sample count
*
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
VkSampleCountFlagBits CAppliction::getMaxUsableSampleCount() {
    VkPhysicalDeviceProperties physicalDeviceProperties;
    vkGetPhysicalDeviceProperties(_physicalDevices.front()._physical_device, &physicalDeviceProperties);

    VkSampleCountFlags counts = physicalDeviceProperties.limits.framebufferColorSampleCounts & physicalDeviceProperties.limits.framebufferDepthSampleCounts;
    if (counts & VK_SAMPLE_COUNT_64_BIT) { return VK_SAMPLE_COUNT_64_BIT; }
    if (counts & VK_SAMPLE_COUNT_32_BIT) { return VK_SAMPLE_COUNT_32_BIT; }
    if (counts & VK_SAMPLE_COUNT_16_BIT) { return VK_SAMPLE_COUNT_16_BIT; }
    if (counts & VK_SAMPLE_COUNT_8_BIT) { return VK_SAMPLE_COUNT_8_BIT; }
    if (counts & VK_SAMPLE_COUNT_4_BIT) { return VK_SAMPLE_COUNT_4_BIT; }
    if (counts & VK_SAMPLE_COUNT_2_BIT) { return VK_SAMPLE_COUNT_2_BIT; }

    return VK_SAMPLE_COUNT_1_BIT;
}


/******************************************************************//**
* \brief   initialize the Vulkan library by creating an instance
*
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::createInstance( void ) {

    //! The very first thing you need to do is initialize the Vulkan library by creating an instance.
    //! The instance is the connection between your application and the Vulkan library and creating it involves specifying some details about your application to the driver.

    //-------------------------------------------
    // VULKAN validation layers
    //-------------------------------------------

    // List all of the available validation layers using the vkEnumerateInstanceLayerProperties
    uint32_t layerCount = 0;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);
    _validationLayers.resize( layerCount );
    vkEnumerateInstanceLayerProperties(&layerCount, _validationLayers.data());
    std::transform(_validationLayers.begin(), _validationLayers.end(), std::back_inserter(_validationLayersNames), []( auto &layer) -> std::string {
        return layer.layerName;
    } );
    
    if ( Verbose() ) {
        std::cout << layerCount << " validation layers supported" << std::endl;
        for ( const auto& name : _validationLayersNames )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // VULKAN extensions
    //-------------------------------------------

    //! To retrieve a list of supported extensions before creating an instance, there's the vkEnumerateInstanceExtensionProperties function.
    //! It takes a pointer to a variable that stores the number of extensions and an array of VkExtensionProperties to store details of the extensions.
    //! It also takes an optional first parameter that allows us to filter extensions by a specific validation layer, which we'll ignore for now.
    uint32_t extensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr);
    _extensions.resize( extensionCount );
    vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, _extensions.data());
    std::transform(_extensions.begin(), _extensions.end(), std::back_inserter(_extensionNames), []( auto &extension) -> std::string {
        return extension.extensionName;
    } );

    if ( Verbose() ) {
        std::cout << extensionCount << " extensions supported" << std::endl;
        for ( const auto& name : _extensionNames )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // GLFW extensions
    //-------------------------------------------

    //! Vulkan is a platform agnostic API, which means that you need an extension to interface with the window system.
    //! GLFW has a handy built-in function that returns the extension(s) it needs to do that which we can pass to the `struct`:

    unsigned int glfwExtensionCount = 0;
    const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);
    _glfwExtensionNames.resize( glfwExtensionCount );
    std::copy( glfwExtensions, glfwExtensions + glfwExtensionCount, _glfwExtensionNames.begin() );
   
    if ( Verbose() ) {
        std::cout << glfwExtensionCount << " GLFW extensions supported" << std::endl;
        for ( const auto& name : _glfwExtensionNames )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // check if request validation layers are available
    //-------------------------------------------
    
    std::vector<const char*> validationLayerParam;
    if ( _enableAllValidationLayers ) {
        for ( auto &layerName : _validationLayersNames ) {
          auto it = std::find( _excludedValidationLayers.begin(), _excludedValidationLayers.end(), layerName );
          if ( it == _excludedValidationLayers.end() ) {
              validationLayerParam.push_back( layerName.c_str() );
          }
        }
    } else {
        for ( auto &layerName : _requestedValidationLayers ) {
            auto vlIt = std::find( _validationLayersNames.begin(), _validationLayersNames.end(), layerName );
            if ( vlIt == _validationLayersNames.end() ) {
                if ( Verbose() ) {
                    std::stringstream msg;
                    msg << "validation layers \"" << layerName << "\" requested, but not available!";
                    std::cout << msg.str() << std::endl;
                }
            } else {
                validationLayerParam.push_back( vlIt->c_str() );
            }
        }
    }

    // add debug report extension if any validation layer is requested
    if ( validationLayerParam.empty() == false ) {
        std::vector<const char*> debug_extensions{ VK_EXT_DEBUG_REPORT_EXTENSION_NAME };
        if ( _enableDebugExtensions )
            debug_extensions.push_back( "VK_EXT_debug_utils" );

        for ( auto debug_extension : debug_extensions ) {                                                                                                  
            if ( std::find( _requestedExtensions.begin(), _requestedExtensions.end(), debug_extension ) != _requestedExtensions.end() )
                continue;
            if ( std::find( _extensionNames.begin(), _extensionNames.end(), debug_extension ) == _extensionNames.end() )
                continue;
            _requestedExtensions.push_back( debug_extension );
        }
    }

    if ( Verbose() ) {
        std::cout << validationLayerParam.size() << " validation layers are set up" << std::endl;
        for ( const auto& name : validationLayerParam )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // check if requested extensions are supported
    //-------------------------------------------

    for ( auto &extensionName : _requestedExtensions ) {
        auto vlIt = std::find( _extensionNames.begin(), _extensionNames.end(), extensionName );
        if ( vlIt == _extensionNames.end() ) {
            std::stringstream msg;
            msg << "extension \"" << extensionName << "\"requested, but not available!";
            if ( Verbose() )
                std::cout << msg.str() << std::endl;
            throw CException( msg.str() );
        }
    }
    std::vector<const char*> extensionParam( _requestedExtensions.size(), nullptr );
    std::transform( _requestedExtensions.begin(), _requestedExtensions.end(), extensionParam.begin(), [](const std::string &str) -> const char * { return str.c_str(); } );
    
    if ( Verbose() ) {
        std::cout << extensionParam.size() << " extensions are set up" << std::endl;
        for ( const auto& name : extensionParam )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // application information
    //-------------------------------------------

    //! Now, to create an instance we'll first have to fill in a `struct` with some information about our application.
    //! This data is technically optional, but it may provide some useful information to the driver to optimize for our specific application,
    //! for example because it uses a well-known graphics engine with certain special behavior.
    //! This `struct` is called `VkApplicationInfo`:

    VkApplicationInfo appInfo {};
    appInfo.sType              = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    // `appInfo.pNext              = nullptr;`
    appInfo.pApplicationName   = "Vulkan tutorial";
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName        = "No Engine";
    appInfo.engineVersion      = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion         = VK_API_VERSION_1_2;   


    //-------------------------------------------
    // instance
    //-------------------------------------------

    //! The next `struct` is not optional and tells the Vulkan driver which global extensions and validation layers we want to use.
    //! Global here means that they apply to the entire program and not a specific device, which will become clear in the next few chapters.

    VkInstanceCreateInfo createInfo = {};
    createInfo.sType            = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    // createInfo.pNext            = nullptr;
    // createInfo.flags
    createInfo.pApplicationInfo = &appInfo;

    createInfo.enabledExtensionCount   = static_cast<uint32_t>( extensionParam.size() );
    createInfo.ppEnabledExtensionNames = extensionParam.data();
 
    // The last two members of the `struct` determine the global validation layers to enable.
    createInfo.enabledLayerCount   = static_cast<uint32_t>( validationLayerParam.size() );
    createInfo.ppEnabledLayerNames = validationLayerParam.empty() ? nullptr : validationLayerParam.data();
   

    if (  vkCreateInstance(&createInfo, nullptr, &_instance) != VK_SUCCESS )
        throw CException("failed to create instance!");
}


/******************************************************************//**
* \brief   initialize the Vulkan debug call back which is notified by validation layers   
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
void CAppliction::setupDebugCallback( void ) {

    if ( _instance == VK_NULL_HANDLE )
       throw CException("no vulkan instance!");

    VkDebugReportCallbackCreateInfoEXT createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    createInfo.flags =
        (_enableDebugInformation ? VK_DEBUG_REPORT_INFORMATION_BIT_EXT : 0) |
        (_enableDebugInformation ? VK_DEBUG_REPORT_DEBUG_BIT_EXT : 0) |
        (_enableValidationWarnings ? VK_DEBUG_REPORT_WARNING_BIT_EXT : 0) |
        (_enableValidationWarnings ? VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT : 0 ) |
        VK_DEBUG_REPORT_ERROR_BIT_EXT;
    createInfo.pfnCallback = &CAppliction::DebugCallback;
    createInfo.pUserData = this;
    
    if ( CreateDebugReportCallbackEXT( _instance, &createInfo, nullptr, &_debubCallback  ) != VK_SUCCESS )
        throw CException("failed to set up debug callback!");


    //! There are a lot more settings for the behavior of validation layers than just the flags specified in the `VkDebugReportCallbackCreateInfoEXT` `struct`.
    //! Browse to the Vulkan SDK and go to the configuration directory. There you will find a vk_layer_settings.txt file that explains how to configure the layers.
    //! To configure the layer settings for your own application, copy the file to the Debug and Release directories of your project and follow the instructions
    //! to set the desired behavior. However, for the remainder of this tutorial I'll assume that you're using the default settings.
    //! cf [https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers]
}


/******************************************************************//**
* \brief   Delegate to `vkCreateDebugReportCallbackEXT` 
*
* `VkDebugReportCallbackCreateInfoEXT`
* This `struct` should be passed to the `vkCreateDebugReportCallbackEXT`
* function to create the `VkDebugReportCallbackEXT` object.
* Unfortunately, because this function is an extension function, it is
* not automatically loaded.
* We have to look up its address ourselves using `vkGetInstanceProcAddr`.
* We're going to create our own proxy function that handles this in
* the background.
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
VkResult CAppliction::CreateDebugReportCallbackEXT(
    VkInstance                                instance,
    const VkDebugReportCallbackCreateInfoEXT *pCreateInfo,
    const VkAllocationCallbacks              *pAllocator,
    VkDebugReportCallbackEXT                 *pCallback ) const {

    auto func = (PFN_vkCreateDebugReportCallbackEXT) vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
    if (func != nullptr) {
        return func(instance, pCreateInfo, pAllocator, pCallback);
    } else {
        return VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}


/******************************************************************//**
* \brief   Delegate to `vkDestroyDebugReportCallbackEXT`
*
* The `VkDebugReportCallbackEXT` object needs to be cleaned up with a
* call to `vkDestroyDebugReportCallbackEXT`.
* Similarly to `vkCreateDebugReportCallbackEXT` the function needs to
* be explicitly loaded.
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
void CAppliction::DestroyDebugReportCallbackEXT(
    VkInstance                   instance,
    VkDebugReportCallbackEXT     callback,
    const VkAllocationCallbacks *pAllocator ) const {

    auto func = (PFN_vkDestroyDebugReportCallbackEXT) vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
    if (func != nullptr) {
        func(instance, callback, pAllocator);
    }
}


/******************************************************************//**
* \brief   Create window surface.
* 
* \author  gernot
* \date    2018-05-11
* \version 1.0
**********************************************************************/
void CAppliction::createSurface( void ) {

    if ( _wnd == nullptr )
       throw CException("no window!"); 
    if ( _instance == VK_NULL_HANDLE )
       throw CException("no vulkan instance!");

    //! Since Vulkan is a platform agnostic API, it can not interface directly with the window system on its own.
    //! To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions.
    //!
    //! The `VK_KHR_surface` extension is an instance level extension and we've actually already enabled it, because it's included in the list returned by `glfwGetRequiredInstanceExtensions`.
    //!
    //! The window surface needs to be created right after the instance creation, because it can actually influence the physical device selection.
    //! The reason we postponed this is because window surfaces are part of the larger topic of render targets and presentation for which the explanation would have cluttered the basic setup.
    //! It should also be noted that window surfaces are an entirely optional component in Vulkan, if you just need off-screen rendering.
    //! Vulkan allows you to do that without hacks like creating an invisible window (necessary for OpenGL).

    //-------------------------------------------
    // Window surface creation
    //-------------------------------------------

    //! Although the `VkSurfaceKHR` object and its usage is platform agnostic, its creation isn't because it depends on window system details.
    //! For example, it needs the HWND and HMODULE handles on Windows.
    //! Therefore there is a platform-specific addition to the extension, which on Windows is called VK_KHR_win32_surface and is also automatically included in the list from `glfwGetRequiredInstanceExtensions`.
    //!
    //! I will demonstrate how this platform specific extension can be used to create a surface on Windows, but we won't actually use it in this tutorial.
    //! It doesn't make any sense to use a library like GLFW and then proceed to use platform-specific code anyway.
    //! GLFW actually has glfwCreateWindowSurface that handles the platform differences for us. Still, it's good to see what it does behind the scenes before we start relying on it.
    //!
    //! Because a window surface is a Vulkan object, it comes with a `VkWin32SurfaceCreateInfoKHR` `struct` that needs to be filled in.
    //! It has two important parameters: `hwnd` and `hinstance`. These are the handles to the window and the process.

    /*
    VkWin32SurfaceCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    createInfo.hwnd = glfwGetWin32Window(_wnd);
    createInfo.hinstance = GetModuleHandle(nullptr);
 
    auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");

    if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("failed to create window surface!");
    }
    */

    //! The glfwCreateWindowSurface function performs exactly this operation with a different implementation for each platform.

    if ( glfwCreateWindowSurface( _instance, _wnd, nullptr, &_surface ) != VK_SUCCESS )
      throw CException( "failed to create window surface!" );
}


/******************************************************************//**
* \brief   look for and select a graphics card in the system that
*          supports the features we need.
*
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
void CAppliction::pickPhysicalDevice( void ) {

    if ( _instance == VK_NULL_HANDLE )
       throw CException("no vulkan instance!");
    _physicalDevices.clear();

    //! After initializing the Vulkan library through a `VkInstance` we need to look for and select a graphics card in the system that supports the features we need.
    //! In fact we can select any number of graphics cards and use them simultaneously.

    //-------------------------------------------
    // Listing the requested device extensions
    //-------------------------------------------

    std::vector<const char*> extensionParam( _requestedDeviceExtensions.size(), nullptr );
    std::transform( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), extensionParam.begin(), [](const std::string &str) -> const char * { return str.c_str(); } );
    if ( Verbose() ) {
        std::cout << extensionParam.size() << " device extensions are requested" << std::endl;
        for ( const auto& name : extensionParam )
            std::cout << "\t" << name << std::endl;
        std::cout << std::endl;
    }


    //-------------------------------------------
    // Listing the graphics cards
    //-------------------------------------------
   
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(_instance, &deviceCount, nullptr);
    if (deviceCount == 0)
        throw CException("failed to find GPUs with Vulkan support!");

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(_instance, &deviceCount, devices.data());

    std::multimap<int, VkPhysicalDevice> candidates;
    for (const auto& device : devices) {

        // get the queue families from the devices
        TDeviceQueueInfo queueInfo = findQueueFamilies( device );

        // find the device extensions
        std::set<std::string> device_extensions;
        uint32_t extensionCount;
        vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);
        std::vector<VkExtensionProperties> availableExtensions(extensionCount);
        vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());
        for ( const auto& extension : availableExtensions )
            device_extensions.insert(extension.extensionName);

        //!< Just checking if a swap chain is available is not sufficient, because it may not actually be compatible with our window surface.
        //!< Creating a swap chain also involves a lot more settings than instance and device creation, so we need to query for some more details before we're able to proceed.
        //!< There are basically three kinds of properties we need to check:
        //!< - Basic surface capabilities (min/max number of images in swap chain, min/max width and height of images)
        //!< - Surface formats (pixel format, color space)
        //!< - Available presentation modes

        TSwapChainSupportDetails details = querySwapChainSupport(device);

  
        // calculate the device score
        int score = rateDeviceSuitability(device, device_extensions, details);
        candidates.insert(std::make_pair(score, device));

        _physicalDevices.push_back( { 
            device,
            score,
            queueInfo,
            device_extensions,
            details
        } );
    }
    std::sort( _physicalDevices.begin(), _physicalDevices.end(), []( auto &a, auto &b )
    {
      return a._rate > b._rate;
    } );

    _msaaSamples = getMaxUsableSampleCount(); // TODO add to `TPhysicalDevice`

    if ( Verbose() )
    {
        std::cout << candidates.size() << " devices are available" << std::endl;
        for ( auto device : _physicalDevices ) {
            std::cout << "\t";
            deviceInformation( device._physical_device, std::cout );
            std::cout << "; rated: " << device._rate << std::endl;

            static const std::vector<std::string> familiy_names{
                "graphics queue indices:       ",
                "compute queue indices:        ",
                "transfer queue indices:       ",
                "sparse binding queue indices: ",
                "surface support indices:      "
            };
            std::vector<std::vector<int>> queue_info{
                device._queue._graphics,
                device._queue._compute,
                device._queue._transfer,
                device._queue._sparse_binding,
                device._queue._surface_support
            };
            for ( size_t i=0; i < queue_info.size(); ++i ) {
                if ( queue_info[i].empty() )
                    continue;
                std::cout << "\t\t" << familiy_names[i] << queue_info[i][0];
                for ( size_t j=1; j<queue_info[i].size(); ++j )
                    std::cout << ", " << queue_info[i][j];
                std::cout << std::endl;
            }

            std::cout << "\t\t" << device._extensions.size() << " device extensions are available" << std::endl;
            for ( auto &ext_name : device._extensions ) {
                std::cout << "\t\t\t" << ext_name << std::endl;
            }
        }
        std::cout << std::endl;
    }

    // Check if the best candidate is suitable at all
    if (_physicalDevices.empty() || _physicalDevices[0]._rate <= 0) {
        throw CException("failed to find a suitable GPU!");
    }
}


/******************************************************************//**
* \brief   evaluate if a device is suitable 
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
int CAppliction::rateDeviceSuitability( 
    VkPhysicalDevice                device,            //!< device handle
    const std::set<std::string>    &device_extensions, //!< device extensions
    const TSwapChainSupportDetails &swapChainSupport   //!< swap chain details
    ) {

    if ( device == VK_NULL_HANDLE )
       throw CException("no physical device!");

    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

    int score = 0;

    static const std::map<VkPhysicalDeviceType, int> typescore_map {
        { VK_PHYSICAL_DEVICE_TYPE_OTHER,          0 },
        { VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU, 100 },
        { VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,   1000 },
        { VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,    2 },
        { VK_PHYSICAL_DEVICE_TYPE_CPU,            1 },
    };
    auto type_score_it = typescore_map.find( deviceProperties.deviceType );
    if ( type_score_it != typescore_map.end() )
        score += type_score_it->second;

    // check for requested device extensions
    if ( checkDeviceExtensionSupport(device_extensions) == false ) {
        score = 0;
        return 0;
    }

    // check for swap chain support
    if ( _enableSwapchainExtension ) {
        if (swapChainSupport._formats.empty() || swapChainSupport._presentModes.empty() ) {
            score = 0;
            return 0;
        }
    }

    // check for anisotropic filer support
    if (!deviceFeatures.samplerAnisotropy) {
        score = 0;
        return 0;
    }

    /*
    // Maximum possible size of textures affects graphics quality
    score += deviceProperties.limits.maxImageDimension2D;

    // Application can't function without geometry shaders
    if (!deviceFeatures.geometryShader) {
        return 0;
    }
    */

    return score;
}


/******************************************************************//**
* \brief   Log the device information. 
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
void CAppliction::deviceInformation( 
    VkPhysicalDevice  device, //!< device handle
    std::ostream     &stream  //!< output stream
    ) {

    if ( device == VK_NULL_HANDLE )
       throw CException("no physical device!");

    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

    if ( Verbose() ) {

        static const std::map<VkPhysicalDeviceType, std::string> typename_map {
            { VK_PHYSICAL_DEVICE_TYPE_OTHER,          "unknown" },
            { VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU, "integrated GPU" },
            { VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,   "discrete GPU" },
            { VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,    "virtual GPU" },
            { VK_PHYSICAL_DEVICE_TYPE_CPU,            "CPU" },
        };
        
        std::string device_name = deviceProperties.deviceName;
        std::string device_type = "unknown";
        auto it = typename_map.find( deviceProperties.deviceType );
        if ( it != typename_map.end() )
            device_type = it->second;

        stream << device_name << " : " << device_type;
    }
}


/******************************************************************//**
* \brief   find the queue families from an device.
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
TDeviceQueueInfo CAppliction::findQueueFamilies( 
    VkPhysicalDevice device //!< device handle
    ) {

    if ( device == VK_NULL_HANDLE )
       throw CException("no physical device!");
    if ( _surface == VK_NULL_HANDLE )
       throw CException("no vulkan surface!");

    //! In Vulkan, anything from drawing to uploading textures, requires commands to be submitted to a queue.
    //! There are different types of queues that originate from different queue families and each family of queues allows only a subset of commands.
    //! For example, there could be a queue family that only allows processing of compute commands or one that only allows memory transfer related commands.
    //! We need to check which queue families are supported by the device and which one of these supports the commands that we want to use. 

    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

    TDeviceQueueInfo info;
    for ( int i=0; i<queueFamilies.size(); ++ i ) {
        const auto& queueFamily = queueFamilies[i];
        if ( queueFamily.queueCount == 0 )
          continue;

        if ( queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT )       info._graphics.push_back(i);
        if ( queueFamily.queueFlags & VK_QUEUE_COMPUTE_BIT )        info._compute.push_back(i);
        if ( queueFamily.queueFlags & VK_QUEUE_TRANSFER_BIT )       info._transfer.push_back(i);
        if ( queueFamily.queueFlags & VK_QUEUE_SPARSE_BINDING_BIT ) info._sparse_binding.push_back(i);

        //!The function to check for that is vkGetPhysicalDeviceSurfaceSupportKHR, which takes the physical device, queue family index and surface as parameters.
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, _surface, &presentSupport);
        if ( presentSupport )
           info._surface_support.push_back(i);
    }

    return info;
}

/******************************************************************//**
* \brief   Create the logical device.   
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
void CAppliction::createLogicalDevice( void ) {

    if ( _instance == VK_NULL_HANDLE )
        throw CException("no vulkan instance!");
    if ( _surface == VK_NULL_HANDLE )
        throw CException("no vulkan surface!");
    if ( _physicalDevices.empty() )
        throw CException("no physical device!");

    //! After selecting a physical device to use we need to set up a logical device to interface with it.
    //! The logical device creation process is similar to the instance creation process and describes the features we want to use.
    //! We also need to specify which queues to create now that we've queried which queue families are available.
    //! You can even create multiple logical devices from the same physical device if you have varying requirements.

    TPhysicalDevice &physicalDevice = _physicalDevices[0];
    if (physicalDevice._queue._graphics.empty() )
        throw CException("no graphics device queue!");
    if (physicalDevice._queue._surface_support.empty())
        throw CException("no surface presentation support!");


    //-------------------------------------------
    // Specifying the queues to be created
    //-------------------------------------------

    std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
    std::set<int> uniqueQueueFamilies = 
    {
      physicalDevice._queue._graphics[0],
      physicalDevice._queue._surface_support[0]
    };

    //!< Vulkan lets you assign priorities to queues to influence the scheduling of command buffer execution using floating point numbers between 0.0 and 1.0.
    //!< This is required even if there is only a single queue:
      
    float queuePriority = 1.0f;
    for (int queueFamily : uniqueQueueFamilies) {
    
        VkDeviceQueueCreateInfo queueCreateInfo = {};
        queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queueCreateInfo.queueFamilyIndex = queueFamily;
        queueCreateInfo.queueCount = 1;
        queueCreateInfo.pQueuePriorities = &queuePriority;
        queueCreateInfos.push_back(queueCreateInfo);
    }


    //-------------------------------------------
    // Specifying used device features
    //-------------------------------------------

    // The next information to specify is the set of device features that we'll be using.
    // These are the features that we queried support for with `vkGetPhysicalDeviceFeatures`.
    VkPhysicalDeviceFeatures deviceFeatures = {};

    deviceFeatures.samplerAnisotropy = VK_TRUE;
    deviceFeatures.sampleRateShading = VK_TRUE; // enable sample shading feature for the device


    //-------------------------------------------
    // Specifying device extensions
    //-------------------------------------------

    std::vector<const char*> deviceExtensionParam( _requestedDeviceExtensions.size(), nullptr );
    std::transform( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), deviceExtensionParam.begin(), [](const std::string &str) -> const char * { return str.c_str(); } );
    

    //-------------------------------------------
    // Creating the logical device
    //-------------------------------------------

    VkDeviceCreateInfo createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
    createInfo.pQueueCreateInfos = queueCreateInfos.data();
    createInfo.pEnabledFeatures = &deviceFeatures;

    createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensionParam.size());
    createInfo.ppEnabledExtensionNames = deviceExtensionParam.data();

    // We will enable the same validation layers for devices as we did for the instance.
    // We won't need any device specific extensions for now.

    std::vector<const char*> validationLayerParam;
    if ( _enableAllValidationLayers ) {
        std::vector<const char*> layers(_validationLayersNames.size(), nullptr);
        validationLayerParam.swap(layers);
        std::transform( _validationLayersNames.begin(), _validationLayersNames.end(), validationLayerParam.begin(), [](const std::string &str) -> const char * { return str.c_str(); } );
    } else {
        for ( auto &layerName : _requestedValidationLayers ) {
            auto vlIt = std::find( _validationLayersNames.begin(), _validationLayersNames.end(), layerName );
            if ( vlIt != _validationLayersNames.end() )
                validationLayerParam.push_back( vlIt->c_str() );
        }
    }
    createInfo.enabledLayerCount   = static_cast<uint32_t>( validationLayerParam.size() );
    createInfo.ppEnabledLayerNames = validationLayerParam.empty() ? nullptr : validationLayerParam.data();

    if (vkCreateDevice(physicalDevice._physical_device, &createInfo, nullptr, &_device) != VK_SUCCESS)
        throw CException("failed to create logical device!");


    //-------------------------------------------
    // Retrieving queue handles
    //-------------------------------------------

    //! Device queues are implicitly cleaned up when the device is destroyed, so we don't need to do anything in cleanup.
    //! We can use the vkGetDeviceQueue function to retrieve queue handles for each queue family. 

    vkGetDeviceQueue(_device, physicalDevice._queue._graphics[0], 0, &_graphicsQueue);
    if ( _graphicsQueue == VK_NULL_HANDLE )
        throw CException("failed to retrieve graphics queue!");

    vkGetDeviceQueue(_device, physicalDevice._queue._surface_support[0], 0, &_presentQueue);
    if ( _presentQueue == VK_NULL_HANDLE )
        throw CException("failed to retrieve surface support (presentation) queue!");
}


/******************************************************************//**
* \brief   Check if the required device extensions are valid
* 
* \author  gernot
* \date    2018-05-16
* \version 1.0
**********************************************************************/
bool CAppliction::checkDeviceExtensionSupport(
    const std::set<std::string> &device_extensions //!< available device handle
    ) { 

    // check if requested device extension exists
    for ( auto &requ_ext : _requestedDeviceExtensions ) {
        if ( device_extensions.find(requ_ext) == device_extensions.end() )
            return false;
    }

    return true;
}


/******************************************************************//**
* \brief   populate swapchain details
* 
* \author  gernot
* \date    2018-05-17
* \version 1.0
**********************************************************************/
TSwapChainSupportDetails CAppliction::querySwapChainSupport( 
    VkPhysicalDevice device //!< device handle
    ) {

    if ( device == VK_NULL_HANDLE )
       throw CException("no physical device!");
    if ( _surface == VK_NULL_HANDLE )
       throw CException("no vulkan surface!"); 

    
    TSwapChainSupportDetails details;

    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, _surface, &details._capabilities);


    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, _surface, &formatCount, nullptr);

    if (formatCount != 0) {
        details._formats.resize(formatCount);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, _surface, &formatCount, details._formats.data());
    }


    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, _surface, &presentModeCount, nullptr);

    if (presentModeCount != 0) {
        details._presentModes.resize(presentModeCount);
        vkGetPhysicalDeviceSurfacePresentModesKHR(device, _surface, &presentModeCount, details._presentModes.data());
    }

    return details;
}


/******************************************************************//**
* \brief   chose a proper surface format  (color depth)
* 
* \author  gernot
* \date    2018-05-19
* \version 1.0
**********************************************************************/
VkSurfaceFormatKHR CAppliction::chooseSwapSurfaceFormat( 
    const std::vector<VkSurfaceFormatKHR>& availableFormats //!< available formats of the selected device
    ) {

    //! Each `VkSurfaceFormatKHR` entry contains a format and a colorSpace member.
    //! The format member specifies the color channels and types.
    //! For example, `VK_FORMAT_B8G8R8A8_UNORM` means that we store the B, G, R and alpha channels in that order with an 8 bit unsigned integer for a total of 32 bits per pixel.
    //! The colorSpace member indicates if the SRGB color space is supported or not using the `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` flag.
    //! Note that this flag used to be called `VK_COLORSPACE_SRGB_NONLINEAR_KHR` in old versions of the specification.
    
    //! The best case scenario is that the surface has no preferred format, which Vulkan indicates by only returning one `VkSurfaceFormatKHR` entry which has its format member set to VK_FORMAT_UNDEFINED.
    if (availableFormats.size() == 1 && availableFormats[0].format == VK_FORMAT_UNDEFINED) {
        return {VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR};
    }  

    for (const auto& availableFormat : availableFormats) {
        if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            return availableFormat;
        }
    }

    assert( false );
    return availableFormats[0];
}


/******************************************************************//**
* \brief   choose a proper presentation mode
* 
* \author  gernot
* \date    2018-05-19
* \version 1.0
**********************************************************************/
VkPresentModeKHR CAppliction::chooseSwapPresentMode( 
    const std::vector<VkPresentModeKHR> availablePresentModes //!< available formats of the selected device
    ) {

    //! The presentation mode is arguably the most important setting for the swap chain, because it represents the actual conditions for showing images to the screen.
    //! There are four possible modes available in Vulkan:
    //! - `VK_PRESENT_MODE_IMMEDIATE_KHR`: Images submitted by your application are transferred to the screen right away, which may result in tearing.
    //! - `VK_PRESENT_MODE_FIFO_KHR`: The swap chain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue.
    //!    If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as "vertical blank".
    //! - `VK_PRESENT_MODE_FIFO_RELAXED_KHR`: This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank.
    //!    Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.
    //! - `VK_PRESENT_MODE_MAILBOX_KHR`: This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones.
    //!    This mode can be used to implement triple buffering, which allows you to avoid tearing with significantly less latency issues than standard vertical sync that uses double buffering.

    VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR;

    for (const auto& availablePresentMode : availablePresentModes) {
        if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
            return availablePresentMode;
        } else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) {
            bestMode = availablePresentMode;
        }
    }

    return bestMode;
}


/******************************************************************//**
* \brief   Chose a proper swap chain 2D extent.
* 
* \author  gernot
* \date    2018-05-19
* \version 1.0
**********************************************************************/
VkExtent2D CAppliction::chooseSwapExtent( 
  const VkSurfaceCapabilitiesKHR& capabilities //!< capabilities of the selected device
  ) {

    //! The swap extent is the resolution of the swap chain images and it's almost always exactly equal to the resolution of the window that we're drawing to.
    //! The range of the possible resolutions is defined in the VkSurfaceCapabilitiesKHR structure.
    //! Vulkan tells us to match the resolution of the window by setting the width and height in the currentExtent member.
    //! However, some window managers do allow us to differ here and this is indicated by setting the width and height in currentExtent to a special value: the maximum value of `uint32_t`.
    //! In that case we'll pick the resolution that best matches the window within the minImageExtent and maxImageExtent bounds.

    if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
        return capabilities.currentExtent;
    } else {

        //! To handle window resizes properly, we also need to query the current size of the framebuffer to make sure that the swap chain images have the (new) right size.

        int width = 0, height = 0;
        while (width == 0 || height == 0) {
            glfwGetFramebufferSize(_wnd, &width, &height);
            glfwWaitEvents();
        }
        
        VkExtent2D actualExtent = {
            static_cast<uint32_t>(width),
            static_cast<uint32_t>(height)
        };

        actualExtent.width  = std::max( capabilities.minImageExtent.width, std::min( capabilities.maxImageExtent.width, actualExtent.width ) );
        actualExtent.height = std::max( capabilities.minImageExtent.height, std::min( capabilities.maxImageExtent.height, actualExtent.height ) );
       
        return actualExtent;
    }
}


/******************************************************************//**
* \brief   create the swap chain (images)
* 
* \author  gernot
* \date    2018-05-16
* \version 1.0
**********************************************************************/
void CAppliction::createSwapChain( void ) {

    if ( _instance == VK_NULL_HANDLE )
        throw CException("no vulkan instance!");
    if ( _surface == VK_NULL_HANDLE )
        throw CException("no vulkan surface!");
    if ( _physicalDevices.empty() )
        throw CException("no physical device!");

    //! Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen.
    //! This infrastructure is known as the swap chain and must be created explicitly in Vulkan.
    //! The swap chain is essentially a queue of images that are waiting to be presented to the screen.

    TPhysicalDevice &physicalDevice = _physicalDevices[0];


    //-------------------------------------------
    // Creating the swap chain
    //-------------------------------------------

    TSwapChainSupportDetails &swapChainSupport = physicalDevice._swapcahin_support;

    _surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport._formats);
    _presentMode   = chooseSwapPresentMode(swapChainSupport._presentModes);
    _extent        = chooseSwapExtent(swapChainSupport._capabilities);
  
    // determine the number o f images in the swap chain
    uint32_t imageCount = swapChainSupport._capabilities.minImageCount + 1;
    if (swapChainSupport._capabilities.maxImageCount > 0 && imageCount > swapChainSupport._capabilities.maxImageCount) {
        imageCount = swapChainSupport._capabilities.maxImageCount;
    }

    VkSwapchainCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    createInfo.surface = _surface;


    //! The `imageArrayLayers` specifies the amount of layers each image consists of.
    //! This is always 1 unless you are developing a stereoscopic 3D application.
    //! The `imageUsage` bit field specifies what kind of operations we'll use the images in the swap chain for.
    //! In this tutorial we're going to render directly to them, which means that they're used as color attachment.
    //! It is also possible that you'll render images to a separate image first to perform operations like post-processing.
    //! In that case you may use a value like `VK_IMAGE_USAGE_TRANSFER_DST_BIT` instead and use a memory operation to transfer the rendered image to a swap chain image.

    createInfo.minImageCount    = imageCount;
    createInfo.imageFormat      = _surfaceFormat.format;
    createInfo.imageColorSpace  = _surfaceFormat.colorSpace;
    createInfo.imageExtent      = _extent;
    createInfo.imageArrayLayers = 1;
    createInfo.imageUsage       = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

    
    //! Next, we need to specify how to handle swap chain images that will be used across multiple queue families.
    //! That will be the case in our application if the graphics queue family is different from the presentation queue.
    //! We'll be drawing on the images in the swap chain from the graphics queue and then submitting them on the presentation queue.
    //! There are two ways to handle images that are accessed from multiple queues:
    //! - `VK_SHARING_MODE_EXCLUSIVE`: An image is owned by one queue family at a time and ownership must be explicitly transfered before using it in another queue family.
    //!   This option offers the best performance.
    //! - `VK_SHARING_MODE_CONCURRENT`: Images can be used across multiple queue families without explicit ownership transfers.

    //! If the graphics queue family and presentation queue family are the same, which will be the case on most hardware,
    //! then we should stick to exclusive mode, because concurrent mode requires you to specify at least two distinct queue families.

    TDeviceQueueInfo &indices = physicalDevice._queue;
    uint32_t queueFamilyIndices[] = {(uint32_t)indices._graphics[0], (uint32_t)indices._surface_support[0]};

    if (indices._graphics[0] != indices._surface_support[0]) {
        createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
        createInfo.queueFamilyIndexCount = 2;
        createInfo.pQueueFamilyIndices = queueFamilyIndices;
    } else {
        createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
        createInfo.queueFamilyIndexCount = 0; // Optional
        createInfo.pQueueFamilyIndices = nullptr; // Optional
    }

    
    //! We can specify that a certain transform should be applied to images in the swap chain if it is supported (`supportedTransforms` in `capabilities`),
    //! like a 90 degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.

    createInfo.preTransform = swapChainSupport._capabilities.currentTransform;


    //! The compositeAlpha field specifies if the alpha channel should be used for blending with other windows in the window system.
    //! You'll almost always want to simply ignore the alpha channel, hence `VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR`.

    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;


    //! The presentMode member speaks for itself.
    //! If the clipped member is set to VK_TRUE then that means that we don't care about the color of pixels that are obscured, for example because another window is in front of them.
    //! Unless you really need to be able to read these pixels back and get predictable results, you'll get the best performance by enabling clipping.

    createInfo.presentMode = _presentMode;
    createInfo.clipped     = VK_TRUE;


    //! That leaves one last field, oldSwapChain.
    //! With Vulkan it's possible that your swap chain becomes invalid or unoptimized while your application is running, for example because the window was resized. 
    //! In that case the swap chain actually needs to be recreated from scratch and a reference to the old one must be specified in this field.
    
    createInfo.oldSwapchain = VK_NULL_HANDLE;


    if (vkCreateSwapchainKHR(_device, &createInfo, nullptr, &_swapChain) != VK_SUCCESS) {
        throw CException("failed to create swap chain!");
    }


    //-------------------------------------------
    // Retrieving the swap chain images
    //-------------------------------------------
    
    //! The images were created by the implementation for the swap chain and they will be automatically cleaned up once the swap chain has been destroyed, therefore we don't need to add any cleanup code.

    if (vkGetSwapchainImagesKHR(_device, _swapChain, &imageCount, nullptr) != VK_SUCCESS || imageCount == 0)
         throw CException("failed to get number of swap chain images");
    _swapChainImages.resize(imageCount);
    if (vkGetSwapchainImagesKHR(_device, _swapChain, &imageCount, _swapChainImages.data()) != VK_SUCCESS)
         throw CException("failed to get swap chain image handles");
}


/******************************************************************//**
* \brief   create the render passes
* 
* \author  gernot
* \date    2018-05-21
* \version 1.0
**********************************************************************/
void CAppliction::createRenderPass( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");


    //! We need to tell Vulkan about the framebuffer attachments that will be used while rendering.
    //! We need to specify how many color and depth buffers there will be, how many samples to use for each of them and how their contents should be handled throughout the rendering operations.
    //! All of this information is wrapped in a render pass object.


    //-------------------------------------------
    // Attachment description
    //-------------------------------------------

    VkAttachmentDescription colorAttachment = {};

    //! The `format` of the color attachment should match the format of the swap chain images,
    //! and we're not doing anything with multisampling, so we'll stick to 1 sample.

    colorAttachment.format = _surfaceFormat.format;
    colorAttachment.samples = _msaaSamples;

    //! The loadOp and storeOp determine what to do with the data in the attachment before rendering and after rendering.
    //! We have the following choices for loadOp:
    //! - `VK_ATTACHMENT_LOAD_OP_LOAD`: Preserve the existing contents of the attachment
    //! - `VK_ATTACHMENT_LOAD_OP_CLEAR`: Clear the values to a constant at the start
    //! - `VK_ATTACHMENT_LOAD_OP_DONT_CARE`: Existing contents are undefined; we don't care about them
    //! In our case we're going to use the clear operation to clear the framebuffer to black before drawing a new frame.
    //! There are only two possibilities for the storeOp:
    //! - `VK_ATTACHMENT_STORE_OP_STORE`: Rendered contents will be stored in memory and can be read later
    //! - `VK_ATTACHMENT_STORE_OP_DONT_CARE`: Contents of the framebuffer will be undefined after the rendering operation
    //! We're interested in seeing the rendered triangle on the screen, so we're going with the store operation here.

    //! The loadOp and storeOp apply to color and depth data, and stencilLoadOp / stencilStoreOp apply to stencil data.
    //! Our application won't do anything with the stencil buffer, so the results of loading and storing are irrelevant.

    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;

    //! Textures and framebuffers in Vulkan are represented by `VkImage` objects with a certain pixel format, 
    //! however the layout of the pixels in memory can change based on what you're trying to do with an image.
    //! Some of the most common layouts are:
    //! - `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`: Images used as color attachment
    //! - `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`: Images to be presented in the swap chain
    //! - VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`: Images to be used as destination for a memory copy operation
    //! The initialLayout specifies which layout the image will have before the render pass begins.
    //! The finalLayout specifies the layout to automatically transition to when the render pass finishes.
    //! Using `VK_IMAGE_LAYOUT_UNDEFINED` for initialLayout means that we don't care what previous layout the image was in.
    //! The caveat of this special value is that the contents of the image are not guaranteed to be preserved, but that doesn't matter since we're going to clear it anyway.
    //! We want the image to be ready for presentation using the swap chain after rendering, which is why we use `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` as finalLayout.

    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;


    //-------------------------------------------
    // Subpasses and attachment references
    //-------------------------------------------
 
    //! A single render pass can consist of multiple subpasses.
    //! Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another.
    //! If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance.
    
    VkAttachmentReference colorAttachmentRef = {};

    //! The attachment parameter specifies which attachment to reference by its index in the attachment descriptions array.
    //! Our array consists of a single `VkAttachmentDescription`, so its index is 0.
    //! The layout specifies which layout we would like the attachment to have during a subpass that uses this reference. 
    //! Vulkan will automatically transition the attachment to this layout when the subpass is started.
    //! We intend to use the attachment to function as a color buffer and the `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` layout will give us the best performance, as its name implies.

    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;


    //-------------------------------------------
    // depth attachment
    //-------------------------------------------


    VkAttachmentDescription depthAttachment{};
    depthAttachment.format = findDepthFormat();
    depthAttachment.samples = _msaaSamples;
    depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthAttachmentRef{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;


    //-------------------------------------------
    // MSAA
    //-------------------------------------------

    VkAttachmentDescription colorAttachmentResolve{};
    colorAttachmentResolve.format = _surfaceFormat.format;
    colorAttachmentResolve.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachmentResolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachmentResolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachmentResolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachmentResolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachmentResolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentReference colorAttachmentResolveRef{};
    colorAttachmentResolveRef.attachment = 2;
    colorAttachmentResolveRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;


    //! The subpass is described using a `VkSubpassDescription` structure:
    //! Vulkan may also support compute subpasses in the future, so we have to be explicit about this being a graphics subpass.
 
    VkSubpassDescription subpass = {};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;

    //! Next, we specify the reference to the color attachment:
    //! The index of the attachment in this array is directly referenced from the fragment shader with the layout(location = 0) out vec4 outColor directive!
    //! The following other types of attachments can be referenced by a subpass:
    //! - `pInputAttachments`: Attachments that are read from a shader
    //! - `pResolveAttachments`: Attachments used for multisampling color attachments
    //! - `pDepthStencilAttachment`: Attachments for depth and stencil data
    //! - `pPreserveAttachments`: Attachments that are not used by this subpass, but for which the data must be preserved

    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    subpass.pResolveAttachments = &colorAttachmentResolveRef;
    subpass.pDepthStencilAttachment = &depthAttachmentRef;
    

    //-------------------------------------------
    // Subpass dependencies
    //-------------------------------------------
    
    //! Remember that the subpasses in a render pass automatically take care of image layout transitions.
    //! These transitions are controlled by subpass dependencies, which specify memory and execution dependencies between subpasses.
    //! We have only a single subpass right now, but the operations right before and right after this subpass also count as implicit "subpasses".

    //! There are two built-in dependencies that take care of the transition at the start of the render pass and at the end of the render pass, but the former does not occur at the right time.
    //! It assumes that the transition occurs at the start of the pipeline, but we haven't acquired the image yet at that point!
    //! There are two ways to deal with this problem.
    //! We could change the waitStages for the imageAvailableSemaphore to `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` to ensure that the render passes don't begin until the image is available,
    //! or we can make the render pass wait for the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` stage.
    //! I've decided to go with the second option here, because it's a good excuse to have a look at subpass dependencies and how they work.

    VkSubpassDependency dependency = {};

    //! The first two fields specify the indices of the dependency and the dependent subpass.
    //! The special value `VK_SUBPASS_EXTERNAL` refers to the implicit subpass before or after the render pass depending on whether it is specified in srcSubpass or dstSubpass.
    //! The index 0 refers to our subpass, which is the first and only one. The dstSubpass must always be higher than srcSubpass to prevent cycles in the dependency graph.

    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
    dependency.dstSubpass = 0;

    //! The next two fields specify the operations to wait on and the stages in which these operations occur.
    //! We need to wait for the swap chain to finish reading from the image before we can access it.
    //! This can be accomplished by waiting on the color attachment output stage itself.

    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dependency.srcAccessMask = 0;

    //! The operations that should wait on this are in the color attachment stage and involve the reading and writing of the color attachment.
    //! These settings will prevent the transition from happening until it's actually necessary (and allowed): when we want to start writing colors to it.

    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;


    //-------------------------------------------
    // Render pass
    //-------------------------------------------
   
    //! The render pass object can then be created by filling in the `VkRenderPassCreateInfo` structure with an array of attachments and subpasses. 
    //! The `VkAttachmentReference` objects reference attachments using the indices of this array.

    std::vector<VkAttachmentDescription> attachments = {colorAttachment, depthAttachment, colorAttachmentResolve};
    VkRenderPassCreateInfo renderPassInfo = {};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
    renderPassInfo.pAttachments = attachments.data();
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies = &dependency;

    if (vkCreateRenderPass(_device, &renderPassInfo, nullptr, &_renderPass) != VK_SUCCESS) {
        throw std::runtime_error("failed to create render pass!");
    }
}


/******************************************************************//**
* \brief   Create the image view objects
* 
* \author  gernot
* \date    2018-05-20
* \version 1.0
**********************************************************************/
void CAppliction::createImageViews( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");
    if ( _swapChainImages.empty() )
        throw CException("no swap chain image handles");


    //! To use any `VkImage`, including those in the swap chain, in the render pipeline we have to create a `VkImageView` object.
    //! An image view is quite literally a view into an image.
    //! It describes how to access the image and which part of the image to access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels.

    //! If you were working on a stereographic 3D application, then you would create a swap chain with multiple layers.
    //! You could then create multiple image views for each image representing the views for the left and right eyes by accessing different layers.

    TPhysicalDevice &physicalDevice = _physicalDevices[0];

    _swapChainImageViews.resize(_swapChainImages.size());


    //! for each swap chain image
    for (size_t i = 0; i < _swapChainImages.size(); i++) {
        createImageView( _swapChainImages[i], _surfaceFormat.format, VK_IMAGE_ASPECT_COLOR_BIT, 1, _swapChainImageViews[i] );
    }
}


/******************************************************************//**
* \brief   create shader module from byte code.
* 
* \author  gernot
* \date    2018-05-20
* \version 1.0
**********************************************************************/
VkShaderModule CAppliction::createShaderModule( 
    const std::vector<char>& code //!< byte code
    ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");
   

    VkShaderModuleCreateInfo createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = code.size();
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());


    VkShaderModule shaderModule;
    if (vkCreateShaderModule(_device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
        throw CException("failed to create shader module!");
    }

    return shaderModule;
}


/******************************************************************//**
* \brief   setup descriptor st layouts
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorSetLayout( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Descriptor set layout
    //-------------------------------------------

    //! We need to provide details about every descriptor binding used in the shaders for pipeline creation,
    //! just like we had to do for every vertex attribute and its location index.
    //! We'll set up a new function to define all of this information called createDescriptorSetLayout.
    //! It should be called right before pipeline creation, because we're going to need it there.

    //! The first two fields specify the binding used in the shader and the type of descriptor, which is a uniform buffer object.
    //! It is possible for the shader variable to represent an array of uniform buffer objects, and descriptorCount specifies the number of values in the array.
    //! This could be used to specify a transformation for each of the bones in a skeleton for skeletal animation, for example.
    //! Our MVP transformation is in a single uniform buffer object, so we're using a descriptorCount of 1.
    //! We also need to specify in which shader stages the descriptor is going to be referenced.
    //! The stageFlags field can be a combination of VkShaderStageFlagBits values or the value VK_SHADER_STAGE_ALL_GRAPHICS.
    //! In our case, we're only referencing the descriptor from the vertex shader.

    VkDescriptorSetLayoutBinding uboLayoutBinding = {};
    uboLayoutBinding.binding = 0;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    uboLayoutBinding.pImmutableSamplers = nullptr; // Optional


    //! add a VkDescriptorSetLayoutBinding for a combined image sampler descriptor. 
    //! Make sure to set the stageFlags to indicate that we intend to use the combined image sampler descriptor in the fragment shader.
    //! That's where the color of the fragment is going to be determined.
    //! It is possible to use texture sampling in the vertex shader, for example to dynamically deform a grid of vertices by a height-map.

    VkDescriptorSetLayoutBinding samplerLayoutBinding{};
    samplerLayoutBinding.binding = 1;
    samplerLayoutBinding.descriptorCount = 1;
    samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    samplerLayoutBinding.pImmutableSamplers = nullptr;
    samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;


    //! All of the descriptor bindings are combined into a single VkDescriptorSetLayout object. 

    std::array<VkDescriptorSetLayoutBinding, 2> bindings = {uboLayoutBinding, samplerLayoutBinding};
    VkDescriptorSetLayoutCreateInfo layoutInfo{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
    layoutInfo.pBindings = bindings.data();

    if (vkCreateDescriptorSetLayout(_device, &layoutInfo, nullptr, &_descriptorSetLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create descriptor set layout!");
    }
}


/******************************************************************//**
* \brief   setup the graphics pipeline
* 
* \author  gernot
* \date    2018-05-20
* \version 1.0
**********************************************************************/
void CAppliction::createGraphicsPipeline( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");


    //-------------------------------------------
    // Graphics pipeline
    //-------------------------------------------

    //! Graphics pipeline simplified overview:
    //! - Vertex/index buffer
    //! - Input assembler
    //! - Vertex shader
    //! - Tessellation
    //! - Geometry shader
    //! - Rasterization
    //! - Fragment shader
    //! - Color blending
    //! - Framebuffer

    //! Input assembler, Rasterization and Color blending stage are known as fixed-function stages.
    //! These stages allow you to tweak their operations using parameters, but the way they work is predefined. 

    //! Vertex shader, Tessellation, Geometry shader and Fragment shader stage are programmable, which means that you can upload your own code to the graphics card to apply exactly the operations you want.
    //! This allows you to use fragment shaders, for example, to implement anything from texturing and lighting to ray tracers.
    //! These programs run on many GPU cores simultaneously to process many objects, like vertices and fragments in parallel.
 
    //! The input assembler collects the raw vertex data from the buffers you specify and may also use an index buffer to repeat certain elements without having to duplicate the vertex data itself.

    //! The vertex shader is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space.
    //! It also passes per-vertex data down the pipeline.

    //! The tessellation shaders allow you to subdivide geometry based on certain rules to increase the mesh quality.
    //! This is often used to make surfaces like brick walls and staircases look less flat when they are nearby.

    //! The geometry shader is run on every primitive (triangle, line, point) and can discard it or output more primitives than came in.
    //! This is similar to the tessellation shader, but much more flexible.
    //! However, it is not used much in today's applications because the performance is not that good on most graphics cards except for Intel's integrated GPUs.

    //! The rasterization stage discretizes the primitives into fragments.
    //! These are the pixel elements that they fill on the framebuffer.
    //! Any fragments that fall outside the screen are discarded and the attributes outputted by the vertex shader are interpolated across the fragments.
    //! Usually the fragments that are behind other primitive fragments are also discarded here because of depth testing.

    //! The fragment shader is invoked for every fragment that survives and determines which framebuffer(s) the fragments are written to and with which color and depth values.
    //! It can do this using the interpolated data from the vertex shader, which can include things like texture coordinates and normals for lighting.

    //! The color blending stage applies operations to mix different fragments that map to the same pixel in the framebuffer.
    //! Fragments can simply overwrite each other, add up or be mixed based upon transparency.


    //-------------------------------------------
    // Vulkan graphics pipeline
    //-------------------------------------------

    //! The graphics pipeline in Vulkan is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function.
    //! The disadvantage is that you'll have to create a number of pipelines that represent all of the different combinations of states you want to use in your rendering operations.
    //! However, because all of the operations you'll be doing in the pipeline are known in advance, the driver can optimize for it much better.

    //! The older graphics APIs provided default state for most of the stages of the graphics pipeline.
    //! In Vulkan you have to be explicit about everything, from viewport size to color blending function.


    //-------------------------------------------
    // Shader modules
    //-------------------------------------------

    //! Unlike earlier APIs, shader code in Vulkan has to be specified in a bytecode format as opposed to human-readable syntax like GLSL and HLSL.
    //! This bytecode format is called SPIR-V and is designed to be used with both Vulkan and OpenCL (both Khronos APIs).
    //! It is a format that can be used to write graphics and compute shaders. 


    //-------------------------------------------
    // Loading shaders
    //-------------------------------------------

    auto vertShaderCode = readFile("shaders/shader_1_vert.spv");
    auto fragShaderCode = readFile("shaders/shader_1_frag.spv");


    //-------------------------------------------
    // Creating shader modules
    //-------------------------------------------

    VkShaderModule vertShaderModule = createShaderModule(vertShaderCode);
    VkShaderModule fragShaderModule = createShaderModule(fragShaderCode);


    //-------------------------------------------
    // Shader stage creation
    //-------------------------------------------
    
    //! The VkShaderModule object is just a dumb wrapper around the bytecode buffer.
    //! The shaders aren't linked to each other yet and they haven't even been given a purpose yet.
    //! Assigning a shader module to either the vertex or fragment shader stage in the pipeline happens through a `VkPipelineShaderStageCreateInfo` structure,
    //! which is part of the actual pipeline creation process.

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    //! There is one more (optional) member, pSpecializationInfo, which we won't be using here, but is worth discussing.
    //! It allows you to specify values for shader constants.
    //! You can use a single shader module where its behavior can be configured at pipeline creation by specifying different values for the constants used in it.
    //! This is more efficient than configuring the shader using variables at render time, because the compiler can do optimizations like eliminating if statements that depend on these values.
    //! If you don't have any constants like that, then you can set the member to nullptr, which our `struct` initialization does automatically.

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };


    //-------------------------------------------
    // Vertex input
    //-------------------------------------------
    
    //! The `VkPipelineVertexInputStateCreateInfo` structure describes the format of the vertex data that will be passed to the vertex shader.
    //! It describes this in roughly two ways:
    //! - Bindings: spacing between data and whether the data is per-vertex or per-instance (see instancing)
    //! - Attribute descriptions: type of the attributes passed to the vertex shader, which binding to load them from and at which offset

    // The `pVertexBindingDescriptions` and `pVertexAttributeDescriptions` members point to an array of `struct`s that describe the aforementioned details for loading vertex data.
   
    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexBindingDescriptionCount = 0;
    vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional
    vertexInputInfo.vertexAttributeDescriptionCount = 0;
    vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional

    auto bindingDescription    = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
    vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();


    //-------------------------------------------
    // Input assembly
    //-------------------------------------------

    //! The `VkPipelineInputAssemblyStateCreateInfo` `struct` describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled.
    //! The former is specified in the topology member and can have values like:
    //! - `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`: points from vertices
    //! - `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`: line from every 2 vertices without reuse
    //! - `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP`: the end vertex of every line is used as start vertex for the next line
    //! - `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: triangle from every 3 vertices without reuse
    //! - `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`: the second and third vertex of every triangle are used as first two vertices of the next triangle
    
    //! Normally, the vertices are loaded from the vertex buffer by index in sequential order, but with an element buffer you can specify the indices to use yourself.
    //! This allows you to perform optimizations like reusing vertices.
    //! If you set the primitiveRestartEnable member to `VK_TRUE , then it's possible to break up lines and triangles in the _STRIP topology modes by using a special index of 0xFFFF or 0xFFFFFFFF.

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    //-------------------------------------------
    // Viewports and scissors
    //-------------------------------------------

    //! A viewport basically describes the region of the framebuffer that the output will be rendered to. 
    //! This will almost always be (0, 0) to (width, height) and in this tutorial that will also be the case.

    //! Remember that the size of the swap chain and its images may differ from the WIDTH and HEIGHT of the window. The swap chain images will be used as framebuffers later on, so we should stick to their size.

    //! The minDepth and maxDepth values specify the range of depth values to use for the framebuffer.
    //! These values must be within the [0.0f, 1.0f] range, but minDepth may be higher than maxDepth.
    //! If you aren't doing anything special, then you should stick to the standard values of 0.0f and 1.0f.

    //! While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored.
    //! Any pixels outside the scissor rectangles will be discarded by the rasterizer.
    //! They function like a filter rather than a transformation. The difference is illustrated below.
    //! Note that the left scissor rectangle is just one of the many possibilities that would result in that image, as long as it's larger than the viewport.

    VkViewport viewport = {};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width = (float)_extent.width;
    viewport.height = (float)_extent.height;
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    VkRect2D scissor = {};
    scissor.offset = {0, 0};
    scissor.extent = _extent;

    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = &viewport;
    viewportState.scissorCount = 1;
    viewportState.pScissors = &scissor;


    //-------------------------------------------
    // Rasterizer
    //-------------------------------------------
    
    //! The rasterizer takes the geometry that is shaped by the vertices from the vertex shader and turns it into fragments to be colored by the fragment shader.
    //! It also performs depth testing, face culling and the scissor test, and it can be configured to output fragments that fill entire polygons or just the edges (wireframe rendering).
    //! All this is configured using the `VkPipelineRasterizationStateCreateInfo` structure.

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    
    //! If `depthClampEnable` is set to `VK_TRUE`, then fragments that are beyond the near and far planes are clamped to them as opposed to discarding them.
    //! This is useful in some special cases like shadow maps.
    //! Using this requires enabling a GPU feature.

    rasterizer.depthClampEnable = VK_FALSE;
   
    //! If `rasterizerDiscardEnable` is set to `VK_TRUE`, then geometry never passes through the rasterizer stage.
    // This basically disables any output to the framebuffer.

    rasterizer.rasterizerDiscardEnable = VK_FALSE;

    //! The polygonMode determines how fragments are generated for geometry.
    //! The following modes are available:
    //! - `VK_POLYGON_MODE_FILL`: fill the area of the polygon with fragments
    //! - `VK_POLYGON_MODE_LINE`: polygon edges are drawn as lines
    //! - `VK_POLYGON_MODE_POINT`: polygon vertices are drawn as points
    //! Using any mode other than fill requires enabling a GPU feature.

    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;

    //! The `lineWidth` member is straightforward, it describes the thickness of lines in terms of number of fragments.
    //! The maximum line width that is supported depends on the hardware and any line thicker than 1.0f requires you to enable the wideLines GPU feature.

    rasterizer.lineWidth = 1.0f;

    //! The `cullMode` variable determines the type of face culling to use.
    //! You can disable culling, cull the front faces, cull the back faces or both.
    //! The `frontFace` variable specifies the vertex order for faces to be considered front-facing and can be clockwise or counterclockwise.

    rasterizer.cullMode = _enable_face_culling ? VK_CULL_MODE_BACK_BIT : VK_CULL_MODE_NONE;
    //rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;

    //! The rasterizer can alter the depth values by adding a constant value or biasing them based on a fragment's slope.
    //! This is sometimes used for shadow mapping, but we won't be using it.
    //! Just set `depthBiasEnable` to `VK_FALSE`.

    rasterizer.depthBiasEnable = VK_FALSE;
    rasterizer.depthBiasConstantFactor = 0.0f; // Optional
    rasterizer.depthBiasClamp = 0.0f; // Optional
    rasterizer.depthBiasSlopeFactor = 0.0f; // Optional


    //-------------------------------------------
    // Multisampling
    //-------------------------------------------

    //! The `VkPipelineMultisampleStateCreateInfo` `struct` configures multisampling, which is one of the ways to perform anti-aliasing.
    //! It works by combining the fragment shader results of multiple polygons that rasterize to the same pixel.
    //! This mainly occurs along edges, which is also where the most noticeable aliasing artifacts occur.
    //! Because it doesn't need to run the fragment shader multiple times if only one polygon maps to a pixel, it is significantly less expensive than simply rendering to a higher resolution and then downscaling.
    //! Enabling it requires enabling a GPU feature.

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_TRUE; // enable sample shading in the pipeline
    multisampling.minSampleShading = .2f; // min fraction for sample shading; closer to one is smoother
    //multisampling.minSampleShading = 1.0f; // Optional
    multisampling.rasterizationSamples = _msaaSamples;
    multisampling.pSampleMask = nullptr; // Optional
    multisampling.alphaToCoverageEnable = VK_FALSE; // Optional
    multisampling.alphaToOneEnable = VK_FALSE; // Optional


    //-------------------------------------------
    // Depth and stencil testing
    //-------------------------------------------
    
    //! If you are using a depth and/or stencil buffer, then you also need to configure the depth and stencil tests using `VkPipelineDepthStencilStateCreateInfo`.
    

    //-------------------------------------------
    // Color blending
    //-------------------------------------------
    
    //! After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer.
    //! This transformation is known as color blending and there are two ways to do it:
    //! - Mix the old and new value to produce a final color
    //! - Combine the old and new value using a bitwise operation
    //! There are two types of `struct`s to configure color blending. 
    //! The first `struct`, `VkPipelineColorBlendAttachmentState` contains the configuration per attached framebuffer
    //! and the second `struct`, `VkPipelineColorBlendStateCreateInfo` contains the global color blending settings.

    //! This per-framebuffer `struct` allows you to configure the first way of color blending.
    //! The operations that will be performed are best demonstrated using the following pseudocode:
    //!
    //! if (blendEnable) {
    //!     finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb);
    //!     finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a);
    //! } else {
    //!     finalColor = newColor;
    //! }
    //! finalColor = finalColor & colorWriteMask;

    //! If blendEnable is set to `VK_FALSE`, then the new color from the fragment shader is passed through unmodified.
    //! Otherwise, the two mixing operations are performed to compute a new color. 
    //! The resulting color is AND'd with the colorWriteMask to determine which channels are actually passed through.
    //!
    //! The most common way to use color blending is to implement alpha blending, where we want the new color to be blended with the old color based on its opacity.
    //! The finalColor should then be computed as follows:
    //!
    //! finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;
    //! finalColor.a = newAlpha.a;

    //! If you want to use the second method of blending (bitwise combination), then you should set `logicOpEnable` to `VK_TRUE`.
    //! The bitwise operation can then be specified in the logicOp field.
    //! Note that this will automatically disable the first method, as if you had set `blendEnable` to `VK_FALSE` for every attached framebuffer!
    //! The `colorWriteMask` will also be used in this mode to determine which channels in the framebuffer will actually be affected.
    //! It is also possible to disable both modes, as we've done here, in which case the fragment colors will be written to the framebuffer unmodified.

    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.blendEnable = VK_FALSE;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY; // Optional
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;
    colorBlending.blendConstants[0] = 0.0f; // Optional
    colorBlending.blendConstants[1] = 0.0f; // Optional
    colorBlending.blendConstants[2] = 0.0f; // Optional
    colorBlending.blendConstants[3] = 0.0f; // Optional


    //-------------------------------------------
    // Dynamic state
    //-------------------------------------------
    
    //! A limited amount of the state that we've specified in the previous `struct`s can actually be changed without recreating the pipeline.
    //! Examples are the size of the viewport, line width and blend constants.
    //! If you want to do that, then you'll have to fill in a `VkPipelineDynamicStateCreateInfo` structure like this:

    VkDynamicState dynamicStates[] = {
        VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_LINE_WIDTH
    };

    VkPipelineDynamicStateCreateInfo dynamicState = {};
    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicState.dynamicStateCount = 2;
    dynamicState.pDynamicStates = dynamicStates;


    //-------------------------------------------
    // Pipeline layout
    //-------------------------------------------

    //! You can use uniform values in shaders, which are globals similar to dynamic state variables that can be changed at drawing time to alter the behavior of your shaders without having to recreate them.
    //! They are commonly used to pass the transformation matrix to the vertex shader, or to create texture samplers in the fragment shader.
    //! These uniform values need to be specified during pipeline creation by creating a `VkPipelineLayout` object.
    //! Even though we won't be using them until a future chapter, we are still required to create an empty pipeline layout.

    //! We need to specify the descriptor set layout during pipeline creation to tell Vulkan which descriptors the shaders will be using.
    //! Descriptor set layouts are specified in the pipeline layout object. Modify the VkPipelineLayoutCreateInfo to reference the layout object.

    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &_descriptorSetLayout;
    pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional
    pipelineLayoutInfo.pPushConstantRanges = nullptr; // Optional

    if (vkCreatePipelineLayout(_device, &pipelineLayoutInfo, nullptr, &_pipelineLayout) != VK_SUCCESS) {
        throw CException( "failed to create pipeline layout!" );
    }


    //-------------------------------------------
    // depth test
    //-------------------------------------------

    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = _enable_depth_test ? VK_TRUE : VK_FALSE;
    depthStencil.depthWriteEnable = _enable_depth_test ? VK_TRUE : VK_FALSE;
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    
    depthStencil.stencilTestEnable = VK_FALSE;
    //depthStencil.front{}; // Optional
    //depthStencil.back{}; // Optional


    //-------------------------------------------
    // Graphics pipeline
    //-------------------------------------------

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;

    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pDepthStencilState = &depthStencil;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.pDynamicState = nullptr; // Optional

    pipelineInfo.layout = _pipelineLayout;

    pipelineInfo.renderPass = _renderPass;
    pipelineInfo.subpass = 0;

    //! And finally we have the reference to the render pass and the index of the sub pass where this graphics pipeline will be used.
    //! It is also possible to use other render passes with this pipeline instead of this specific instance,
    //! but they have to be compatible with renderPass.

    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // Optional
    pipelineInfo.basePipelineIndex = -1; // Optional

    //! There are actually two more parameters: `basePipelineHandle` and `basePipelineIndex`.
    //! Vulkan allows you to create a new graphics pipeline by deriving from an existing pipeline.
    //! The idea of pipeline derivatives is that it is less expensive to set up pipelines when they have much functionality in common with an existing pipeline and switching between pipelines from the same parent can also be done quicker.
    //! You can either specify the handle of an existing pipeline with basePipelineHandle or reference another pipeline that is about to be created by index with basePipelineIndex.
    //! Right now there is only a single pipeline, so we'll simply specify a null handle and an invalid index.
    //! These values are only used if the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag is also specified in the flags field of `VkGraphicsPipelineCreateInfo`.

    if (vkCreateGraphicsPipelines(_device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &_graphicsPipeline) != VK_SUCCESS) {
        throw CException("failed to create graphics pipeline!");
    }


    // cleanup the shader modules
    vkDestroyShaderModule(_device, fragShaderModule, nullptr);
    vkDestroyShaderModule(_device, vertShaderModule, nullptr);

}


/******************************************************************//**
* \brief   Create the framebuffers.
* 
* \author  gernot
* \date    2018-05-25
* \version 1.0
**********************************************************************/
void CAppliction::createFramebuffers( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    _swapChainFramebuffers.resize(_swapChainImageViews.size());

    for (size_t i = 0; i < _swapChainImageViews.size(); i++) {
        std::vector<VkImageView> attachments = {
            _colorImageView.front(),
            _depthImageView.front(),
            _swapChainImageViews[i],
        };

        VkFramebufferCreateInfo framebufferInfo = {};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = _renderPass;
        framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());;
        framebufferInfo.pAttachments = attachments.data();;
        framebufferInfo.width = _extent.width;
        framebufferInfo.height = _extent.height;
        framebufferInfo.layers = 1;

        if (vkCreateFramebuffer(_device, &framebufferInfo, nullptr, &_swapChainFramebuffers[i]) != VK_SUCCESS) {
            throw CException("failed to create framebuffer!");
        }
    }
}


/******************************************************************//**
* \brief   create the command pool.
* 
* \author  gernot
* \date    2018-05-25
* \version 1.0
**********************************************************************/
void CAppliction::createCommandPool( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");
    if ( _physicalDevices.empty() )
        throw CException("no physical device!");

    TPhysicalDevice &physicalDevice = _physicalDevices[0];
    if (physicalDevice._queue._graphics.empty() )
        throw CException("no graphics device queue!");

    //! Commands in Vulkan, like drawing operations and memory transfers, are not executed directly using function calls.
    //! You have to record all of the operations you want to perform in command buffer objects.
    //! The advantage of this is that all of the hard work of setting up the drawing commands can be done in advance and in multiple threads.
    //! After that, you just have to tell Vulkan to execute the commands in the main loop.


    //-------------------------------------------
    // Command pools
    //-------------------------------------------

    //! We have to create a command pool before we can create command buffers.
    //! Command pools manage the memory that is used to store the buffers and command buffers are allocated from them.
   
    //! Command buffers are executed by submitting them on one of the device queues, like the graphics and presentation queues we retrieved.
    //! Each command pool can only allocate command buffers that are submitted on a single type of queue.
    //! We're going to record commands for drawing, which is why we've chosen the graphics queue family.
    
    //! There are two possible flags for command pools:
    //! - `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`: Hint that command buffers are rerecorded with new commands very often (may change memory allocation behavior)
    //! - `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`: Allow command buffers to be rerecorded individually, without this flag they all have to be reset together

    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = physicalDevice._queue._graphics[0];
    poolInfo.flags = 0; // Optional

    if (vkCreateCommandPool(_device, &poolInfo, nullptr, &_commandPool) != VK_SUCCESS) {
        throw CException("failed to create command pool!");
    }
}

/******************************************************************//**
* \brief Evaluate the memory type.  
* 
* \author  gernot
* \date    2018-11-04
* \version 1.0
**********************************************************************/
uint32_t CAppliction::findMemoryType( 
    VkPhysicalDevice      device,     //!< I - the devices
    uint32_t              typeFilter, //!< I - type
    VkMemoryPropertyFlags properties  //!< I - properties
    ) {

    //! Graphics cards can offer different types of memory to allocate from.
    //! Each type of memory varies in terms of allowed operations and performance characteristics.
    //! We need to combine the requirements of the buffer and our own application requirements to find the right type of memory to use.
  
    //! The `typeFilter` parameter will be used to specify the bit field of memory types that are suitable.
    //! That means that we can find the index of a suitable memory type by simply iterating over them and checking if the corresponding bit is set to 1.
    //! However, we're not just interested in a memory type that is suitable for the vertex buffer.
    //! We also need to be able to write our vertex data to that memory.
    //! The memoryTypes array consists of `VkMemoryType` `structs` that specify the heap and properties of each type of memory.
    //! The properties define special features of the memory, like being able to map it so we can write to it from the CPU.
    //! This property is indicated with `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, but we also need to use the `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` property.

    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(device, &memProperties);

    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw CException("failed to find suitable memory type!");
}


/******************************************************************//**
* \brief Begin executing a command buffer.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
VkCommandBuffer CAppliction::beginSingleTimeCommands( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //! Memory transfer operations are executed using command buffers, just like drawing commands. 
    //! Therefore we must first allocate a temporary command buffer. 
    //! You may wish to create a separate command pool for these kinds of short-lived buffers, because the implementation may be able to apply memory allocation optimizations.
    //! You should use the VK_COMMAND_POOL_CREATE_TRANSIENT_BIT flag during command pool generation in that case.

    VkCommandBufferAllocateInfo allocInfo = {};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = _commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(_device, &allocInfo, &commandBuffer);
    
    //! The VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag that we used for the drawing command buffers is not necessary here,
    //! because we're only going to use the command buffer once and wait with returning from the function until the copy operation has finished executing.
    //! It's good practice to tell the driver about our intent using VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT.

    VkCommandBufferBeginInfo beginInfo = {};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

    vkBeginCommandBuffer(commandBuffer, &beginInfo);

    return commandBuffer;
}


/******************************************************************//**
* \brief End execute command buffer.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::endSingleTimeCommands( 
    VkCommandBuffer commandBuffer //!< I - command buffer
    ) {

    //! Contents of buffers are transferred using the vkCmdCopyBuffer command.
    //! It takes the source and destination buffers as arguments, and an array of regions to copy.
    //! The regions are defined in `VkBufferCopy`` structures and consist of a source buffer offset, destination buffer offset and size.
    //! It is not possible to specify VK_WHOLE_SIZE here, unlike the vkMapMemory command.

    vkEndCommandBuffer(commandBuffer);

    //! This command buffer only contains the copy command, so we can stop recording right after that.
    //! Now execute the command buffer to complete the transfer:

    VkSubmitInfo submitInfo = {};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(_graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(_graphicsQueue);

    //! Unlike the draw commands, there are no events we need to wait on this time. We just want to execute the transfer on the buffers immediately.
    //! There are again two possible ways to wait on this transfer to complete.
    //! We could use a fence and wait with vkWaitForFences, or simply wait for the transfer queue to become idle with vkQueueWaitIdle.
    //! A fence would allow you to schedule multiple transfers simultaneously and wait for all of them complete, instead of executing one at a time.
    //! That may give the driver more opportunities to optimize.

    vkFreeCommandBuffers(_device, _commandPool, 1, &commandBuffer);
}


/******************************************************************//**
* \brief Abstract image creation.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::createImage(
    uint32_t               width,      //!< I -
    uint32_t               height,     //!< I -
    uint32_t               mipLevels,  //!< I -
    VkSampleCountFlagBits  numSamples, //!< I -
    VkFormat               format,     //!< I -
    VkImageTiling          tiling,     //!< I -
    VkImageUsageFlags      usage,      //!< I -
    VkMemoryPropertyFlags  properties, //!< I -
    VkImage               &image,      //!< O - texture image
    VkDeviceMemory        &imageMemory //!< O - texture image memory
    ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Texture Image
    //-------------------------------------------

    //! The image type, specified in the imageType field, tells Vulkan with what kind of coordinate system the texels in the image are going to be addressed.
    //! It is possible to create 1D, 2D and 3D images.
    //! One dimensional images can be used to store an array of data or gradient, two dimensional images are mainly used for textures, and three dimensional images can be used to store voxel volumes, for example.
    //! The extent field specifies the dimensions of the image, basically how many texels there are on each axis. That's why depth must be 1 instead of 0. Our texture will not be an array and we won't be using mipmapping for now.
    //! Vulkan supports many possible image formats, but we should use the same format for the texels as the pixels in the buffer, otherwise the copy operation will fail.
    //! The tiling field can have one of two values:
    //!     VK_IMAGE_TILING_LINEAR: Texels are laid out in row-major order like our pixels array
    //!     VK_IMAGE_TILING_OPTIMAL: Texels are laid out in an implementation defined order for optimal access
    //! Unlike the layout of an image, the tiling mode cannot be changed at a later time. If you want to be able to directly access texels in the memory of the image, then you must use VK_IMAGE_TILING_LINEAR.
    //! We will be using a staging buffer instead of a staging image, so this won't be necessary. We will be using VK_IMAGE_TILING_OPTIMAL for efficient access from the shader.
    //! There are only two possible values for the initialLayout of an image:
    //!     VK_IMAGE_LAYOUT_UNDEFINED: Not usable by the GPU and the very first transition will discard the texels.
    //!     VK_IMAGE_LAYOUT_PREINITIALIZED: Not usable by the GPU, but the first transition will preserve the texels.
    //! There are few situations where it is necessary for the texels to be preserved during the first transition.
    //! One example, however, would be if you wanted to use an image as a staging image in combination with the VK_IMAGE_TILING_LINEAR layout.
    //! In that case, you'd want to upload the texel data to it and then transition the image to be a transfer source without losing the data.
    //! In our case, however, we're first going to transition the image to be a transfer destination and then copy texel data to it from a buffer object, so we don't need this property and can safely use VK_IMAGE_LAYOUT_UNDEFINED.
    //! The usage field has the same semantics as the one during buffer creation. 
    //! The image is going to be used as destination for the buffer copy, so it should be set up as a transfer destination.
    //! We also want to be able to access the image from the shader to color our mesh, so the usage should include VK_IMAGE_USAGE_SAMPLED_BIT.
    //! The image will only be used by one queue family: the one that supports graphics (and therefore also) transfer operations.
    //! The samples flag is related to multisampling. This is only relevant for images that will be used as attachments, so stick to one sample.
    //! There are some optional flags for images that are related to sparse images. Sparse images are images where only certain regions are actually backed by memory.
    //! If you were using a 3D texture for a voxel terrain, for example, then you could use this to avoid allocating memory to store large volumes of "air" values.
    //! We won't be using it in this tutorial, so leave it to its default value of 0.

    VkImageCreateInfo imageInfo = {};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = static_cast<uint32_t>(width);
    imageInfo.extent.height = static_cast<uint32_t>(height);
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = mipLevels;
    imageInfo.arrayLayers = 1;
    imageInfo.format = format;
    imageInfo.tiling = tiling;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imageInfo.usage = usage;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imageInfo.samples = numSamples;
    imageInfo.flags = 0; // Optional


    //! The image is created using vkCreateImage, which doesn't have any particularly noteworthy parameters.
    //! It is possible that the VK_FORMAT_R8G8B8A8_UNORM format is not supported by the graphics hardware.
    //! You should have a list of acceptable alternatives and go with the best one that is supported.
    //! However, support for this particular format is so widespread that we'll skip this step.
    //! Using different formats would also require annoying conversions.
    //! We will get back to this in the depth buffer chapter, where we'll implement such a system.

    if (vkCreateImage(_device, &imageInfo, nullptr, &image) != VK_SUCCESS) {
        throw std::runtime_error("failed to create image!");
    }

    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(_device, image, &memRequirements);

    VkMemoryAllocateInfo allocInfo = {};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(_physicalDevices.front()._physical_device, memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(_device, &allocInfo, nullptr, &imageMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate image memory!");
    }
    vkBindImageMemory(_device, image, imageMemory, 0);
}


/******************************************************************//**
* \brief  image view generation.
* 
* \author  gernot
* \date    2020-05-26
* \version 1.0
**********************************************************************/
void CAppliction::createImageView(
    VkImage             image,       //!< I -
    VkFormat            format,      //!< I -
    VkImageAspectFlags  aspectFlags, //!< I -
    uint32_t            mipLevels,   //!< I -
    VkImageView        &imageView )  //!< O -
{
    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = image; 

    // The `viewType` and `format` fields specify how the image data should be interpreted.
    // The `viewType` parameter allows you to treat images as 1D textures, 2D textures, 3D textures and cube maps.

    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = format;


    // The `components` field allows you to swizzle the color channels around.
    // For example, you can map all of the channels to the red channel for a monochrome texture.
    // You can also map constant values of 0 and 1 to a channel.
    // In our case we'll stick to the default mapping.

    viewInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
    viewInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;


    // The subresourceRange field describes what the image's purpose is and which part of the image should be accessed.
    // Our images will be used as color targets without any mipmapping levels or multiple layers.

    viewInfo.subresourceRange.aspectMask = aspectFlags;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = mipLevels;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    if (vkCreateImageView(_device, &viewInfo, nullptr, &imageView) != VK_SUCCESS) {
        throw std::runtime_error("failed to create texture image view!");
    }
}

    
/******************************************************************//**
* \brief Handle image layout transition.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::transitionImageLayout( 
    VkImage       image,     //!< I -
    VkFormat      format,    //!< I -
    VkImageLayout oldLayout, //!< I -
    VkImageLayout newLayout, //!< I -
    uint32_t      mipLevels  //!< I -
    ) {

    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    //-------------------------------------------
    // Layout transitions
    //-------------------------------------------

    //! One of the most common ways to perform layout transitions is using an image memory barrier.
    //! A pipeline barrier like that is generally used to synchronize access to resources,
    //! like ensuring that a write to a buffer completes before reading from it,
    //! but it can also be used to transition image layouts and transfer queue family ownership when VK_SHARING_MODE_EXCLUSIVE is used.
    
    //! There is an equivalent buffer memory barrier to do this for buffers.
    //! The first two fields specify layout transition.
    //! It is possible to use VK_IMAGE_LAYOUT_UNDEFINED as oldLayout if you don't care about the existing contents of the image.
    //! If you are using the barrier to transfer queue family ownership, then these two fields should be the indices of the queue families.
    //! They must be set to VK_QUEUE_FAMILY_IGNORED if you don't want to do this (not the default value!).
    //! The image and subresourceRange specify the image that is affected and the specific part of the image.
    //! Our image is not an array and does not have mipmapping levels, so only one level and layer are specified.
    //! Barriers are primarily used for synchronization purposes, so you must specify which types of operations that involve the resource must happen before the barrier,
    //! and which operations that involve the resource must wait on the barrier.
    //! We need to do that despite already using vkQueueWaitIdle to manually synchronize.
    //! The right values depend on the old and new layout, so we'll get back to this once we've figured out which transitions we're going to use.

    VkImageMemoryBarrier barrier = {}; 
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.oldLayout = oldLayout;
    barrier.newLayout = newLayout;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.image = image;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = mipLevels;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.srcAccessMask = 0; // see below
    barrier.dstAccessMask = 0; // see below

    //! All types of pipeline barriers are submitted using the same function.
    //! The first parameter after the command buffer specifies in which pipeline stage the operations occur that should happen before the barrier.
    //! The second parameter specifies the pipeline stage in which operations will wait on the barrier.
    //! The pipeline stages that you are allowed to specify before and after the barrier depend on how you use the resource before and after the barrier.
    //! The allowed values are listed in this table of the specification. 
    //! For example, if you're going to read from a uniform after the barrier,
    //! you would specify a usage of VK_ACCESS_UNIFORM_READ_BIT and the earliest shader that will read from the uniform as pipeline stage,
    //! for example VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT.
    //! It would not make sense to specify a non-shader pipeline stage for this type of usage and the validation layers will warn you when you specify a pipeline stage that does not match the type of usage.
    //! The third parameter is either 0 or VK_DEPENDENCY_BY_REGION_BIT.
    //! The latter turns the barrier into a per-region condition. 
    //! That means that the implementation is allowed to already begin reading from the parts of a resource that were written so far, for example.
    //! The last three pairs of parameters reference arrays of pipeline barriers of the three available types:
    //! memory barriers, buffer memory barriers, and image memory barriers like the one we're using here.
    //! Note that we're not using the VkFormat parameter yet, but we'll be using that one for special transitions in the depth buffer chapter.
   

    //-------------------------------------------
    // Transition barrier masks
    //-------------------------------------------
    
    //! There are two transitions we need to handle:
    //!     Undefined transfer destination: transfer writes that don't need to wait on anything
    //!     transfer destination shader reading: shader reads should wait on transfer writes, specifically the shader reads in the fragment shader, because that's where we're going to use the texture

    //! As you can see in the aforementioned table, transfer writes must occur in the pipeline transfer stage.
    //! Since the writes don't have to wait on anything, you may specify an empty access mask and the earliest possible pipeline stage VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT for the pre-barrier operations.
    //! It should be noted that VK_PIPELINE_STAGE_TRANSFER_BIT is not a real stage within the graphics and compute pipelines.
    //! It is more of a pseudo-stage where transfers happen. See the documentation for more information and other examples of pseudo-stages.
    //! The image will be written in the same pipeline stage and subsequently read by the fragment shader, which is why we specify shader reading access in the fragment shader pipeline stage.
    //! If we need to do more transitions in the future, then we'll extend the function.
    //! The application should now run successfully, although there are of course no visual changes yet.
    //! One thing to note is that command buffer submission results in implicit VK_ACCESS_HOST_WRITE_BIT synchronization at the beginning.
    //1 Since the transitionImageLayout function executes a command buffer with only a single command, you could use this implicit synchronization and set srcAccessMask to 0 if you ever needed a VK_ACCESS_HOST_WRITE_BIT dependency in a layout transition.
    //! It's up to you if you want to be explicit about it or not, but I'm personally not a fan of relying on these OpenGL-like "hidden" operations.
    //! There is actually a special type of image layout that supports all operations, VK_IMAGE_LAYOUT_GENERAL.
    //! The problem with it, of course, is that it doesn't necessarily offer the best performance for any operation.
    //! It is required for some special cases, like using an image as both input and output, or for reading an image after it has left the preinitialized layout.
    //! All of the helper functions that submit commands so far have been set up to execute synchronously by waiting for the queue to become idle.
    //! For practical applications it is recommended to combine these operations in a single command buffer and execute them asynchronously for higher throughput, especially the transitions and copy in the createTextureImage function.
    //! Try to experiment with this by creating a setupCommandBuffer that the helper functions record commands into, and add a flushSetupCommands to execute the commands that have been recorded so far.
    //! It's best to do this after the texture mapping works to check if the texture resources are still set up correctly.


    VkPipelineStageFlags sourceStage;
    VkPipelineStageFlags destinationStage;

    if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        barrier.srcAccessMask = 0;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

        sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
        destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    } else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    } else {
        throw std::invalid_argument("unsupported layout transition!");
    }

    vkCmdPipelineBarrier(
        commandBuffer,
        sourceStage, destinationStage,
        0,
        0, nullptr,
        0, nullptr,
        1, &barrier
    );
     

    endSingleTimeCommands(commandBuffer);
}


/******************************************************************//**
* \brief Copy buffer to image.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::copyBufferToImage(
    VkBuffer buffer, //!< I - 
    VkImage  image,  //!< I - 
    uint32_t width,  //!< I - 
    uint32_t height  //!< I - 
    ) {

     VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    //-------------------------------------------
    // Copying buffer to image
    //-------------------------------------------

    //! The bufferOffset specifies the byte offset in the buffer at which the pixel values start.
    //! The bufferRowLength and bufferImageHeight fields specify how the pixels are laid out in memory.
    //! For example, you could have some padding bytes between rows of the image.
    //! Specifying 0 for both indicates that the pixels are simply tightly packed like they are in our case. 
    //! The imageSubresource, imageOffset and imageExtent fields indicate to which part of the image we want to copy the pixels.

    VkBufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;

    region.imageOffset = {0, 0, 0};
    region.imageExtent = {
        width,
        height,
        1
    };

    //! The fourth parameter indicates which layout the image is currently using.
    //! I'm assuming here that the image has already been transitioned to the layout that is optimal for copying pixels to.
    //! Right now we're only copying one chunk of pixels to the whole image, but it's possible to specify an array of VkBufferImageCopy to perform many different copies from this buffer to the image in one operation.

    vkCmdCopyBufferToImage(
        commandBuffer,
        buffer,
        image,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        1,
        &region
    );

    endSingleTimeCommands(commandBuffer);
}


/******************************************************************//**
* \brief find supported format
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
VkFormat CAppliction::findSupportedFormat(const std::vector<VkFormat>& candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    
    //! Creating a depth image is fairly straightforward. It should have the same resolution as the color attachment, 
    //! defined by the swap chain extent, an image usage appropriate for a depth attachment, optimal tiling and device local memory. 
    //! The only question is: what is the right format for a depth image? The format must contain a depth component, indicated by _D??_ in the VK_FORMAT_.

    //! Unlike the texture image, we don't necessarily need a specific format, because we won't be directly accessing the texels from the program. 
    //! It just needs to have a reasonable accuracy, at least 24 bits is common in real-world applications. There are several formats that fit this requirement:
    //!
    //! VK_FORMAT_D32_SFLOAT: 32-bit float for depth
    //! VK_FORMAT_D32_SFLOAT_S8_UINT: 32-bit signed float for depth and 8 bit stencil component
    //! VK_FORMAT_D24_UNORM_S8_UINT: 24-bit float for depth and 8 bit stencil component
    
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(_physicalDevices.front()._physical_device, format, &props);

        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }

    throw std::runtime_error("failed to find supported format!");
}


/******************************************************************//**
* \brief Find depth format. 
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
VkFormat CAppliction::findDepthFormat() {
    return findSupportedFormat(
        {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT},
        VK_IMAGE_TILING_OPTIMAL,
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
    );
}


/******************************************************************//**
* \brief Has stencil component.
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
bool hasStencilComponent(VkFormat format) {
    return format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;
}


/******************************************************************//**
* \brief Create color image.  
* 
* \author  gernot
* \date    2020-06-01
* \version 1.0
**********************************************************************/
void CAppliction::createColorResources(void) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    VkFormat colorFormat = _surfaceFormat.format;

    _colorImage.push_back( VK_NULL_HANDLE );
    _colorImageMemories.push_back( VK_NULL_HANDLE );
    createImage(
        _extent.width, _extent.height, 1, _msaaSamples,
        colorFormat,
        VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        _colorImage.back(),
        _colorImageMemories.back());
    
    _colorImageView.push_back( VK_NULL_HANDLE );
    createImageView(_colorImage.back(), colorFormat, VK_IMAGE_ASPECT_COLOR_BIT, 1, _colorImageView.back());
}


/******************************************************************//**
* \brief Create depth image.  
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
void CAppliction::createDepthResources( void )
{
    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    VkFormat depthFormat = findDepthFormat();

    _depthImage.push_back( VK_NULL_HANDLE );
    _depthImageMemories.push_back( VK_NULL_HANDLE );
    createImage(
        _extent.width, _extent.height, 1, _msaaSamples,
        depthFormat,
        VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        _depthImage.back(),
        _depthImageMemories.back());
    
    _depthImageView.push_back( VK_NULL_HANDLE );
    createImageView(_depthImage.back(), depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, 1, _depthImageView.back());
}


/******************************************************************//**
* \brief Create texture image.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::createTextureImage( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Loading an image
    //-------------------------------------------
    
    std::string image_name = "../../../_data/wood.png";
    if (_load_model)
        image_name = TEXTURE_PATH;

    int texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(image_name.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
    VkDeviceSize imageSize = (size_t)texWidth * texHeight * 4;

    if (!pixels) {
        throw CException("failed to load texture image!");
    }


    //-------------------------------------------
    // Staging buffer
    //-------------------------------------------

    //! We're now going to create a buffer in host visible memory so that we can use vkMapMemory and copy the pixels to it.
    //! Add variables for this temporary buffer to the createTextureImage function:
    //! The buffer should be in host visible memory so that we can map it and it should be usable as a transfer source so that we can copy it to an image later on:
    //! We can then directly copy the pixel values that we got from the image loading library to the buffer:

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;

    createBuffer(
      imageSize, 
      VK_BUFFER_USAGE_TRANSFER_SRC_BIT, 
      VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
      stagingBuffer, stagingBufferMemory);

    void* data;
    vkMapMemory(_device, stagingBufferMemory, 0, imageSize, 0, &data);
    memcpy(data, pixels, static_cast<size_t>(imageSize));
    vkUnmapMemory(_device, stagingBufferMemory);

    stbi_image_free( pixels );

    uint32_t mipLevels = static_cast<uint32_t>(std::floor(std::log2(std::max(texWidth, texHeight)))) + 1;
    _textureImageMipmapLevel.push_back(mipLevels);

    _textureImage.push_back( VK_NULL_HANDLE );
    _textureImageMemories.push_back( VK_NULL_HANDLE );
    createImage(
        texWidth, texHeight, _textureImageMipmapLevel.back(), VK_SAMPLE_COUNT_1_BIT,
        VK_FORMAT_R8G8B8A8_SRGB,
        VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | (_textureImageMipmapLevel.back() > 1 ? VK_IMAGE_USAGE_TRANSFER_SRC_BIT : 0),
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        _textureImage.back(), _textureImageMemories.back());


    //-------------------------------------------
    // Preparing the texture image
    //-------------------------------------------
 
    //! Copy the staging buffer to the texture image. This involves two steps:
    //!     Transition the texture image to VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    //!     Execute the buffer to image copy operation

    //! The image was created with the VK_IMAGE_LAYOUT_UNDEFINED layout, so that one should be specified as old layout when transitioning textureImage.
    //! Remember that we can do this because we don't care about its contents before performing the copy operation.

    transitionImageLayout(_textureImage.back(), VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, _textureImageMipmapLevel.back());
    copyBufferToImage(stagingBuffer, _textureImage.back(), static_cast<uint32_t>(texWidth), static_cast<uint32_t>(texHeight));

    //! To be able to start sampling from the texture image in the shader, we need one last transition to prepare it for shader access:
    //transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps
    if (_textureImageMipmapLevel.back() == 1)
        transitionImageLayout(_textureImage.back(), VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 1);

    vkDestroyBuffer(_device, stagingBuffer, nullptr);
    vkFreeMemory(_device, stagingBufferMemory, nullptr);

     if (_textureImageMipmapLevel.back() > 1)
         generateMipmaps(_textureImage.back(), VK_FORMAT_R8G8B8A8_SRGB, texWidth, texHeight, _textureImageMipmapLevel.back());    
}


/******************************************************************//**
* \brief Generate mipmaps
* 
* \author  gernot
* \date    2020-06-01
* \version 1.0
**********************************************************************/
void CAppliction::generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) {
    // Check if image format supports linear blitting
    VkFormatProperties formatProperties;
    vkGetPhysicalDeviceFormatProperties(_physicalDevices.front()._physical_device, imageFormat, &formatProperties);

    if (!(formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) {
        throw std::runtime_error("texture image format does not support linear blitting!");
    }

    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkImageMemoryBarrier barrier{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.image = image;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.subresourceRange.levelCount = 1;

    //! We're going to make several transitions, so we'll reuse this VkImageMemoryBarrier. 
    //! The fields set above will remain the same for all barriers. subresourceRange.miplevel, oldLayout, newLayout, srcAccessMask, and dstAccessMask will be changed for each transition.

    int32_t mipWidth = texWidth;
    int32_t mipHeight = texHeight;

    for (uint32_t i = 1; i < mipLevels; i++) {

        //! This loop will record each of the VkCmdBlitImage commands. Note that the loop variable starts at 1, not 0.

        barrier.subresourceRange.baseMipLevel = i - 1;
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

        vkCmdPipelineBarrier(commandBuffer,
            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
            0, nullptr,
            0, nullptr,
            1, &barrier);

        //! First, we transition level i - 1 to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL.
        //! This transition will wait for level i - 1 to be filled, either from the previous blit command, or from vkCmdCopyBufferToImage.
        //! The current blit command will wait on this transition.

        VkImageBlit blit{};
        blit.srcOffsets[0] = { 0, 0, 0 };
        blit.srcOffsets[1] = { mipWidth, mipHeight, 1 };
        blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.srcSubresource.mipLevel = i - 1;
        blit.srcSubresource.baseArrayLayer = 0;
        blit.srcSubresource.layerCount = 1;
        blit.dstOffsets[0] = { 0, 0, 0 };
        blit.dstOffsets[1] = { mipWidth > 1 ? mipWidth / 2 : 1, mipHeight > 1 ? mipHeight / 2 : 1, 1 };
        blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blit.dstSubresource.mipLevel = i;
        blit.dstSubresource.baseArrayLayer = 0;
        blit.dstSubresource.layerCount = 1;

        //! Next, we specify the regions that will be used in the blit operation. 
        //! The source mipmap level is i - 1 and the destination mipmap level is i. 
        //! The two elements of the srcOffsets array determine the 3D region that data will be blitted from.
        //! dstOffsets determines the region that data will be blitted to. 
        //! The X and Y dimensions of the dstOffsets[1] are divided by two since each mipmap level is half the size of the previous level.
        //! The Z dimension of srcOffsets[1] and dstOffsets[1] must be 1, since a 2D image has a depth of 1.

       vkCmdBlitImage(commandBuffer,
            image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            1, &blit,
            VK_FILTER_LINEAR);

        //! Now, we record the blit command. Note that textureImage is used for both the srcImage and dstImage parameter. 
        //! This is because we're blitting between different levels of the same image.
        //! The source mipmap level was just transitioned to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL and the destination level is still in VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL from createTextureImage.

        //! The last parameter allows us to specify a VkFilter to use in the blit. 
        //! We have the same filtering options here that we had when making the VkSampler. 
        //! We use the VK_FILTER_LINEAR to enable interpolation.

        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        vkCmdPipelineBarrier(commandBuffer,
            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
            0, nullptr,
            0, nullptr,
            1, &barrier);

        if (mipWidth > 1) mipWidth /= 2;
        if (mipHeight > 1) mipHeight /= 2;

        //! At the end of the loop, we divide the current mipmap dimensions by two. 
        //! We check each dimension before the division to ensure that dimension never becomes 0. 
        //! This handles cases where the image is not square, since one of the mipmap dimensions would reach 1 before the other dimension. 
        //! When this happens, that dimension should remain 1 for all remaining levels.
    }

    //! Before we end the command buffer, we insert one more pipeline barrier. 
    //! This barrier transitions the last mipmap level from VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL. 
    //! This wasn't handled by the loop, since the last mipmap level is never blitted from.

    barrier.subresourceRange.baseMipLevel = mipLevels - 1;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    vkCmdPipelineBarrier(commandBuffer,
        VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
        0, nullptr,
        0, nullptr,
        1, &barrier);

    endSingleTimeCommands(commandBuffer);
}


/******************************************************************//**
* \brief Create texture image.  
* 
* \author  gernot
* \date    2020-05-26
* \version 1.0
**********************************************************************/
void CAppliction::createTextureImageView( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //! We've seen before, with the swap chain images and the framebuffer, that images are accessed through image views rather than directly.
    //! We will also need to create such an image view for the texture image.

    _textureImageView.push_back( VK_NULL_HANDLE );
    createImageView(_textureImage.back(), VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, _textureImageMipmapLevel.back(), _textureImageView.back());
}


/******************************************************************//**
* \brief Create texture sampler. 
* 
* \author  gernot
* \date    2020-05-26
* \version 1.0
**********************************************************************/
void CAppliction::createTextureSampler( void )
{
    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");


    //! Samplers are configured through a VkSamplerCreateInfo structure, which specifies all filters and transformations that it should apply.

    VkSamplerCreateInfo samplerInfo{};
    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    samplerInfo.magFilter = VK_FILTER_LINEAR;
    samplerInfo.minFilter = VK_FILTER_LINEAR;


    //! The magFilter and minFilter fields specify how to interpolate texels that are magnified or minified.
    //! Magnification concerns the oversampling problem describes above, and minification concerns under-sampling.
    //! The choices are VK_FILTER_NEAREST and VK_FILTER_LINEAR, corresponding to the modes demonstrated in the images above.

    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;

    
    //! The addressing mode can be specified per axis using the addressMode fields.
    //! The available values are listed below. Most of these are demonstrated in the image above.
    //! Note that the axes are called U, V and W instead of X, Y and Z. This is a convention for texture space coordinates.
    //! 
    //! - VK_SAMPLER_ADDRESS_MODE_REPEAT: Repeat the texture when going beyond the image dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: Like repeat, but inverts the coordinates to mirror the image when going beyond the dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: Take the color of the edge closest to the coordinate beyond the image dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: Like clamp to edge, but instead uses the edge opposite to the closest edge.
    //! - VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: Return a solid color when sampling beyond the dimensions of the image.
    //! 
    //! It doesn't really matter which addressing mode we use here, because we're not going to sample outside of the image in this tutorial. 
    //! However, the repeat mode is probably the most common mode, because it can be used to tile textures like floors and walls.

    //samplerInfo.anisotropyEnable = VK_FALSE;
    //samplerInfo.maxAnisotropy = 1.0f;
    samplerInfo.anisotropyEnable = VK_TRUE;
    samplerInfo.maxAnisotropy = 16.0f;

    
    //! These two fields specify if anisotropic filtering should be used. There is no reason not to use this unless performance is a concern.
    //! The maxAnisotropy field limits the amount of texel samples that can be used to calculate the final color. 
    //! A lower value results in better performance, but lower quality results. There is no graphics hardware available today that will use more than 16 samples, because the difference is negligible beyond that point.

    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;

    
    //! The borderColor field specifies which color is returned when sampling beyond the image with clamp to border addressing mode. 
    //! It is possible to return black, white or transparent in either float or int formats. You cannot specify an arbitrary color.

    samplerInfo.unnormalizedCoordinates = VK_FALSE;

    
    //! The unnormalizedCoordinates field specifies which coordinate system you want to use to address texels in an image. 
    //! If this field is VK_TRUE, then you can simply use coordinates within the [0, texWidth) and [0, texHeight) range.
    //! If it is VK_FALSE, then the texels are addressed using the [0, 1) range on all axes. 
    //! Real-world applications almost always use normalized coordinates, because then it's possible to use textures of varying resolutions with the exact same coordinates.

    samplerInfo.compareEnable = VK_FALSE;
    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;


    //! If a comparison function is enabled, then texels will first be compared to a value, and the result of that comparison is used in filtering operations. This is mainly used for percentage-closer filtering on shadow maps.
    //! We'll look at this in a future chapter.

    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
    samplerInfo.mipLodBias = 0.0f; 
    samplerInfo.minLod = 0.0f; // static_cast<float>(_textureImageMipmapLevel.back() / 2);
    samplerInfo.maxLod = static_cast<float>(_textureImageMipmapLevel.back());

    
    //! All of these fields apply to mipmapping. We will look at mipmapping in a later chapter,
    //! but basically it's another type of filter that can be applied.
    
    _textureSampler.push_back( VK_NULL_HANDLE );
    if (vkCreateSampler(_device, &samplerInfo, nullptr, &_textureSampler.back()) != VK_SUCCESS) {
        throw std::runtime_error("failed to create texture sampler!");
    }
}


/******************************************************************//**
* \brief Abstracting buffer creation.  
* 
* \author  gernot
* \date    2019-04-28
* \version 1.0
**********************************************************************/
void CAppliction::createBuffer(
    VkDeviceSize           size,        //!< I - size of the buffer
    VkBufferUsageFlags     usage,       //!< I - buffer usage
    VkMemoryPropertyFlags  properties,  //!< I - memory property
    VkBuffer              &buffer,      //!< I - 
    VkDeviceMemory        &bufferMemory //!< 
    ) {
    
    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //! Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card.
    //! They can be used to store vertex data, but they can also be used for many other purposes.
    //! Unlike the Vulkan objects we've been dealing with so far, buffers do not automatically allocate memory for themselves.
    //! The Vulkan API puts the programmer in control of almost everything and memory management is one of those things.

    //-------------------------------------------
    // Buffer creation
    //-------------------------------------------

    //! Creating a buffer requires us to fill a `VkBufferCreateInfo` structure.
    //! The first field of the `struct` is `size`, which specifies the size of the buffer in bytes. 
    //! Calculating the byte size of the vertex data is straightforward with `sizeof`.
    //! The second field is `usage`, which indicates for which purposes the data in the buffer is going to be used.
    //! It is possible to specify multiple purposes using a bitwise or.
    //! Just like the images in the swap chain, buffers can also be owned by a specific queue family or be shared between multiple at the same time.
    //! The buffer will only be used from the graphics queue, so we can stick to exclusive access.

    VkBufferCreateInfo bufferInfo = {};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(_device, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
        throw CException("failed to create buffer!");
    }

    //-------------------------------------------
    // Memory requirements
    //-------------------------------------------

    //! The buffer has been created, but it doesn't actually have any memory assigned to it yet.
    //! The first step of allocating memory for the buffer is to query its memory requirements using the aptly named `vkGetBufferMemoryRequirements` function.
    //! The `VkMemoryRequirements` `struct` has three fields:
    //! `size`: The size of the required amount of memory in bytes, may differ from bufferInfo.size.
    //! `alignment`: The offset in bytes where the buffer begins in the allocated region of memory, depends on bufferInfo.usage and bufferInfo.flags.
    //! `memoryTypeBits`: Bit field of the memory types that are suitable for the buffer.

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(_device, buffer, &memRequirements);

    //-------------------------------------------
    // Memory allocation
    //-------------------------------------------

    //! We now have a way to determine the right memory type, so we can actually allocate the memory by filling in the `VkMemoryAllocateInfo` structure.
    //! Memory allocation is now as simple as specifying the size and type, both of which are derived from the memory requirements of the vertex buffer and the desired property.

    VkMemoryAllocateInfo allocInfo = {};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(_physicalDevices.front()._physical_device, memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(_device, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
        throw CException("failed to allocate buffer memory!");
    }

    //! If memory allocation was successful, then we can now associate this memory with the buffer using.
    //! The first three parameters are self-explanatory and the fourth parameter is the offset within the region of memory.
    //! Since this memory is allocated specifically for this the vertex buffer, the offset is simply 0.
    //! If the offset is non-zero, then it is required to be divisible by `memRequirements.alignment`.

    vkBindBufferMemory(_device, buffer, bufferMemory, 0);
}


/******************************************************************//**
* \brief Copy from copy buffer to the other buffer 
* 
* \author  gernot
* \date    2019-04-28
* \version 1.0
**********************************************************************/
void CAppliction::copyBuffer(
    VkBuffer     srcBuffer, //!< I - source buffer
    VkBuffer     dstBuffer, //!< I - target buffer
    VkDeviceSize size       //!< I - buffer size
    ) {

    //! Contents of buffers are transferred using the vkCmdCopyBuffer command.
    //! It takes the source and destination buffers as arguments, and an array of regions to copy.
    //! The regions are defined in VkBufferCopy structures and consist of a source buffer offset, destination buffer offset and size.
    //! It is not possible to specify VK_WHOLE_SIZE here, unlike the vkMapMemory command.

    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkBufferCopy copyRegion = {};
    copyRegion.srcOffset = 0; // Optional
    copyRegion.dstOffset = 0; // Optional
    copyRegion.size = size;
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    endSingleTimeCommands(commandBuffer);
}


/******************************************************************//**
* \brief Load scene.  
* 
* \author  gernot
* \date    2018-11-04
* \version 1.0
**********************************************************************/
void CAppliction::loadModel(void) {

    if (_load_model == false)
    {
        _vertices = cube_vertices;
        _indices = cube_indices;
        return;
    }


    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string warn, err;

    if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, MODEL_PATH.c_str())) {
        throw std::runtime_error(warn + err);
    }

    std::unordered_map<Vertex, uint32_t> uniqueVertices{};

    for (const auto& shape : shapes) {
        for (const auto& index : shape.mesh.indices) {
            Vertex vertex{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = {5.0f, 5.0f, 5.0f};

            if (uniqueVertices.count(vertex) == 0) {
                uniqueVertices[vertex] = static_cast<uint32_t>(_vertices.size());
                _vertices.push_back(vertex);
            }

            _indices.push_back(uniqueVertices[vertex]);
        }
    }
}


/******************************************************************//**
* \brief Create vertex buffers.  
* 
* \author  gernot
* \date    2018-11-04
* \version 1.0
**********************************************************************/
void CAppliction::createVertexBuffer( void ) {

    //! TODO $$$
    //! [Transfer queue](https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer)
    //! The buffer copy command requires a queue family that supports transfer operations, which is indicated using VK_QUEUE_TRANSFER_BIT. The good news is that any queue family with VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT capabilities already implicitly support VK_QUEUE_TRANSFER_BIT operations. The implementation is not required to explicitly list it in queueFlags in those cases.
    //!
    //! If you like a challenge, then you can still try to use a different queue family specifically for transfer operations. It will require you to make the following modifications to your program:
    //! - Modify QueueFamilyIndices and findQueueFamilies to explicitly look for a queue family with the VK_QUEUE_TRANSFER bit, but not the VK_QUEUE_GRAPHICS_BIT.
    //! - Modify createLogicalDevice to request a handle to the transfer queue
    //! - Create a second command pool for command buffers that are submitted on the transfer queue family
    //! - Change the sharingMode of resources to be VK_SHARING_MODE_CONCURRENT and specify both the graphics and transfer queue families
    //! -Submit any transfer commands like vkCmdCopyBuffer (which we'll be using in this chapter) to the transfer queue instead of the graphics queue

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Filling the vertex buffer
    //-------------------------------------------

    //! It is now time to copy the vertex data to the buffer. This is done by mapping the buffer memory into CPU accessible memory with `vkMapMemory`.
    //! This function allows us to access a region of the specified memory resource defined by an offset and size.
    //! The offset and size here are 0 and `bufferInfo.size`, respectively.
    //! It is also possible to specify the special value `VK_WHOLE_SIZE` to map all of the memory.
    //! The second to last parameter can be used to specify flags, but there aren't any available yet in the current API.
    //! It must be set to the value 0. The last parameter specifies the output for the pointer to the mapped memory.
    //! You can now simply `memcpy` the vertex data to the mapped memory and unmap it again using `vkUnmapMemory`.
    //! Unfortunately the driver may not immediately copy the data into the buffer memory, for example because of caching.
    //! It is also possible that writes to the buffer are not visible in the mapped memory yet. There are two ways to deal with that problem:
    //! - Use a memory heap that is host coherent, indicated with `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`.
    //! - Call `vkFlushMappedMemoryRanges` to after writing to the mapped memory, and call `vkInvalidateMappedMemoryRanges` before reading from the mapped memory.
    //! We went for the first approach, which ensures that the mapped memory always matches the contents of the allocated memory.

    //! We're now going to change createVertexBuffer to only use a host visible buffer as temporary buffer and use a device local one as actual vertex buffer.

    //-------------------------------------------
    // Using a staging buffer
    //-------------------------------------------

    //! We're now using a new stagingBuffer with stagingBufferMemory for mapping and copying the vertex data. In this chapter we're going to use two new buffer usage flags:
    //! - VK_BUFFER_USAGE_TRANSFER_SRC_BIT: Buffer can be used as source in a memory transfer operation.
    //! - VK_BUFFER_USAGE_TRANSFER_DST_BIT: Buffer can be used as destination in a memory transfer operation.
    //! The vertexBuffer is now allocated from a memory type that is device local, which generally means that we're not able to use vkMapMemory. However, we can copy data from the stagingBuffer to the vertexBuffer. We have to indicate that we intend to do that by specifying the transfer source flag for the stagingBuffer and the transfer destination flag for the vertexBuffer, along with the vertex buffer usage flag.

    VkDeviceSize bufferSize = sizeof(_vertices[0]) * _vertices.size();
    
    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        stagingBuffer, stagingBufferMemory);


    void* data;
    vkMapMemory(_device, stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, _vertices.data(), (size_t) bufferSize);
    vkUnmapMemory(_device, stagingBufferMemory);

    _vertexBuffers.push_back( VK_NULL_HANDLE );
    _vertexBufferMemories.push_back( VK_NULL_HANDLE );
    createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        _vertexBuffers.back(), _vertexBufferMemories.back());

    copyBuffer(stagingBuffer, _vertexBuffers.back(), bufferSize);

    vkDestroyBuffer(_device, stagingBuffer, nullptr);
    vkFreeMemory(_device, stagingBufferMemory, nullptr);
}


/******************************************************************//**
* \brief Create index buffers.  
* 
* \author  gernot
* \date    2019-05-01
* \version 1.0
**********************************************************************/
void CAppliction::createIndexBuffer( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Index buffer creation
    //-------------------------------------------

    //! The usage of the indexBuffer should be VK_BUFFER_USAGE_INDEX_BUFFER_BIT instead of VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, which makes sense.  

    VkDeviceSize bufferSize = sizeof(_indices[0]) * _indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        stagingBuffer, stagingBufferMemory);

    void* data;
    vkMapMemory(_device, stagingBufferMemory, 0, bufferSize, 0, &data);
    memcpy(data, _indices.data(), (size_t) bufferSize);
    vkUnmapMemory(_device, stagingBufferMemory);

    _indexBuffers.push_back( VK_NULL_HANDLE );
    _indexBufferMemories.push_back( VK_NULL_HANDLE );
    createBuffer(
        bufferSize,
        VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        _indexBuffers.back(), _indexBufferMemories.back());

    copyBuffer(stagingBuffer, _indexBuffers.back(), bufferSize);

    vkDestroyBuffer(_device, stagingBuffer, nullptr);
    vkFreeMemory(_device, stagingBufferMemory, nullptr);
}


/******************************************************************//**
* \brief Create uniform buffers.  
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createUniformBuffers( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Uniform buffer
    //------------------------------------------- 

    //! We're going to copy new data to the uniform buffer every frame, so it doesn't really make any sense to have a staging buffer.
    //! It would just add extra overhead in this case and likely degrade performance instead of improving it.

    //! We should have multiple buffers, because multiple frames may be in flight at the same time and we don't want to update the buffer in preparation of the next frame while a previous one is still reading from it!
    //! We could either have a uniform buffer per frame or per swap chain image.
    //! However, since we need to refer to the uniform buffer from the command buffer that we have per swap chain image, it makes the most sense to also have a uniform buffer per swap chain image.

    VkDeviceSize bufferSize = sizeof(UniformBufferObject);

    _uniformBuffers.resize(_swapChainImages.size());
    _uniformBuffersMemories.resize(_swapChainImages.size());

    for (size_t i = 0; i < _swapChainImages.size(); i++) {
        createBuffer(
          bufferSize,
          VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
          VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
          _uniformBuffers[i], _uniformBuffersMemories[i]);
    }
}


/******************************************************************//**
* \brief Create uniform buffers.  
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorPool( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Descriptor pool
    //------------------------------------------- 

    //! Descriptor sets can't be created directly, they must be allocated from a pool like command buffers.
    //! The equivalent for descriptor sets is unsurprisingly called a descriptor pool.
    //! We'll write a new function createDescriptorPool to set it up


    //! We first need to describe which descriptor types our descriptor sets are going to contain and how many of them, using VkDescriptorPoolSize structures.

    std::array<VkDescriptorPoolSize, 2> poolSizes{};
    poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    poolSizes[0].descriptorCount = static_cast<uint32_t>(_swapChainImages.size());
    poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    poolSizes[1].descriptorCount = static_cast<uint32_t>(_swapChainImages.size());


    //! We will allocate one of these descriptors for every frame. This pool size structure is referenced by the main VkDescriptorPoolCreateInfo:
    //! Aside from the maximum number of individual descriptors that are available, we also need to specify the maximum number of descriptor sets that may be allocated:

    VkDescriptorPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());
    poolInfo.pPoolSizes = poolSizes.data();
    poolInfo.maxSets = static_cast<uint32_t>(_swapChainImages.size());


    if (vkCreateDescriptorPool(_device, &poolInfo, nullptr, &_descriptorPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create descriptor pool!"); 
    }
}


/******************************************************************//**
* \brief Create descriptor sets.
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorSets( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");
    if ( _descriptorPool == VK_NULL_HANDLE )
        throw CException("no descriptor pool!");
    if ( _descriptorSetLayout == VK_NULL_HANDLE )
        throw CException("no descriptor set layout!");
    if ( _uniformBuffers.size() < _swapChainImages.size() )
        throw CException("missing uniform buffers");

    //-------------------------------------------
    // Descriptor set
    //------------------------------------------- 

    //! A descriptor set allocation is described with a VkDescriptorSetAllocateInfo structure.
    //! You need to specify the descriptor pool to allocate from, the number of descriptor sets to allocate, and the descriptor layout to base them on:
    
    std::vector<VkDescriptorSetLayout> layouts(_swapChainImages.size(), _descriptorSetLayout);
    VkDescriptorSetAllocateInfo allocInfo = {}; 
    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    allocInfo.descriptorPool = _descriptorPool; 
    allocInfo.descriptorSetCount = static_cast<uint32_t>(_swapChainImages.size());
    allocInfo.pSetLayouts = layouts.data();

    _descriptorSets.resize(_swapChainImages.size());
    if (vkAllocateDescriptorSets(_device, &allocInfo, _descriptorSets.data()) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate descriptor sets!");
    }

    //! The descriptor sets have been allocated now, but the descriptors within still need to be configured.
    //! We'll now add a loop to populate every descriptor:

    //! Descriptors that refer to buffers, like our uniform buffer descriptor, are configured with a VkDescriptorBufferInfo structure.
    // This structure specifies the buffer and the region within it that contains the data for the descriptor.

    for (size_t i = 0; i < _swapChainImages.size(); i++) {

        std::vector<VkWriteDescriptorSet> descriptorWrites;

        VkDescriptorBufferInfo bufferInfo = {};
        bufferInfo.buffer = _uniformBuffers[i];
        bufferInfo.offset = 0;
        bufferInfo.range = sizeof(UniformBufferObject);

        //! If you're overwriting the whole buffer, like we are in this case, then it is also possible to use the VK_WHOLE_SIZE value for the range.
        //! The configuration of descriptors is updated using the vkUpdateDescriptorSets function, which takes an array of VkWriteDescriptorSet structures as parameter.

        //! The first two fields specify the descriptor set to update and the binding.
        //! We gave our uniform buffer binding index 0. Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
        //! We're not using an array, so the index is simply 0.

        //! We need to specify the type of descriptor again.
        //! It's possible to update multiple descriptors at once in an array, starting at index dstArrayElement.
        //! The descriptorCount field specifies how many array elements you want to update.

        descriptorWrites.push_back( VkWriteDescriptorSet{} );
        VkWriteDescriptorSet &descriptorWrite = descriptorWrites.back();
        descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptorWrite.dstSet = _descriptorSets[i];
        descriptorWrite.dstBinding = 0;
        descriptorWrite.dstArrayElement = 0;
        descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        descriptorWrite.descriptorCount = 1;
        descriptorWrite.pBufferInfo = &bufferInfo;
        descriptorWrite.pImageInfo = nullptr; // Optional
        descriptorWrite.pTexelBufferView = nullptr; // Optional

        //! The last field references an array with descriptorCount structures that actually configure the descriptors.
        //! It depends on the type of descriptor which one of the three you actually need to use.
        //! The pBufferInfo field is used for descriptors that refer to buffer data, pImageInfo is used for descriptors that refer to image data,
        //! and pTexelBufferView is used for descriptors that refer to buffer views.
        //! Our descriptor is based on buffers, so we're using pBufferInfo.

        for (size_t j = 0; j < _textureImageView.size(); ++j)
        {
            VkDescriptorImageInfo imageInfo{};
            imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
            imageInfo.imageView = _textureImageView[j];
            imageInfo.sampler = _textureSampler[j];

            descriptorWrites.push_back( VkWriteDescriptorSet{} );
            VkWriteDescriptorSet &descriptorWrite = descriptorWrites.back();
            descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descriptorWrite.dstSet = _descriptorSets[i];
            descriptorWrite.dstBinding = 1;
            descriptorWrite.dstArrayElement = 0;
            descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
            descriptorWrite.descriptorCount = 1;
            descriptorWrite.pBufferInfo = nullptr;
            descriptorWrite.pImageInfo = &imageInfo;
            descriptorWrite.pTexelBufferView = nullptr; // Optional
        }

        vkUpdateDescriptorSets(_device, static_cast<uint32_t>(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr);

        //! The updates are applied using vkUpdateDescriptorSets. It accepts two kinds of arrays as parameters:
        //! an array of VkWriteDescriptorSet and an array of VkCopyDescriptorSet. 
        //! The latter can be used to copy descriptors to each other, as its name implies.
    }
}


/******************************************************************//**
* \brief   create command buffers.
* 
* \author  gernot
* \date    2018-05-25
* \version 1.0
**********************************************************************/
void CAppliction::createCommandBuffers( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");
    if ( _commandPool == VK_NULL_HANDLE )
        throw CException("no vulkan command pool!");
   

    //-------------------------------------------
    // Command buffer allocation
    //-------------------------------------------

    //! The level parameter specifies if the allocated command buffers are primary or secondary command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_PRIMARY`: Can be submitted to a queue for execution, but cannot be called from other command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_SECONDARY`: Cannot be submitted directly, but can be called from primary command buffers.

    _commandBuffers.resize(_swapChainFramebuffers.size());
    
    VkCommandBufferAllocateInfo allocInfo = {};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = _commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = (uint32_t)_commandBuffers.size();

    if (vkAllocateCommandBuffers(_device, &allocInfo, _commandBuffers.data()) != VK_SUCCESS) {
        throw CException("failed to allocate command buffers!");
    }


    //-------------------------------------------
    // Starting command buffer recording
    //-------------------------------------------

    //! The flags parameter specifies how we're going to use the command buffer. The following values are available:
    //! - `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`: The command buffer will be rerecorded right after executing it once.
    //! - `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`: This is a secondary command buffer that will be entirely within a single render pass.
    //! - `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`: The command buffer can be resubmitted while it is also already pending execution.

    for (size_t i = 0; i < _commandBuffers.size(); i++) {
        VkCommandBufferBeginInfo beginInfo = {};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
        beginInfo.pInheritanceInfo = nullptr; // Optional

        if (vkBeginCommandBuffer(_commandBuffers[i], &beginInfo) != VK_SUCCESS) {
            throw CException("failed to begin recording command buffer!");
        }

        //! We have used the last flag because we may already be scheduling the drawing commands for the next frame while the last frame is not finished yet.
        //! The pInheritanceInfo parameter is only relevant for secondary command buffers. It specifies which state to inherit from the calling primary command buffers.

        //! If the command buffer was already recorded once, then a call to vkBeginCommandBuffer will implicitly reset it.
        //! It's not possible to append commands to a buffer at a later time.
       

        //-------------------------------------------
        // Starting a render pass
        //-------------------------------------------

        //! The render pass can now begin. All of the functions that record commands can be recognized by their vkCmd prefix.
        //! They all return void, so there will be no error handling until we've finished recording.

        VkRenderPassBeginInfo renderPassInfo = {};

        //! The first parameters are the render pass itself and the attachments to bind. 
        //! We created a framebuffer for each swap chain image that specifies it as color attachment.

        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        renderPassInfo.renderPass = _renderPass;
        renderPassInfo.framebuffer = _swapChainFramebuffers[i];

        //! The next two parameters define the size of the render area.
        //! The render area defines where shader loads and stores will take place.
        //! The pixels outside this region will have undefined values.
        //! It should match the size of the attachments for best performance.

        renderPassInfo.renderArea.offset = {0, 0};
        renderPassInfo.renderArea.extent = _extent;

        //! The last two parameters define the clear values to use for VK_ATTACHMENT_LOAD_OP_CLEAR, which we used as load operation for the color attachment.
        //! I've defined the clear color to simply be black with 100% opacity.

        std::array<VkClearValue, 2> clearValues{};
        clearValues[0].color = {0.0f, 0.0f, 0.0f, 1.0f};
        clearValues[1].depthStencil = {1.0f, 0};

        renderPassInfo.clearValueCount = static_cast<uint32_t>(clearValues.size());
        renderPassInfo.pClearValues = clearValues.data();


        //! The first parameter for every command is always the command buffer to record the command to.
        //! The second parameter specifies the details of the render pass we've just provided. The final parameter controls how the drawing commands within the render pass will be provided.
        //! It can have one of two values:
        //! - `VK_SUBPASS_CONTENTS_INLINE`: The render pass commands will be embedded in the primary command buffer itself and no secondary command buffers will be executed.
        //! - `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`: The render pass commands will be executed from secondary command buffers.

        vkCmdBeginRenderPass(_commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);


        //-------------------------------------------
        // Basic drawing commands
        //-------------------------------------------
        
        //! The second parameter specifies if the pipeline object is a graphics or compute pipeline.
    
        vkCmdBindPipeline(_commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, _graphicsPipeline);

        //! The actual vkCmdDraw function is a bit anticlimactic, but it's so simple because of all the information we specified in advance.
        //! It has the following parameters, aside from the command buffer:
        //! - vertexCount: Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.
        //! - instanceCount: Used for instanced rendering, use 1 if you're not doing that.
        //! - firstVertex: Used as an offset into the vertex buffer, defines the lowest value of gl_VertexIndex.
        //! - firstInstance: Used as an offset for instanced rendering, defines the lowest value of gl_InstanceIndex.

        //! The `vkCmdBindVertexBuffers` function is used to bind vertex buffers to bindings, like the one we set up in the previous chapter.
        //! The first two parameters, besides the command buffer, specify the offset and number of bindings we're going to specify vertex buffers for.
        //! The last two parameters specify the array of vertex buffers to bind and the byte offsets to start reading vertex data from.
        //! You should also change the call to vkCmdDraw to pass the number of vertices in the buffer as opposed to the hardcoded number 3.

        VkBuffer vertexBuffers[] = { _vertexBuffers.back() };
        VkDeviceSize offsets[] = { 0 };
        vkCmdBindVertexBuffers(_commandBuffers[i], 0, 1, vertexBuffers, offsets);

        // vkCmdDraw(_commandBuffers[i], static_cast<uint32_t>(vertices.size()), 1, 0, 0);


        //-------------------------------------------
        // Using an index buffer
        //-------------------------------------------

        //! Using an index buffer for drawing involves two changes to createCommandBuffers.
        //! We first need to bind the index buffer, just like we did for the vertex buffer.
        //! The difference is that you can only have a single index buffer.
        //! It's unfortunately not possible to use different indices for each vertex attribute,
        //! so we do still have to completely duplicate vertex data even if just one attribute varies.

        //! An index buffer is bound with vkCmdBindIndexBuffer which has the index buffer, a byte offset into it,
        //! and the type of index data as parameters. As mentioned before, the possible types are VK_INDEX_TYPE_UINT16 and VK_INDEX_TYPE_UINT32.

        VkIndexType index_type = sizeof(*_indices.data()) == 4 ? VK_INDEX_TYPE_UINT32 : (sizeof(*_indices.data()) == 2 ? VK_INDEX_TYPE_UINT16 : VK_INDEX_TYPE_UINT8_EXT);
        vkCmdBindIndexBuffer(_commandBuffers[i], _indexBuffers.back(), 0, index_type);

    
        //-------------------------------------------
        // Using descriptor sets
        //-------------------------------------------

        //! Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines.
        //! Therefore we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
        //! The next parameter is the layout that the descriptors are based on.
        //! The next three parameters specify the index of the first descriptor set, the number of sets to bind, and the array of sets to bind. We'll get back to this in a moment.
        //! The last two parameters specify an array of offsets that are used for dynamic descriptors.

        vkCmdBindDescriptorSets(_commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, _pipelineLayout, 0, 1, &_descriptorSets[i], 0, nullptr);


        //! Just binding an index buffer doesn't change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
        //! Remove the vkCmdDraw line and replace it with vkCmdDrawIndexed:

        vkCmdDrawIndexed(_commandBuffers[i], static_cast<uint32_t>(_indices.size()), 1, 0, 0, 0);


        //-------------------------------------------
        // Finishing up
        //-------------------------------------------

        vkCmdEndRenderPass(_commandBuffers[i]);

        if (vkEndCommandBuffer(_commandBuffers[i]) != VK_SUCCESS) {
            throw CException("failed to record command buffer!");
        }
    }    
}


/******************************************************************//**
* \brief   create semaphores 
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::createSyncObjects( void ) {

    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");


    //! The drawFrame function will perform the following operations:
    //! - Acquire an image from the swap chain
    //! - Execute the command buffer with that image as attachment in the framebuffer
    //! - Return the image to the swap chain for presentation

    //! Each of these events is set in motion using a single function call, but they are executed asynchronously.
    //! The function calls will return before the operations are actually finished and the order of execution is also undefined.
    //! That is unfortunate, because each of the operations depends on the previous one finishing.

    //! There are two ways of synchronizing swap chain events: fences and semaphores.
    //! They're both objects that can be used for coordinating operations by having one operation signal and another operation wait for a fence or semaphore to go from the unsignaled to signaled state.

    //! The difference is that the state of fences can be accessed from your program using calls like `vkWaitForFences` and semaphores cannot be.
    //! Fences are mainly designed to synchronize your application itself with rendering operation, whereas semaphores are used to synchronize operations within or across command queues.


    //-------------------------------------------
    // Semaphores
    //-------------------------------------------

    const int MAX_FRAMES_IN_FLIGHT = 2;

    _imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    _renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    _inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

    VkSemaphoreCreateInfo semaphoreInfo = {};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    VkFenceCreateInfo fenceInfo = {};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;

    //! initialize in the signaled state as if we had rendered an initial frame that finished
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        if (vkCreateSemaphore(_device, &semaphoreInfo, nullptr, &_imageAvailableSemaphores[i]) != VK_SUCCESS ||
            vkCreateSemaphore(_device, &semaphoreInfo, nullptr, &_renderFinishedSemaphores[i]) != VK_SUCCESS ||
            vkCreateFence(_device, &fenceInfo, nullptr, &_inFlightFences[i]) != VK_SUCCESS) {

            throw CException("failed to create synchronization objects for a frame!");
        }
    }

}


/******************************************************************//**
* \brief   do the drawing
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::drawFrame( void ) {

    //! The `vkWaitForFences` function takes an array of fences and waits for either any or all of them to be signaled before returning.
    //! The `VK_TRUE` we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter.
    //! Just like `vkAcquireNextImageKHR` this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the vkResetFences call.

    vkWaitForFences(_device, 1, &_inFlightFences[_currentFrame], VK_TRUE, std::numeric_limits<uint64_t>::max());

    //-------------------------------------------
    // Acquiring an image from the swap chain
    //-------------------------------------------

    //! The first two parameters of `vkAcquireNextImageKHR` are the logical device and the swap chain from which we wish to acquire an image.
    //! The third parameter specifies a timeout in nanoseconds for an image to become available.
    //! Using the maximum value of a 64 bit unsigned integer disables the timeout.

    //! The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image.
    //! That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both.
    //! We're going to use our imageAvailableSemaphore for that purpose here.

    //! The last parameter specifies a variable to output the index of the swap chain image that has become available.
    //! The index refers to the VkImage in our swapChainImages array.

    uint32_t imageIndex;
    VkResult acquireNextImageResult = vkAcquireNextImageKHR( _device, _swapChain, std::numeric_limits<uint64_t>::max(), _imageAvailableSemaphores[_currentFrame], VK_NULL_HANDLE, &imageIndex );
    
    if (acquireNextImageResult == VK_ERROR_OUT_OF_DATE_KHR || acquireNextImageResult == VK_SUBOPTIMAL_KHR || _framebufferResized) {
        _framebufferResized = false;
        recreateSwapChain();
        return;
    } else if (acquireNextImageResult != VK_SUCCESS /*&& acquireNextImageResult != VK_SUBOPTIMAL_KHR*/ ) {
        throw CException("failed to acquire swap chain image index");
    }


    vkResetFences(_device, 1, &_inFlightFences[_currentFrame]);


    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------
    
    updateUniformBuffer(imageIndex);

    //-------------------------------------------
    // Submitting the command buffer
    //-------------------------------------------
    
    VkSubmitInfo submitInfo = {};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    //! The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
    //! We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment.
    //! That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. 
    //! Each entry in the waitStages array corresponds to the semaphore with the same index in pWaitSemaphores.

    VkSemaphore waitSemaphores[] = {_imageAvailableSemaphores[_currentFrame]};
    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;

    //! The next two parameters specify which command buffers to actually submit for execution.
    //! As mentioned earlier, we should submit the command buffer that binds the swap chain image we just acquired as color attachment.

    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &_commandBuffers[imageIndex];

    //! The signalSemaphoreCount and pSignalSemaphores parameters specify which semaphores to signal once the command buffer(s) have finished execution.
    //! In our case we're using the renderFinishedSemaphore for that purpose.

    VkSemaphore signalSemaphores[] = {_renderFinishedSemaphores[_currentFrame]};
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;

    if (vkQueueSubmit(_graphicsQueue, 1, &submitInfo, _inFlightFences[_currentFrame]) != VK_SUCCESS) {
        throw CException("failed to submit draw command buffer!");
    }

 
    //-------------------------------------------
    // Presentation
    //-------------------------------------------
    
    VkPresentInfoKHR presentInfo = {};
    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

    presentInfo.waitSemaphoreCount = 1;
    presentInfo.pWaitSemaphores = signalSemaphores;

    //! The next two parameters specify the swap chains to present images to and the index of the image for each swap chain.
    //! This will almost always be a single one.

    VkSwapchainKHR swapChains[] = {_swapChain};
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains = swapChains;
    presentInfo.pImageIndices = &imageIndex;

    //! There is one last optional parameter called pResults.
    //! It allows you to specify an array of `VkResult` values to check for every individual swap chain if presentation was successful. 
    //! It's not necessary if you're only using a single swap chain, because you can simply use the return value of the present function.

    presentInfo.pResults = nullptr; // Optional

    if (vkQueuePresentKHR(_presentQueue, &presentInfo) != VK_SUCCESS) {
       throw CException("queue presentation failed!");
    }      


    //-------------------------------------------
    // Frames in flight
    //-------------------------------------------
    
    //! If you run your application with validation layers enabled and you monitor the memory usage of your application, you may notice that it is slowly growing.
    //! The reason for this is that the application is rapidly submitting work in the drawFrame function, but doesn't actually check if any of it finishes.
    //! If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work.
    //! Worse, even, is that we are reusing the imageAvailableSemaphore and renderFinishedSemaphore for multiple frames at the same time.

    //! The easy way to solve this is to wait for work to finish right after submitting it, for example by using vkQueueWaitIdle.
    //! However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now.
    //! The stages that the current frame has already progressed through are idle and could already be used for a next frame.

    //vkQueuePresentKHR(_presentQueue, &presentInfo);
    //vkQueueWaitIdle(_presentQueue);


    _currentFrame = (_currentFrame + 1) % _imageAvailableSemaphores.size();
}


/******************************************************************//**
* \brief   update the uniform buffer for the current image
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::updateUniformBuffer( uint32_t imageIndex )
{
    if ( _device == VK_NULL_HANDLE )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------

    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    UniformBufferObject ubo = {};
    ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = glm::perspective(glm::radians(45.0f), _extent.width / (float) _extent.height, 0.1f, 10.0f);

    // GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
    // The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the projection matrix.
    // If you don't do this, then the image will be rendered upside down.
     ubo.proj[1][1] *= -1;

    void* data;
    vkMapMemory(_device, _uniformBuffersMemories[imageIndex], 0, sizeof(ubo), 0, &data);
    memcpy(data, &ubo, sizeof(ubo));
    vkUnmapMemory(_device, _uniformBuffersMemories[imageIndex]);
}


} // VulkanLoader


using HelloTriangleApplication = VulkanLoader::CAppliction;


int main() {
    
    static bool verbose                      = true;
    static bool enable_all_validation_layers = false;
    static bool enable_surface_extensions    = true;
    static bool enable_swapchain_extensions  = true;
    static bool enable_validation_warnings   = true;
    static bool enable_debug_extensions      = true;
    static bool enable_debug_information     = false;
    static bool enable_depth_test            = true;
    static bool enable_face_culling          = false;
    static bool load_model                   = true;
    
    HelloTriangleApplication app( verbose );

    const std::vector<std::string> validationLayers = {
        //"VK_LAYER_LUNARG_api_dump",
        "VK_LAYER_KHRONOS_validation",
        "VK_LAYER_LUNARG_monitor",
        "VK_LAYER_LUNARG_screenshot"
    };
    const std::vector<std::string> excludeValidationLayers = {
        "VK_LAYER_LUNARG_device_simulation",
        "VK_LAYER_LUNARG_vktrace",
        "VK_LAYER_RENDERDOC_Capture" //!< causes instance creation fail; why?
    };

    app.scene(load_model);
    app.layers(validationLayers, enable_all_validation_layers, excludeValidationLayers);
    app.settings(enable_depth_test, enable_face_culling);

    const std::vector<std::string> extensions = {
        "VK_KHR_win32_surface", // seems to be strongly required for win32 application (at least for GLFW)
    };
    app.extensions( 
      extensions,
      enable_surface_extensions,
      enable_validation_warnings,
      enable_debug_extensions,
      enable_debug_information );

    const std::vector<std::string> device_extensions = {};
    app.deviceExtensions( 
      device_extensions,
      enable_swapchain_extensions );

    bool exit_success = true;
    try {
        app.run();
    } catch (const std::runtime_error& e) {
        std::cerr << e.what() << std::endl;
        exit_success = false;
    }

    return exit_success ? EXIT_SUCCESS : EXIT_FAILURE;
}