#include <stdafx.h>


// Vulkan

//! Vulkan is included by GLFW library
//#include <vulkan/vulkan.h>


// GLM

#define GLM_ENABLE_EXPERIMENTAL

#define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/hash.hpp>


// STB

#define STB_IMAGE_IMPLEMENTATION
//#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>


// TINYOBJLOADER

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>


// Vulkan

#include <vk_utility_vulkan_include.h>
#include <vk_utility_parameter_helper.h>
#include <vk_utility_validation_layers.h>
#include <vk_utility_extensions.h>
#include <vk_utility_instance.h>
#include <vk_utility_instance_factory.h>
#include <vk_utility_debug.h>
#include <vk_utility_surface.h>
#include <vk_utility_physical_device.h>
#include <vk_utility_physical_device_extensions.h>
#include <vk_utility_physical_device_rate_default.h>
#include <vk_utility_device.h>
#include <vk_utility_device_factory.h>
#include <vk_utility_device_factory_default.h>
#include <vk_utility_device_memory.h>
#include <vk_utility_buffer.h>
#include <vk_utility_buffer_and_memory.h>
#include <vk_utility_buffer_operator_copy_data_to_memory.h>
#include <vk_utility_buffer_operator_copy_data_staging.h>
#include <vk_utility_buffer_operator_copy_buffer.h>
#include <vk_utility_logging.h>
#include <vk_utility_logging_physical_device.h>
#include <vk_utility_render_pass.h>
#include <vk_utility_render_pass_factory.h>
#include <vk_utility_render_pass_factory_default.h>
#include <vk_utility_descriptor_set_layout.h>
#include <vk_utility_descriptor_set_layout_factory.h>
#include <vk_utility_descriptor_set_layout_factory_default.h>
#include <vk_utility_swap_surface_format_selector.h>
#include <vk_utility_swap_surface_fromat_selector_default.h>
#include <vk_utility_swap_present_mode_selector.h>
#include <vk_utility_swap_present_mode_selector_default.h>
#include <vk_utility_swap_extent_selector.h>
#include <vk_utility_swapchain.h>
#include <vk_utility_swapchain_factory.h>
#include <vk_utility_swapchain_factory_default.h>
#include <vk_utility_shader_module.h>
#include <vk_utility_shader_module_factory_spirv_file.h>
#include <vk_utility_shader_stage_create_information.h>
#include <vk_utility_pipeline.h>
#include <vk_utility_pipeline_layout.h>
#include <vk_utility_pipeline_factory_default.h>
#include <vk_utility_image_view.h>
#include <vk_utility_image_view_and_image_memory.h>
#include <vk_utility_swapchain_image_views_factory_default.h>
#include <vk_utility_framebuffer.h>
#include <vk_utility_framebuffer_factory_default.h>
#include <vk_utility_command_pool.h>
#include <vk_utility_command_pool_factory_default.h>
#include <vk_utility_command_buffer.h>
#include <vk_utility_command_buffer_factory_single_time_command.h>
#include <vk_utility_image_factory_2d.h>
#include <vk_utility_image_device_memory_factory.h>
#include <vk_utility_image_and_memory.h>
#include <vk_utility_image_and_memory_factory_default.h>
#include <vk_utility_image_view_factory_default.h>
#include <vk_utility_image_view_and_image_memory_factory_default.h>
#include <vk_utility_image_transition_command.h>
#include <vk_utility_image_copy_buffer_to_image_command.h>
#include <vk_utility_sampler.h>
#include <vk_utility_sampler_factory_default.h>
#include <vk_utility_descriptor_pool.h>
#include <vk_utility_descriptor_pool_factory_default.h>
#include <vk_utility_semaphore.h>
#include <vk_utility_semaphore_factory_default.h>
#include <vk_utility_fence.h>
#include <vk_utility_fence_factory_default.h>
#include <vk_utility_format_selector.h>
#include <vk_utility_image_generate_mipmaps_command.h>
#include <vk_utility_buffer_device_memory_factory.h>
#include "vk_utility_buffer_factory_default.h"
#include "vk_utility_device_memory_factory_default.h"
#include "vk_utility_buffer_and_memory_factory_default.h"

// GLFW

#include <vk_glfw_utility_include.h>
#include <vk_glfw_utility_extensions.h>
#include <vk_glfw_utility_surface_factory.h>
#include <vk_glfw_utility_swap_extent_selector.h>


// STL

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <tuple>
#include <array>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <chrono>
#include <cmath>
#include <math.h>


const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;


const std::string MODEL_PATH = "../../../../../model/viking_room/viking_room.obj";
const std::string TEXTURE_PATH = "../../../../../model/viking_room/viking_room.png";



struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    bool operator==(const Vertex& other) const {
        return pos == other.pos && color == other.color && texCoord == other.texCoord;
    }

    static vk::VertexInputBindingDescription getBindingDescription( void );
    static std::array<vk::VertexInputAttributeDescription, 3> getAttributeDescriptions( void );
};


namespace std {
    template<> struct hash<Vertex> {
        size_t operator()(Vertex const& vertex) const {
            return ((hash<glm::vec3>()(vertex.pos) ^
                   (hash<glm::vec3>()(vertex.color) << 1)) >> 1) ^
                   (hash<glm::vec2>()(vertex.texCoord) << 1);
        }
    };
}


vk::VertexInputBindingDescription Vertex::getBindingDescription( void ) {
    
    vk::VertexInputBindingDescription bindingDescription(0, sizeof(Vertex), vk::VertexInputRate::eVertex);
    return bindingDescription;
}

std::array<vk::VertexInputAttributeDescription, 3> Vertex::getAttributeDescriptions( void ) {
    
    std::array<vk::VertexInputAttributeDescription, 3> attributeDescriptions
    {
        vk::VertexInputAttributeDescription(0, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, pos)),
        vk::VertexInputAttributeDescription(1, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, color)),
        vk::VertexInputAttributeDescription(2, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, texCoord))
    };

    return attributeDescriptions;
}

const std::vector<Vertex> cube_vertices = {
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 1.0f}}
};

const std::vector<uint32_t> cube_indices = {
    0, 1, 2, 0, 2, 3,
    4, 5, 6, 4, 6, 7,
    8, 9, 10, 8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23
};

struct UniformBufferObject {
    alignas(16) glm::mat4 model;
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
};

namespace VulkanLoader {

#ifdef _DEBUG
const bool debug_true = true;
#else
const bool debug_true = false;
#endif


class CException 
    : public std::runtime_error 
{
public:

    explicit CException( const char *what ) : std::runtime_error( what ) {}
    explicit CException( const std::string &what ) : std::runtime_error( what ) {}
};


class CopyBufferHelper;


/******************************************************************//**
* \brief   Vulkan application object.
*
* The setup of the Vulkan application follows widely the official
* Vulkan tutorial.
* [https://vulkan-tutorial.com/Introduction]
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
class CAppliction 
{
    friend class CopyBufferHelper;

public: // public operations
    
    CAppliction( bool verbose );
    virtual ~CAppliction();

    bool Verbose( void ) const { return _verbose; }

    void scene(bool load_model)
    {
        _load_model = load_model;
    }

    void layers( 
        const std::vector<std::string> &layerNames,         //!< explicit names of validation layer which should be added
        bool                            all_layers,         //!< enable all existing validation layers
        const std::vector<std::string> &excludeLayerNames ) //!< exclude this validations layers in any case
    { 
      _requestedValidationLayers = layerNames;
      _enableAllValidationLayers = all_layers;
      _excludedValidationLayers  = excludeLayerNames;
    }

    void settings(bool enable_depth_test, bool enable_face_culling)
    {
        _enable_depth_test   = enable_depth_test;
        _enable_face_culling = enable_face_culling;
    }

    void extensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            surface_extensions,   //!< automatically add surface extensions 
        bool                            validation_warnings,  //!< add validation warnings 
        bool                            debug_extensions,     //!< automatically add debug extensions 
        bool                            debug_information)    //!< automatically enable additional debug information
    { 
        _requestedExtensions      = extensions;
        _enableSurfaceExtensions  = surface_extensions;
        _enableValidationWarnings = validation_warnings;
        _enableDebugExtensions    = debug_extensions;
        _enableDebugInformation   = debug_information;

        // add surface extension to the requested extensions
        const std::string surface_ext_name = "VK_KHR_surface";
        if ( _enableSurfaceExtensions ) {
            if ( std::find( _requestedExtensions.begin(), _requestedExtensions.end(), surface_ext_name.c_str() ) == _requestedExtensions.end() )
                _requestedExtensions.push_back( surface_ext_name.c_str() );
            // "VK_KHR_win32_surface" ???
        }
    }

     void deviceExtensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            swapchain_extensions) //!< automatically add swapchain extensions 
    { 
        _requestedDeviceExtensions = extensions;
        _enableSwapchainExtension  = swapchain_extensions;

        // add swapchain device extension  to requested device extensions
        const std::string swapchain_ext_name = "VK_KHR_swapchain";
        if ( _enableSwapchainExtension ) {
            if ( std::find( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), swapchain_ext_name.c_str() ) == _requestedDeviceExtensions.end() )
              _requestedDeviceExtensions.push_back( swapchain_ext_name.c_str() );
        }
    }

    void run( void ); //!< Run Vulkan application

private: // private operations

    void initWindow( void );              //!< Initialize GLFW and create GLFW window
    void initVulkan( void );              //!< Set up Vulkan
    void mainLoop( void );                //!< Event loop
    void cleanup( void );                 //!< Cleanup GLFW
    void resize( int width, int height ); //!< Resize notification
    
    void recreateSwapChain( void );                  //!< recreate the entire swapchain (e.g. when the window was resized)
    void createSwapChain( bool initilaize );         //!< create the entire swapchain (e.g. when the window was resized)
    void cleanupSwapChain( void );                   //!< cleanup everything which will be recreated till swapchain is recreated
    void loadModel(void);                            //!< load scene
    void createTextureImage( void );                 //!< create texture image
    void createTextureImageView( void );             //!< create texture image view
    void createDescriptorSets( void );               //!< create descriptor sets
    void createCommandBuffers( void );               //!< create command buffers
    void updateUniformBuffer( uint32_t imageIndex ); //!< update the uniform buffer for the current image

    void drawFrame( void ); //! do the drawing

    static void framebufferResizeCallback( GLFWwindow* window, int width, int height );

private: // private attributes

    bool                     _verbose                   = false; //!< flag which controls log messages
    bool                     _enableAllValidationLayers = false; //!< flag which controls the usage of validation layers
    bool                     _enableValidationWarnings  = false; //!< flag which controls warning information
    bool                     _enableSurfaceExtensions   = false; //!< flag which controls automatically enabling of surface extensions
    bool                     _enableDebugExtensions     = false; //!< flag which controls automatically enabling of debug extensions
    bool                     _enableDebugInformation    = false; //!< flag which controls additional debug information
    bool                     _enableSwapchainExtension  = false; //!< flag which controls automatically enabling of swapchain device extensions
    bool                     _enable_depth_test         = false; //!< flag which controls the depth test
    bool                     _enable_face_culling       = false; //!< flag which controls the face culling
    bool                     _load_model                = false; //!< flag which controls loading of obj model
    std::vector<std::string> _requestedValidationLayers;         //!< list of requested validation layers
    std::vector<std::string> _excludedValidationLayers;          //!< list of excluded validation layers
    std::vector<std::string> _requestedExtensions;               //!< list of requested extensions, "VK_EXT_debug_report" is automatically added if any validation layer is requested
    std::vector<std::string> _requestedDeviceExtensions;         //!< list of requested device extensions

    GLFWwindow                          *_wnd = nullptr;         //!< GLFW window

    std::vector<Vertex>                  _vertices;              //!< model vertices
    std::vector<uint32_t>                _indices;               //!< model indices

    vk_utility::core::DebugPtr _debubCallback;
    
    size_t                  _currentFrame = 0;                          //!< current frame semaphore index
    bool                    _framebufferResized = false;                //!< state which indicates that the widow has been resized

    vk_utility::core::InstancePtr                              _instance;                   // Vulkan instance handle
    vk_utility::device::SurfacePtr                             _surface;                    // Vulkan surface handle
    vk_utility::device::PhysicalDevicePtr                      _physical_device;
    vk_utility::device::DevicePtr                              _device;                     // Vulkan logical device handle 
    vk::Queue                      _graphicsQueue;            //!< Vulkan graphics queue handle 
    vk::Queue                      _presentQueue;             //!< Vulkan presentation queue handle 
    vk_utility::swap::SwapchainPtr                             _swapchain;                  // Vulkan swap chain handle 
    std::vector<vk_utility::image::ImageViewPtr>               _swapchain_image_views;      // Vulkan swap chain image handles
    vk_utility::core::RenderPassPtr                            _render_pass;                // Vulkan render pass handle
    vk_utility::core::DescriptorSetLayoutPtr                   _descriptor_set_layout;      // Vulkan descriptor set layout
    vk_utility::core::DescriptorPoolPtr                        _descriptor_pool;            // Vulkan descriptor set pool
    std::vector<vk::DescriptorSet> _descriptorSets;           //!< Vulkan descriptor sets
    vk_utility::pipeline::PipelineLayoutPtr                    _pipeline_layout;            // Vulkan pipeline layout handle
    vk_utility::pipeline::PipelinePtr                          _graphics_pipeline;          // Vulkan graphics pipeline handle
    std::vector<vk_utility::buffer::FramebufferPtr>            _swapchain_framebuffers;     // Vulkan framebuffers
    vk_utility::command::CommandPoolPtr                        _command_pool;               // Vulkan command pool
    std::vector<vk::CommandBuffer> _commandBuffers;           //!< Vulkan command buffers
    std::vector<vk_utility::core::SemaphorePtr>                _image_available_semaphores; // Vulkan semaphore
    std::vector<vk_utility::core::SemaphorePtr>                _render_finished_semaphores; // Vulkan semaphore
    std::vector<vk_utility::core::FencePtr>                    _in_flight_fences;           // Vulkan fence
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>        _vertex_buffers;             // Vulkan vertex buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>        _index_buffers;              // Vulkan index buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>        _uniform_buffers;            // Vulkan uniform buffer
    std::vector<vk_utility::image::ImageViewAndImageMemoryPtr> _depth_image_view_memorys;   // Vulkan depth image view memory
    std::vector<vk_utility::image::ImageViewAndImageMemoryPtr> _color_image_view_memorys;   // Vulkan color image view memory
    std::vector<vk_utility::image::ImageViewAndImageMemoryPtr> _texture_image_view_memorys; // Vulkan texture image view memory
    std::vector<vk_utility::image::SamplerPtr>                 _texture_samplers;           // Vulkan texture sampler
};


// TODO $$$ BufferCopyCommand
class CopyBufferHelper
    : public vk_utility::buffer::BufferOperatorCopyBuffer
{
private: 
    CAppliction &_app;

public:
    CopyBufferHelper(CAppliction &app)
        : _app(app)
    {}
    
    virtual CopyBufferHelper &copy(vk_utility::buffer::BufferAndMemoryPtr destination_buffer, vk_utility::buffer::BufferAndMemoryPtr source_buffer) override
    {
        //! TODO $$$
        //! [Transfer queue](https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer)
        //! The buffer copy command requires a queue family that supports transfer operations, which is indicated using VK_QUEUE_TRANSFER_BIT.
        //! The good news is that any queue family with VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT capabilities already implicitly support VK_QUEUE_TRANSFER_BIT operations.
        //! The implementation is not required to explicitly list it in queueFlags in those cases.
        //!
        //! If you like a challenge, then you can still try to use a different queue family specifically for transfer operations. 
        //! It will require you to make the following modifications to your program:
        //! - Modify QueueFamilyIndices and findQueueFamilies to explicitly look for a queue family with the VK_QUEUE_TRANSFER bit, but not the VK_QUEUE_GRAPHICS_BIT.
        //! - Modify createLogicalDevice to request a handle to the transfer queue
        //! - Create a second command pool for command buffers that are submitted on the transfer queue family
        //! - Change the sharingMode of resources to be VK_SHARING_MODE_CONCURRENT and specify both the graphics and transfer queue families
        //! - Submit any transfer commands like vkCmdCopyBuffer (which we'll be using in this chapter) to the transfer queue instead of the graphics queue

        
        //! Contents of buffers are transferred using the vkCmdCopyBuffer command.
        //! It takes the source and destination buffers as arguments, and an array of regions to copy.
        //! The regions are defined in `vk::BufferCopy` structures and consist of a source buffer offset, destination buffer offset and size.
        //! It is not possible to specify VK_WHOLE_SIZE here, unlike the vkMapMemory command.

        auto command_buffer_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
            .set_graphics_queue(_app._graphicsQueue);
        auto command_buffer = vk_utility::command::CommandBuffer::NewPtr(_app._device->get(), _app._command_pool->get(), command_buffer_factory);


        std::vector<vk::BufferCopy> copyRegions{vk::BufferCopy(0, 0, destination_buffer->get().buffer().size())};
        command_buffer->get()->copyBuffer(source_buffer->get().buffer(), destination_buffer->get().buffer(), copyRegions);
        
        command_buffer_factory.End(command_buffer->get());

        return *this;
    }
};


/******************************************************************//**
* \brief   ctor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::CAppliction( 
  bool verbose ) //!< control of log messages
  : _verbose( verbose )
{}


/******************************************************************//**
* \brief   dtor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::~CAppliction()
{}


/******************************************************************//**
* \brief   Run Vulkan application
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::run( void ) 
{     
    if ( _requestedValidationLayers.empty() && _enableAllValidationLayers == false )
        _enableAllValidationLayers = debug_true;

    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}


/******************************************************************//**
* \brief   Initialize GLFW and create GLFW window
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initWindow( void ) 
{
    //! glfwInit() initializes the GLFW library. 
    if ( glfwInit() == GLFW_FALSE )
        throw CException( "error initializing GLFW" ); 

    //! Because GLFW was originally designed to create an OpenGL context,
    //! we need to tell it to not create an OpenGL context with a subsequent call:
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        
    //! Because handling resized windows takes special care that we'll look into later,
    //! disable it for now with another window hint call:
    //glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    //! The first three parameters specify the width, height and title of the window.
    //! The fourth parameter allows you to optionally specify a monitor to open the window on
    //! and the last parameter is only relevant to OpenGL.
    _wnd = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan window", nullptr, nullptr);
    if ( _wnd == nullptr )
        throw CException( "error initializing window" ); 

    //! window pointer for callbacks
    glfwSetWindowUserPointer(_wnd, this);

    //! resize call back 
    glfwSetFramebufferSizeCallback(_wnd, framebufferResizeCallback);
}


/******************************************************************//**
* \brief Load scene.
*
* \author  gernot
* \date    2018-11-04
* \version 1.0
**********************************************************************/
void CAppliction::loadModel(void)
{
    if (_load_model == false)
    {
        _vertices = cube_vertices;
        _indices = cube_indices;
        return;
    }

    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string warn, err;

    if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, MODEL_PATH.c_str())) {
        throw std::runtime_error(warn + err);
    }

    std::unordered_map<Vertex, uint32_t> uniqueVertices{};

    for (const auto& shape : shapes) {
        for (const auto& index : shape.mesh.indices) {
            Vertex vertex{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = { 5.0f, 5.0f, 5.0f };

            if (uniqueVertices.count(vertex) == 0) {
                uniqueVertices[vertex] = static_cast<uint32_t>(_vertices.size());
                _vertices.push_back(vertex);
            }

            _indices.push_back(uniqueVertices[vertex]);
        }
    }
}


/******************************************************************//**
* \brief   Set up Vulkan
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initVulkan( void )
{
    vk_utility::logging::Log log;

    //vk_utility::Init();


#if VK_UTILITY_DYNAMIC_LOADING == 1
    vk::DynamicLoader dl;
    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = dl.getProcAddress<PFN_vkGetInstanceProcAddr>("vkGetInstanceProcAddr");

    VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);
#endif

    if (Verbose())
         vk_utility::logging::LogList(log).log("GLFW extensions supported", vk_glfw_utility::core::Extensions().get_names());

    _instance = vk_utility::core::Instance::New(
        vk_utility::core::InstanceFactoryDefault()
            .verbose(Verbose())
            .title("Vulkan tutorial - utility")
            .validation_layers(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers)
            .extensions(_requestedExtensions, _enableDebugExtensions));

    _debubCallback = vk_utility::core::Debug::New(_instance, _enableDebugInformation, _enableValidationWarnings);

    _surface = vk_glfw_utility::device::SurfaceFactory(_wnd).New(_instance);

    if (Verbose())
      vk_utility::logging::LogList(log).log("physical device extensions are requested", _requestedDeviceExtensions);
    
    _physical_device = vk_utility::device::PhysicalDeviceSelctor::New()
        .rater(vk_utility::device::PhysicalDeviceRateDefault::New(_requestedDeviceExtensions, _enableSwapchainExtension))
        .verbose(Verbose())
        .select(_instance, _surface);

    vk_utility::core::ValidationLayers validation_layers;
    auto selected_validation_layers = validation_layers.select(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers);
    _device = vk_utility::device::DeviceFactoryDefault()
        .set_requested_device_extensions(_requestedDeviceExtensions)
        .set_requested_validation_layers(selected_validation_layers)
        .New(_physical_device);

    _graphicsQueue = _device->get().get_first_graphics_queue(); // TODO [...] vk_utility::Queue 
    _presentQueue = _device->get().get_first_graphics_queue();  // TODO [...] vk_utility::Queue 

    _descriptor_set_layout = vk_utility::core::DescriptorSetLayoutFactoryDefault().New(_device);

    createSwapChain(true);

    const int MAX_FRAMES_IN_FLIGHT = 2;
    auto semaphore_factory = vk_utility::core::SemaphoreFactoryDefault();
    auto fence_factory = vk_utility::core::FenceFactoryDefault();
    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++)
    {
        _image_available_semaphores.push_back(vk_utility::core::Semaphore::NewPtr(*_device, vk_utility::core::SemaphoreFactoryDefault()));
        _render_finished_semaphores.push_back(vk_utility::core::Semaphore::NewPtr(*_device, vk_utility::core::SemaphoreFactoryDefault()));
        _in_flight_fences.push_back(vk_utility::core::Fence::NewPtr(*_device, vk_utility::core::FenceFactoryDefault()));
    }
}


/******************************************************************//**
* \brief   Event loop
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::mainLoop( void ) 
{
    //! To keep the application running until either an error occurs or the window is closed, we need to add an event loop 
    while (!glfwWindowShouldClose(_wnd)) {
        glfwPollEvents();

        drawFrame();

        //! we should wait for the logical device to finish operations before exiting mainLoop and destroying the window:
        _device->get()->waitIdle();

        //glfwWaitEvents();
    }
}


/******************************************************************//**
* \brief   Cleanup GLFW
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::cleanup( void ) 
{
    cleanupSwapChain();

    _descriptor_set_layout = nullptr;
    _texture_samplers.clear();
    _texture_image_view_memorys.clear();
    _index_buffers.clear();
    _vertex_buffers.clear();
    _in_flight_fences.clear();
    _render_finished_semaphores.clear();
    _image_available_semaphores.clear();
    _command_pool = nullptr;
    _device = nullptr;
    _physical_device = nullptr;
    _surface = nullptr;
    _debubCallback = nullptr;
    _instance = nullptr;

    //! Once the window is closed, we need to clean up resources by destroying it and terminating GLFW itself. 
    glfwDestroyWindow(_wnd);
    _wnd = nullptr;
    glfwTerminate();
}


/******************************************************************//**
* \brief Resize notification.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::framebufferResizeCallback( 
    GLFWwindow* window, //!< GLFW window handle (pointer)
    int         width,  //!< new width of the window
    int         height  //!< new height of the window
    ) 
{
    if ( window == nullptr )
        return;
    CAppliction *appPtr = (CAppliction*)glfwGetWindowUserPointer( window );
    if ( appPtr == nullptr )
        return;

    appPtr->resize( width, height );
}


/******************************************************************//**
* \brief Resize notification  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::resize( 
    int width, //!< new width of the window
    int height //!< new height of the window
    ) 
{
  _framebufferResized = true;
}


/******************************************************************//**
* \brief Recreate the entire swapchain (e.g. when the window was resized). 
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::recreateSwapChain( void ) 
{    
    if ( !_device )
        return;

    //! We first call `vkDeviceWaitIdle`, because just like in the last chapter, we shouldn't touch resources that may still be in use.
    //! Obviously, the first thing we'll have to do is recreate the swap chain itself.
    //! The image views need to be recreated because they are based directly on the swap chain images.
    // !The render pass needs to be recreated because it depends on the format of the swap chain images.
    // !It is rare for the swap chain image format to change during an operation like a window resize, but it should still be handled.
    // !Viewport and scissor rectangle size is specified during graphics pipeline creation, so the pipeline also needs to be rebuilt.
    // !It is possible to avoid this by using dynamic state for the viewports and scissor rectangles.
    //! Finally, the framebuffers and command buffers also directly depend on the swap chain images.

    _device->get()->waitIdle();

    // pause till the window is minimized
    int width = 0, height = 0;
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(_wnd, &width, &height);
        glfwWaitEvents();
    }

    //pickPhysicalDevice();
    // update swap chain information
    _physical_device->get().evaluate_swapchain_support(*_surface);
    
    cleanupSwapChain();
    createSwapChain(false);
}


void CAppliction::createSwapChain(bool initilaize)
{
    vk::Format depthFormat = vk_utility::core::FormatSelector()
        .set_tiling(vk::ImageTiling::eOptimal)
        .set_feataures(vk::FormatFeatureFlagBits::eDepthStencilAttachment)
        .find_supported_format(*_physical_device, { vk::Format::eD32Sfloat, vk::Format::eD32SfloatS8Uint, vk::Format::eD24UnormS8Uint });

    _swapchain = vk_utility::swap::SwapchainFactoryDefault()
        .set_format_selector(std::make_shared<vk_utility::swap::SwapSurfaceFormatSelectorDefault>())
        .set_present_mode_selector(std::make_shared<vk_utility::swap::SwapPresentModeSelectorDefault>())
        .set_extent_selector(std::make_shared<vk_glfw_utility::swap::SwapExtentSelector>(_wnd))
        .New(_device, _surface);

    _swapchain_image_views = vk_utility::image::ImageView::NewPtrVector(
        *_device,
        vk_utility::image::SwapchainImageViewFactoryDefault()
            .set_swapchain(_swapchain));

    _render_pass = vk_utility::core::RenderPassFactoryDefault()
        .set_color_format(_swapchain->get().image_format())
        .set_depth_format(depthFormat)
        .set_sampple_count(_physical_device->get().get_max_usable_sample_count())
        .New(_device);

    _pipeline_layout = vk_utility::pipeline::PipelineLayout::New(_device, _descriptor_set_layout);

    auto vert_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_vert.spv")
        .New(_device);
    auto frag_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_frag.spv")
        .New(_device);
    auto bindingDescription = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    _graphics_pipeline = vk_utility::pipeline::PipelienFactoryDefault()
        .add_shader_module(vert_shader_module, vk::ShaderStageFlagBits::eVertex)
        .add_shader_module(frag_shader_module, vk::ShaderStageFlagBits::eFragment)
        .add_vertex_binding_description(bindingDescription)
        .add_attribute_descriptions(std::vector<vk::VertexInputAttributeDescription>(attributeDescriptions.begin(), attributeDescriptions.end()))
        .enable_face_culling(_enable_face_culling)
        .set_pipeline_layout(_pipeline_layout)
        .set_render_pass(_render_pass)
        .New(_device, _swapchain);

    _command_pool = vk_utility::command::CommandPool::NewPtr(
        _device->get(),
        vk_utility::command::CommandPoolFactoryDefault()
        .set_device_queue_information(_physical_device->get().get_queue_information_ptr()));

    vk::Format colorFormat = _swapchain->get().image_format();
    _color_image_view_memorys.emplace_back(
        vk_utility::image::ImageViewAndImageMemory::NewPtr(
            *_device,
            vk_utility::image::ImageViewAndImageMemoryFactoryDefault()
            .set_image_and_memory_factory(&vk_utility::image::ImageAndMemoryFactoryDefault()
                .set_image_factory(&vk_utility::image::ImageFactory2D()
                    .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
                    .set_format(colorFormat)
                    .set_mipmap_levels(1)
                    .set_samples(_physical_device->get().get_max_usable_sample_count())
                    .set_usage(vk::ImageUsageFlagBits::eTransientAttachment | vk::ImageUsageFlagBits::eColorAttachment))
                .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
                    .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
                    .set_from_physical_device(_device->get().physical_device())))
            .set_image_view_factory(&vk_utility::image::ImageViewFactoryDefault()
                .set_format(colorFormat)
                .set_aspect_flags(vk::ImageAspectFlagBits::eColor)
                .set_mipmap_levels(1))));

    _depth_image_view_memorys.emplace_back(
        vk_utility::image::ImageViewAndImageMemory::NewPtr(
            *_device,
            vk_utility::image::ImageViewAndImageMemoryFactoryDefault()
            .set_image_and_memory_factory(&vk_utility::image::ImageAndMemoryFactoryDefault()
                .set_image_factory(&vk_utility::image::ImageFactory2D()
                    .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
                    .set_format(depthFormat)
                    .set_mipmap_levels(1)
                    .set_samples(_physical_device->get().get_max_usable_sample_count())
                    .set_usage(vk::ImageUsageFlagBits::eDepthStencilAttachment))
                .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
                    .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
                    .set_from_physical_device(_device->get().physical_device())))
            .set_image_view_factory(&vk_utility::image::ImageViewFactoryDefault()
                .set_format(depthFormat)
                .set_aspect_flags(vk::ImageAspectFlagBits::eDepth)
                .set_mipmap_levels(1))));
    
    _swapchain_framebuffers = vk_utility::buffer::FramebufferFactoryDefault()
        .set_swapchain(_swapchain)
        .set_swapchain_image_views(_swapchain_image_views)
        .set_color_image_view(_color_image_view_memorys.front())
        .set_depth_image_view(_depth_image_view_memorys.front())
        .set_render_pass(_render_pass)
        .New(_device->get());

    if (initilaize)
    {
        createTextureImage();

        loadModel();

        auto vertex_buffer = vk_utility::buffer::BufferAndMemory::NewPtr(
            *_device,
            vk_utility::buffer::BufferAndMemoryFactoryDefault()
            .set_buffer_factory(
                &vk_utility::buffer::BufferFactoryDefault()
                    .set_buffer_size(sizeof(_vertices[0]) * _vertices.size())
                    .set_vertex_buffer_usage())
            .set_buffer_memory_factory(
                &vk_utility::buffer::BufferDeviceMemoryFactory()
                    .set_from_physical_device(*_device->get().physical_device())));
        vk_utility::buffer::BufferOperatorCopyDataStaging::New(_device, std::make_shared<CopyBufferHelper>(*this))
            ->copy(vertex_buffer, 0, sizeof(_vertices[0]) * _vertices.size(), _vertices.data());
        _vertex_buffers.push_back(vertex_buffer);

        auto index_buffer = vk_utility::buffer::BufferAndMemory::NewPtr(
            *_device,
            vk_utility::buffer::BufferAndMemoryFactoryDefault()
            .set_buffer_factory(
                &vk_utility::buffer::BufferFactoryDefault()
                    .set_buffer_size(sizeof(_indices[0]) * _indices.size())
                    .set_index_buffer_usage())
            .set_buffer_memory_factory(
                &vk_utility::buffer::BufferDeviceMemoryFactory()
                    .set_from_physical_device(*_device->get().physical_device())));
        vk_utility::buffer::BufferOperatorCopyDataStaging::New(_device, std::make_shared<CopyBufferHelper>(*this))
            ->copy(index_buffer, 0, sizeof(_indices[0]) * _indices.size(), _indices.data());
        _index_buffers.push_back(index_buffer);
    }

    // We're going to copy new data to the uniform buffer every frame, so it doesn't really make any sense to have a staging buffer.
    // It would just add extra overhead in this case and likely degrade performance instead of improving it.

    // We should have multiple buffers, because multiple frames may be in flight at the same time and
    // we don't want to update the buffer in preparation of the next frame while a previous one is still reading from it!
    // We could either have a uniform buffer per frame or per swap chain image.
    // However, since we need to refer to the uniform buffer from the command buffer that we have per swap chain image,
    // it makes the most sense to also have a uniform buffer per swap chain image.

    vk::DeviceSize bufferSize = sizeof(UniformBufferObject);
    for (size_t i = 0; i < _swapchain->get().no_of_swapchain_images(); i++)
    {
        _uniform_buffers.push_back(vk_utility::buffer::BufferAndMemory::NewPtr(
            *_device, 
            vk_utility::buffer::BufferAndMemoryFactoryDefault()
                .set_buffer_factory(
                    &vk_utility::buffer::BufferFactoryDefault()
                        .set_buffer_size(bufferSize)
                        .set_coherent_uniform_buffer_usage())
                .set_buffer_memory_factory(
                    &vk_utility::buffer::BufferDeviceMemoryFactory()
                        .set_coherent_memory_properties()
                        .set_from_physical_device(_device->get().physical_device()))));
    }

    _descriptor_pool = vk_utility::core::DescriptorPool::NewPtr(
        *_device,
        vk_utility::core::DescriptorPoolFactoryDefault()
        .set_no_of_swapchain_images(_swapchain->get().no_of_swapchain_images()));

    createDescriptorSets();
    createCommandBuffers();
}


/******************************************************************//**
* \brief Cleanup everything which will be recreated till swapchain
* is recreated.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::cleanupSwapChain( void ) {

    _depth_image_view_memorys.clear();
    _color_image_view_memorys.clear();
    _uniform_buffers.clear();
    _descriptor_pool = nullptr,
    //! You don't need to explicitly clean up descriptor sets, because they will be automatically freed when the descriptor pool is destroyed.
    _descriptorSets.clear();
    _swapchain_framebuffers.clear();

    if (_command_pool)
        _device->get()->freeCommandBuffers(_command_pool->get(), _commandBuffers);
    _commandBuffers.clear();

    _graphics_pipeline = nullptr;
    _pipeline_layout = nullptr;
    _render_pass = nullptr;
    _swapchain_image_views.clear();
    _swapchain = nullptr;
}


/******************************************************************//**
* \brief Create texture image.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::createTextureImage( void ) {

    if ( !_device )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Loading an image
    //-------------------------------------------
    
    std::string image_name = "../../../_data/wood.png";
    if (_load_model)
        image_name = TEXTURE_PATH;

    int texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(image_name.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
    vk::DeviceSize imageSize = (size_t)texWidth * texHeight * 4;

    if (!pixels) {
        throw CException("failed to load texture image!");
    }


    //-------------------------------------------
    // Staging buffer
    //-------------------------------------------

    //! We're now going to create a buffer in host visible memory so that we can use vkMapMemory and copy the pixels to it.
    //! Add variables for this temporary buffer to the createTextureImage function:
    //! The buffer should be in host visible memory so that we can map it and it should be usable as a transfer source so that we can copy it to an image later on:
    //! We can then directly copy the pixel values that we got from the image loading library to the buffer:

    auto staging_buffer = vk_utility::buffer::BufferAndMemory::NewPtr(
        *_device,
        vk_utility::buffer::BufferAndMemoryFactoryDefault()
            .set_buffer_factory(
                &vk_utility::buffer::BufferFactoryDefault()
                    .set_buffer_size(imageSize)
                    .set_staging_buffer_usage())
            .set_buffer_memory_factory(
                &vk_utility::buffer::BufferDeviceMemoryFactory()
                    .set_staging_memory_properties()
                    .set_from_physical_device(*_device->get().physical_device())));
    vk_utility::buffer::BufferOperatorCopyDataToMemory::New()
        ->copy(staging_buffer, 0, staging_buffer->get().memory().size(), pixels);

    stbi_image_free( pixels );

    uint32_t mipmap_levels = static_cast<uint32_t>(std::floor(std::log2(std::max(texWidth, texHeight)))) + 1;
   
    vk::ImageUsageFlags usage_flags = vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled;
    if (mipmap_levels > 1)
        usage_flags |= vk::ImageUsageFlagBits::eTransferSrc;

    auto image_and_memory = vk_utility::image::ImageAndMemory::NewPtr(
        _device->get(),
        vk_utility::image::ImageAndMemoryFactoryDefault()
        .set_image_factory(&vk_utility::image::ImageFactory2D()
            .set_size(texWidth, texHeight)
            .set_format(vk::Format::eR8G8B8A8Srgb)
            .set_mipmap_levels(mipmap_levels)
            .set_samples(vk::SampleCountFlagBits::e1)
            .set_usage(usage_flags))
        .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
            .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
            .set_from_physical_device(_device->get().physical_device()))
    );

    //-------------------------------------------
    // Preparing the texture image
    //-------------------------------------------
 
    //! Copy the staging buffer to the texture image. This involves two steps:
    //!     Transition the texture image to VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    //!     Execute the buffer to image copy operation

    //! The image was created with the VK_IMAGE_LAYOUT_UNDEFINED layout, so that one should be specified as old layout when transitioning textureImage.
    //! Remember that we can do this because we don't care about its contents before performing the copy operation.

    auto single_time_command_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);

    vk_utility::image::ImageTransitionCommand()
        .set_command_buffer_factory(&single_time_command_factory)
        .set_image(*image_and_memory->get().image())
        .set_mipmap_levels(mipmap_levels)
        .set_old_layout(vk::ImageLayout::eUndefined)
        .set_new_layout(vk::ImageLayout::eTransferDstOptimal)
        .execute_command(*_device, *_command_pool);

    vk_utility::image::ImageCopyBufferToImageCommand()
        .set_command_buffer_factory(&single_time_command_factory)
        .set_buffer(staging_buffer->get().buffer())
        .set_image(*image_and_memory->get().image())
        .set_size(static_cast<uint32_t>(texWidth), static_cast<uint32_t>(texHeight))
        .execute_command(*_device, *_command_pool);

    //! To be able to start sampling from the texture image in the shader, we need one last transition to prepare it for shader access:
    //transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps
    if (mipmap_levels == 1)
        vk_utility::image::ImageTransitionCommand()
            .set_command_buffer_factory(&single_time_command_factory)
            .set_image(*image_and_memory->get().image())
            .set_mipmap_levels(1)
            .set_old_layout(vk::ImageLayout::eTransferDstOptimal)
            .set_new_layout(vk::ImageLayout::eShaderReadOnlyOptimal)
            .execute_command(*_device, *_command_pool);
    
    staging_buffer->get().destroy();

    if (mipmap_levels > 1)
        vk_utility::image::GeneratrMipmapsCommand()
            .set_command_buffer_factory(&single_time_command_factory)
            .set_image(*image_and_memory->get().image())
            .set_size(static_cast<uint32_t>(texWidth), static_cast<uint32_t>(texHeight))
            .set_mipmap_levels(mipmap_levels)
            .set_format(vk::Format::eR8G8B8A8Srgb)
            .execute_command(*_device, *_command_pool);

     auto image_view = vk_utility::image::ImageView::NewPtr(
         *_device,
         vk_utility::image::ImageViewFactoryDefault()
             .set_image(*image_and_memory->get().image())
             .set_format(vk::Format::eR8G8B8A8Srgb)
             .set_aspect_flags(vk::ImageAspectFlagBits::eColor)
             .set_mipmap_levels(mipmap_levels));

    _texture_image_view_memorys.emplace_back(
        vk_utility::image::ImageViewAndImageMemory::NewPtr(image_and_memory->get().detach_device_memory(), image_and_memory->get().detach_image(), image_view));

    _texture_samplers.push_back(vk_utility::image::Sampler::NewPtr(
        *_device,
        vk_utility::image::SamplerFactoryDefault()
            .set_mipmap_levels(mipmap_levels)));
}


/******************************************************************//**
* \brief Create descriptor sets.
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorSets( void )
{
    if (!_device)
        throw CException("no logical vulkan device!");
    if (!_descriptor_pool)
        throw CException("no descriptor pool!");
    if (_uniform_buffers.size() < _swapchain->get().no_of_swapchain_images())
        throw CException("missing uniform buffers");

    //-------------------------------------------
    // Descriptor set
    //------------------------------------------- 

    //! A descriptor set allocation is described with a `vk::DescriptorSetAllocateInfo` structures.
    //! You need to specify the descriptor pool to allocate from, the number of descriptor sets to allocate, and the descriptor layout to base them on:
    
    std::vector<vk::DescriptorSetLayout> layouts(_swapchain->get().no_of_swapchain_images(), _descriptor_set_layout->get());
    vk::DescriptorSetAllocateInfo allocInfo(*_descriptor_pool, layouts);

    _descriptorSets = _device->get()->allocateDescriptorSets(allocInfo);

    //! The descriptor sets have been allocated now, but the descriptors within still need to be configured.
    //! We'll now add a loop to populate every descriptor:

    //! Descriptors that refer to buffers, like our uniform buffer descriptor, are configured with a `vk::DescriptorBufferInfo` structures.
    // This structure specifies the buffer and the region within it that contains the data for the descriptor.

    for (size_t i = 0; i < _swapchain->get().no_of_swapchain_images(); i++) {

        std::vector<vk::WriteDescriptorSet> descriptorWrites;

        //! If you're overwriting the whole buffer, like we are in this case, then it is also possible to use the VK_WHOLE_SIZE value for the range.
        //! The configuration of descriptors is updated using the vkUpdateDescriptorSets function, which takes an array of `vk::WriteDescriptorSet` structures as parameter.

        //! The first two fields specify the descriptor set to update and the binding.
        //! We gave our uniform buffer binding index 0. Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
        //! We're not using an array, so the index is simply 0.

        //! We need to specify the type of descriptor again.
        //! It's possible to update multiple descriptors at once in an array, starting at index dstArrayElement.
        //! The descriptorCount field specifies how many array elements you want to update.

        std::vector<vk::DescriptorImageInfo> image_infos;
        std::vector<vk::DescriptorBufferInfo> bufferInfos
        { 
            vk::DescriptorBufferInfo(_uniform_buffers[i]->get().buffer(), 0, sizeof(UniformBufferObject))
        };
        std::vector<vk::BufferView> texel_buffer_view;
        descriptorWrites.push_back(
            vk::WriteDescriptorSet
            (
                _descriptorSets[i],
                0,
                0,
                vk::DescriptorType::eUniformBuffer,
                image_infos,
                bufferInfos,
                texel_buffer_view
            ));

        //! The last field references an array with descriptorCount structures that actually configure the descriptors.
        //! It depends on the type of descriptor which one of the three you actually need to use.
        //! The pBufferInfo field is used for descriptors that refer to buffer data, pImageInfo is used for descriptors that refer to image data,
        //! and pTexelBufferView is used for descriptors that refer to buffer views.
        //! Our descriptor is based on buffers, so we're using pBufferInfo.

        for (size_t j = 0; j < _texture_image_view_memorys.size(); ++j)
        {
            vk::DescriptorImageInfo imageInfo(*_texture_samplers[j], *_texture_image_view_memorys[j]->get().image_view(),  vk::ImageLayout::eShaderReadOnlyOptimal);

            descriptorWrites.push_back(
                vk::WriteDescriptorSet
                (
                    _descriptorSets[i],
                    1,
                    0,
                    1,
                    vk::DescriptorType::eCombinedImageSampler,
                    &imageInfo,
                    nullptr,
                    nullptr
                ));
        }

        _device->get()->updateDescriptorSets(descriptorWrites, nullptr);

        //! The updates are applied using vkUpdateDescriptorSets. It accepts two kinds of arrays as parameters:
        //! an array of `vk::WriteDescriptorSet` and an array of `vk::CopyDescriptorSet`. 
        //! The latter can be used to copy descriptors to each other, as its name implies.
    }
}


/******************************************************************//**
* \brief   create command buffers.
* 
* \author  gernot
* \date    2018-05-25
* \version 1.0
**********************************************************************/
void CAppliction::createCommandBuffers( void ) 
{
    if (!_device)
        throw CException("no logical vulkan device!");
    if (!_command_pool)
        throw CException("no vulkan command pool!");
   

    //-------------------------------------------
    // Command buffer allocation
    //-------------------------------------------

    //! The level parameter specifies if the allocated command buffers are primary or secondary command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_PRIMARY`: Can be submitted to a queue for execution, but cannot be called from other command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_SECONDARY`: Cannot be submitted directly, but can be called from primary command buffers.

    _commandBuffers.resize(_swapchain_framebuffers.size());
    
    vk::CommandBufferAllocateInfo allocInfo(_command_pool->get(), vk::CommandBufferLevel::ePrimary, (uint32_t)_commandBuffers.size());

    _commandBuffers = _device->get()->allocateCommandBuffers(allocInfo);


    //-------------------------------------------
    // Starting command buffer recording
    //-------------------------------------------

    //! The flags parameter specifies how we're going to use the command buffer. The following values are available:
    //! - `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`: The command buffer will be rerecorded right after executing it once.
    //! - `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`: This is a secondary command buffer that will be entirely within a single render pass.
    //! - `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`: The command buffer can be resubmitted while it is also already pending execution.

    for (size_t i = 0; i < _commandBuffers.size(); i++)
    {
        vk::CommandBufferBeginInfo beginInfo(vk::CommandBufferUsageFlagBits::eSimultaneousUse, nullptr);

        _commandBuffers[i].begin(beginInfo);

        //! We have used the last flag because we may already be scheduling the drawing commands for the next frame while the last frame is not finished yet.
        //! The pInheritanceInfo parameter is only relevant for secondary command buffers. It specifies which state to inherit from the calling primary command buffers.

        //! If the command buffer was already recorded once, then a call to vkBeginCommandBuffer will implicitly reset it.
        //! It's not possible to append commands to a buffer at a later time.
       

        //-------------------------------------------
        // Starting a render pass
        //-------------------------------------------

        //! The render pass can now begin. All of the functions that record commands can be recognized by their vkCmd prefix.
        //! They all return void, so there will be no error handling until we've finished recording.

        //! The first parameters are the render pass itself and the attachments to bind. 
        //! We created a framebuffer for each swap chain image that specifies it as color attachment.

        //! The next two parameters define the size of the render area.
        //! The render area defines where shader loads and stores will take place.
        //! The pixels outside this region will have undefined values.
        //! It should match the size of the attachments for best performance.

        //! The last two parameters define the clear values to use for VK_ATTACHMENT_LOAD_OP_CLEAR, which we used as load operation for the color attachment.
        //! I've defined the clear color to simply be black with 100% opacity.

        std::vector<vk::ClearValue> clearValues
        {
            vk::ClearValue(vk::ClearColorValue(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f})),
            vk::ClearValue(vk::ClearDepthStencilValue(1.0f, 0))
        };

        vk::RenderPassBeginInfo renderPassInfo
        (
            _render_pass->handle(),
            _swapchain_framebuffers[i]->handle(),
            vk::Rect2D(vk::Offset2D(0, 0), _swapchain->get().image_extent_2D()),
            clearValues
        );


        //! The first parameter for every command is always the command buffer to record the command to.
        //! The second parameter specifies the details of the render pass we've just provided. The final parameter controls how the drawing commands within the render pass will be provided.
        //! It can have one of two values:
        //! - `VK_SUBPASS_CONTENTS_INLINE`: The render pass commands will be embedded in the primary command buffer itself and no secondary command buffers will be executed.
        //! - `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`: The render pass commands will be executed from secondary command buffers.

        _commandBuffers[i].beginRenderPass(renderPassInfo, vk::SubpassContents::eInline);


        //-------------------------------------------
        // Basic drawing commands
        //-------------------------------------------
        
        //! The second parameter specifies if the pipeline object is a graphics or compute pipeline.
    
        _commandBuffers[i].bindPipeline(vk::PipelineBindPoint::eGraphics, *_graphics_pipeline);

        //! The actual vkCmdDraw function is a bit anticlimactic, but it's so simple because of all the information we specified in advance.
        //! It has the following parameters, aside from the command buffer:
        //! - vertexCount: Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.
        //! - instanceCount: Used for instanced rendering, use 1 if you're not doing that.
        //! - firstVertex: Used as an offset into the vertex buffer, defines the lowest value of gl_VertexIndex.
        //! - firstInstance: Used as an offset for instanced rendering, defines the lowest value of gl_InstanceIndex.

        //! The `vkCmdBindVertexBuffers` function is used to bind vertex buffers to bindings, like the one we set up in the previous chapter.
        //! The first two parameters, besides the command buffer, specify the offset and number of bindings we're going to specify vertex buffers for.
        //! The last two parameters specify the array of vertex buffers to bind and the byte offsets to start reading vertex data from.
        //! You should also change the call to vkCmdDraw to pass the number of vertices in the buffer as opposed to the hardcoded number 3.

        std::vector<vk::Buffer> vertexBuffers = { _vertex_buffers.back()->get().buffer() };
        std::vector<vk::DeviceSize> offsets = { 0 };
        _commandBuffers[i].bindVertexBuffers(0, vertexBuffers, offsets);

        // vkCmdDraw(_commandBuffers[i], static_cast<uint32_t>(vertices.size()), 1, 0, 0);


        //-------------------------------------------
        // Using an index buffer
        //-------------------------------------------

        //! Using an index buffer for drawing involves two changes to createCommandBuffers.
        //! We first need to bind the index buffer, just like we did for the vertex buffer.
        //! The difference is that you can only have a single index buffer.
        //! It's unfortunately not possible to use different indices for each vertex attribute,
        //! so we do still have to completely duplicate vertex data even if just one attribute varies.

        //! An index buffer is bound with vkCmdBindIndexBuffer which has the index buffer, a byte offset into it,
        //! and the type of index data as parameters. As mentioned before, the possible types are VK_INDEX_TYPE_UINT16 and VK_INDEX_TYPE_UINT32.

        vk::IndexType index_type = sizeof(*_indices.data()) == 4 ? vk::IndexType::eUint32 : (sizeof(*_indices.data()) == 2 ? vk::IndexType::eUint16 : vk::IndexType::eUint8EXT);
        _commandBuffers[i].bindIndexBuffer(_index_buffers.back()->get().buffer(), 0, index_type);

    
        //-------------------------------------------
        // Using descriptor sets
        //-------------------------------------------

        //! Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines.
        //! Therefore we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
        //! The next parameter is the layout that the descriptors are based on.
        //! The next three parameters specify the index of the first descriptor set, the number of sets to bind, and the array of sets to bind. We'll get back to this in a moment.
        //! The last two parameters specify an array of offsets that are used for dynamic descriptors.

        _commandBuffers[i].bindDescriptorSets(vk::PipelineBindPoint::eGraphics, *_pipeline_layout, 0, 1, &_descriptorSets[i], 0, nullptr);


        //! Just binding an index buffer doesn't change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
        //! Remove the vkCmdDraw line and replace it with vkCmdDrawIndexed:

        vkCmdDrawIndexed(_commandBuffers[i], static_cast<uint32_t>(_indices.size()), 1, 0, 0, 0);


        //-------------------------------------------
        // Finishing up
        //-------------------------------------------

        _commandBuffers[i].endRenderPass();
        _commandBuffers[i].end();
    }    
}


/******************************************************************//**
* \brief   do the drawing
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::drawFrame( void )
{
    //! The `vkWaitForFences` function takes an array of fences and waits for either any or all of them to be signaled before returning.
    //! The `VK_TRUE` we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter.
    //! Just like `vkAcquireNextImageKHR` this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the vkResetFences call.

    std::vector<vk::Fence> fences{ *_in_flight_fences[_currentFrame] };
    auto result = _device->get()->waitForFences(fences, VK_TRUE, std::numeric_limits<uint64_t>::max());

    //-------------------------------------------
    // Acquiring an image from the swap chain
    //-------------------------------------------

    //! The first two parameters of `vkAcquireNextImageKHR` are the logical device and the swap chain from which we wish to acquire an image.
    //! The third parameter specifies a timeout in nanoseconds for an image to become available.
    //! Using the maximum value of a 64 bit unsigned integer disables the timeout.

    //! The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image.
    //! That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both.
    //! We're going to use our imageAvailableSemaphore for that purpose here.

    //! The last parameter specifies a variable to output the index of the swap chain image that has become available.
    //! The index refers to the `vk::Image` in our swapChainImages array.

    uint32_t imageIndex;
    vk::Result acquireNextImageResult;
    result = _device->get()->acquireNextImageKHR(*_swapchain, std::numeric_limits<uint64_t>::max(), *_image_available_semaphores[_currentFrame], vk::Fence(), &imageIndex);
    acquireNextImageResult = result;
    
    if (acquireNextImageResult == vk::Result::eErrorOutOfDateKHR || acquireNextImageResult == vk::Result::eSuboptimalKHR || _framebufferResized) {
        _framebufferResized = false;
        recreateSwapChain();
        return;
    } 

    result = _device->get()->resetFences(1, &fences[0]);


    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------
    
    updateUniformBuffer(imageIndex);

    //-------------------------------------------
    // Submitting the command buffer
    //-------------------------------------------
    
    //! The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
    //! We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment.
    //! That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. 
    //! Each entry in the waitStages array corresponds to the semaphore with the same index in pWaitSemaphores.

    //! The next two parameters specify which command buffers to actually submit for execution.
    //! As mentioned earlier, we should submit the command buffer that binds the swap chain image we just acquired as color attachment.

    //! The signalSemaphoreCount and pSignalSemaphores parameters specify which semaphores to signal once the command buffer(s) have finished execution.
    //! In our case we're using the renderFinishedSemaphore for that purpose.

    std::vector<vk::Semaphore> waitSemaphores{*_image_available_semaphores[_currentFrame]};
    std::vector<vk::Semaphore> signalSemaphores{*_render_finished_semaphores[_currentFrame]};
    std::vector<vk::PipelineStageFlags> waitStages{vk::PipelineStageFlagBits::eColorAttachmentOutput};
    std::vector<vk::CommandBuffer> commandbuffers{_commandBuffers[imageIndex]};

    vk::SubmitInfo submitInfo(waitSemaphores, waitStages, commandbuffers, signalSemaphores);

    result = _graphicsQueue.submit(1, &submitInfo, *_in_flight_fences[_currentFrame]);
 
    //-------------------------------------------
    // Presentation
    //-------------------------------------------
    
    //! The next two parameters specify the swap chains to present images to and the index of the image for each swap chain.
    //! This will almost always be a single one.

    //! There is one last optional parameter called pResults.
    //! It allows you to specify an array of `vk::Result` values to check for every individual swap chain if presentation was successful. 
    //! It's not necessary if you're only using a single swap chain, because you can simply use the return value of the present function.

    std::vector<vk::SwapchainKHR> swapChains{_swapchain->handle()};
    std::vector<uint32_t> imageIndexs{imageIndex};
    std::vector<vk::Result> resutl;

    vk::PresentInfoKHR presentInfo(signalSemaphores, swapChains, imageIndexs, resutl);

    result = _presentQueue.presentKHR(presentInfo);

    //-------------------------------------------
    // Frames in flight
    //-------------------------------------------
    
    //! If you run your application with validation layers enabled and you monitor the memory usage of your application, you may notice that it is slowly growing.
    //! The reason for this is that the application is rapidly submitting work in the drawFrame function, but doesn't actually check if any of it finishes.
    //! If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work.
    //! Worse, even, is that we are reusing the imageAvailableSemaphore and renderFinishedSemaphore for multiple frames at the same time.

    //! The easy way to solve this is to wait for work to finish right after submitting it, for example by using vkQueueWaitIdle.
    //! However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now.
    //! The stages that the current frame has already progressed through are idle and could already be used for a next frame.

    //vkQueuePresentKHR(_presentQueue, &presentInfo);
    //vkQueueWaitIdle(_presentQueue);


    _currentFrame = (_currentFrame + 1) % _image_available_semaphores.size();
}


/******************************************************************//**
* \brief   update the uniform buffer for the current image
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::updateUniformBuffer( uint32_t imageIndex )
{
    if ( !_device )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------

    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    UniformBufferObject ubo = {};
    ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = glm::perspective(glm::radians(45.0f), _swapchain->get().image_width_2D() / (float) _swapchain->get().image_height_2D(), 0.1f, 10.0f);

    // GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
    // The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the projection matrix.
    // If you don't do this, then the image will be rendered upside down.
    ubo.proj[1][1] *= -1;

    _uniform_buffers[imageIndex]->get().memory().copy(&ubo);
}


} // VulkanLoader


using HelloTriangleApplication = VulkanLoader::CAppliction;


int main() 
{    
    static bool verbose                      = true;
    static bool enable_all_validation_layers = false;
    static bool enable_surface_extensions    = true;
    static bool enable_swapchain_extensions  = true;
    static bool enable_validation_warnings   = true;
    static bool enable_debug_extensions      = true;
    static bool enable_debug_information     = false;
    static bool enable_depth_test            = true;
    static bool enable_face_culling          = false;
    static bool load_model                   = true;
    
    HelloTriangleApplication app( verbose );

    const std::vector<std::string> validationLayers = {
        //"VK_LAYER_LUNARG_api_dump",
        "VK_LAYER_KHRONOS_validation",
        "VK_LAYER_LUNARG_monitor",
        "VK_LAYER_LUNARG_screenshot",
        "VK_LAYER_NV_optimus"
    };
    const std::vector<std::string> excludeValidationLayers = {
        "VK_LAYER_LUNARG_device_simulation",
        "VK_LAYER_LUNARG_vktrace",
        "VK_LAYER_RENDERDOC_Capture" //!< causes instance creation fail; why?
    };

    app.scene(load_model);
    app.layers(validationLayers, enable_all_validation_layers, excludeValidationLayers);
    app.settings(enable_depth_test, enable_face_culling);

    const std::vector<std::string> extensions = {
        "VK_KHR_win32_surface", // seems to be strongly required for win32 application (at least for GLFW)
    };
    app.extensions( 
      extensions,
      enable_surface_extensions,
      enable_validation_warnings,
      enable_debug_extensions,
      enable_debug_information );

    const std::vector<std::string> device_extensions = {};
    app.deviceExtensions( 
      device_extensions,
      enable_swapchain_extensions );

    bool exit_success = true;
    try {
        app.run();
    } catch (const std::runtime_error& e) {
        std::cerr << e.what() << std::endl;
        exit_success = false;
    }

    return exit_success ? EXIT_SUCCESS : EXIT_FAILURE;
}