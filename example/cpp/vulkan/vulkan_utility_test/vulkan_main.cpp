#include <stdafx.h>


// Vulkan

//! Vulkan is included by GLFW library
//#include <vulkan/vulkan.h>


// GLM

#define GLM_ENABLE_EXPERIMENTAL

#define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/hash.hpp>


// STB

#define STB_IMAGE_IMPLEMENTATION
//#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>


// TINYOBJLOADER

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>


// Vulkan

#include <vk_utility_vulkan_include.h>
#include <vk_utility_parameter_helper.h>
#include <vk_utility_validation_layers.h>
#include <vk_utility_extensions.h>
#include <vk_utility_instance.h>
#include <vk_utility_instance_factory.h>
#include <vk_utility_debug.h>
#include <vk_utility_surface.h>
#include <vk_utility_physical_device.h>
#include <vk_utility_physical_device_extensions.h>
#include <vk_utility_physical_device_rate_default.h>
#include <vk_utility_device.h>
#include <vk_utility_device_factory.h>
#include <vk_utility_device_factory_default.h>
#include <vk_utility_device_memory.h>
#include <vk_utility_buffer.h>
#include <vk_utility_buffer_and_memory.h>
#include <vk_utility_logging.h>
#include <vk_utility_logging_physical_device.h>
#include <vk_utility_render_pass.h>
#include <vk_utility_render_pass_factory.h>
#include <vk_utility_render_pass_factory_default.h>
#include <vk_utility_descriptor_set_layout.h>
#include <vk_utility_descriptor_set_layout_factory.h>
#include <vk_utility_descriptor_set_layout_factory_default.h>
#include <vk_utility_swap_surface_format_selector.h>
#include <vk_utility_swap_surface_fromat_selector_default.h>
#include <vk_utility_swap_present_mode_selector.h>
#include <vk_utility_swap_present_mode_selector_default.h>
#include <vk_utility_swap_extent_selector.h>
#include <vk_utility_swapchain.h>
#include <vk_utility_swapchain_factory.h>
#include <vk_utility_swapchain_factory_default.h>
#include <vk_utility_shader_module.h>
#include <vk_utility_shader_module_factory_spirv_file.h>
#include <vk_utility_shader_stage_create_information.h>
#include <vk_utility_pipeline.h>
#include <vk_utility_pipeline_layout.h>
#include <vk_utility_pipeline_factory_default.h>
#include <vk_utility_image_view.h>
#include <vk_utility_image_view_and_image_memory.h>
#include <vk_utility_swapchain_image_views_factory_default.h>
#include <vk_utility_framebuffer.h>
#include <vk_utility_swapchain_framebuffer_factory_default.h>
#include <vk_utility_command_pool.h>
#include <vk_utility_command_pool_factory_default.h>
#include <vk_utility_command_buffer.h>
#include <vk_utility_command_buffer_factory_single_time_command.h>
#include <vk_utility_image_factory_2d.h>
#include <vk_utility_image_device_memory_factory.h>
#include <vk_utility_image_and_memory.h>
#include <vk_utility_image_and_memory_factory_default.h>
#include <vk_utility_image_view_factory_default.h>
#include <vk_utility_image_view_and_image_memory_factory_default.h>
#include <vk_utility_image_transition_command.h>
#include <vk_utility_image_copy_buffer_to_image_command.h>
#include <vk_utility_sampler.h>
#include <vk_utility_sampler_factory_default.h>
#include <vk_utility_descriptor_pool.h>
#include <vk_utility_descriptor_pool_factory_default.h>
#include <vk_utility_semaphore.h>
#include <vk_utility_semaphore_factory_default.h>
#include <vk_utility_fence.h>
#include <vk_utility_fence_factory_default.h>
#include <vk_utility_format_selector.h>
#include <vk_utility_image_generate_mipmaps_command.h>
#include <vk_utility_buffer_device_memory_factory.h>
#include "vk_utility_buffer_factory_default.h"
#include "vk_utility_device_memory_factory_default.h"
#include "vk_utility_buffer_and_memory_factory_default.h"
#include "vk_utility_buffer_copy_data_staging_command.h"
#include "vk_utility_texture_factory_default.h"
#include "vk_utility_sampler_and_imageview_image_memory.h"
#include "vk_utility_descriptor_sets_factory_default.h"
#include "vk_utility_command_buffers_factory_default.h"
#include "vk_utility_command_buffers.h"

// GLFW

#include <vk_glfw_utility_include.h>
#include <vk_glfw_utility_extensions.h>
#include <vk_glfw_utility_surface_factory.h>
#include <vk_glfw_utility_swap_extent_selector.h>


// STL

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <tuple>
#include <array>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <chrono>
#include <cmath>
#include <math.h>


const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;


const std::string MODEL_PATH = "../../../../../model/viking_room/viking_room.obj";
const std::string TEXTURE_PATH = "../../../../../model/viking_room/viking_room.png";



struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    bool operator==(const Vertex& other) const {
        return pos == other.pos && color == other.color && texCoord == other.texCoord;
    }

    static vk::VertexInputBindingDescription getBindingDescription( void );
    static std::array<vk::VertexInputAttributeDescription, 3> getAttributeDescriptions( void );
};


namespace std {
    template<> struct hash<Vertex> {
        size_t operator()(Vertex const& vertex) const {
            return ((hash<glm::vec3>()(vertex.pos) ^
                   (hash<glm::vec3>()(vertex.color) << 1)) >> 1) ^
                   (hash<glm::vec2>()(vertex.texCoord) << 1);
        }
    };
}


vk::VertexInputBindingDescription Vertex::getBindingDescription( void ) {
    
    vk::VertexInputBindingDescription bindingDescription(0, sizeof(Vertex), vk::VertexInputRate::eVertex);
    return bindingDescription;
}

std::array<vk::VertexInputAttributeDescription, 3> Vertex::getAttributeDescriptions( void ) {
    
    std::array<vk::VertexInputAttributeDescription, 3> attributeDescriptions
    {
        vk::VertexInputAttributeDescription(0, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, pos)),
        vk::VertexInputAttributeDescription(1, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, color)),
        vk::VertexInputAttributeDescription(2, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, texCoord))
    };

    return attributeDescriptions;
}

const std::vector<Vertex> cube_vertices = {
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 1.0f}}
};

const std::vector<uint32_t> cube_indices = {
    0, 1, 2, 0, 2, 3,
    4, 5, 6, 4, 6, 7,
    8, 9, 10, 8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23
};

struct UniformBufferObject {
    alignas(16) glm::mat4 model;
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
};

namespace VulkanLoader {

#ifdef _DEBUG
const bool debug_true = true;
#else
const bool debug_true = false;
#endif


class CException 
    : public std::runtime_error 
{
public:

    explicit CException( const char *what ) : std::runtime_error( what ) {}
    explicit CException( const std::string &what ) : std::runtime_error( what ) {}
};


/******************************************************************//**
* \brief   Vulkan application object.
*
* The setup of the Vulkan application follows widely the official
* Vulkan tutorial.
* [https://vulkan-tutorial.com/Introduction]
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
class CAppliction 
{
public: // public operations
    
    CAppliction( bool verbose );
    virtual ~CAppliction();

    bool Verbose( void ) const { return _verbose; }

    void scene(bool load_model)
    {
        _load_model = load_model;
    }

    void layers( 
        const std::vector<std::string> &layerNames,         //!< explicit names of validation layer which should be added
        bool                            all_layers,         //!< enable all existing validation layers
        const std::vector<std::string> &excludeLayerNames ) //!< exclude this validations layers in any case
    { 
      _requestedValidationLayers = layerNames;
      _enableAllValidationLayers = all_layers;
      _excludedValidationLayers  = excludeLayerNames;
    }

    void settings(bool enable_depth_test, bool enable_face_culling)
    {
        _enable_depth_test   = enable_depth_test;
        _enable_face_culling = enable_face_culling;
    }

    void extensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            surface_extensions,   //!< automatically add surface extensions 
        bool                            validation_warnings,  //!< add validation warnings 
        bool                            debug_extensions,     //!< automatically add debug extensions 
        bool                            debug_information)    //!< automatically enable additional debug information
    { 
        _requestedExtensions      = extensions;
        _enableSurfaceExtensions  = surface_extensions;
        _enableValidationWarnings = validation_warnings;
        _enableDebugExtensions    = debug_extensions;
        _enableDebugInformation   = debug_information;

        // add surface extension to the requested extensions
        const std::string surface_ext_name = "VK_KHR_surface";
        if ( _enableSurfaceExtensions ) {
            if ( std::find( _requestedExtensions.begin(), _requestedExtensions.end(), surface_ext_name.c_str() ) == _requestedExtensions.end() )
                _requestedExtensions.push_back( surface_ext_name.c_str() );
            // "VK_KHR_win32_surface" ???
        }
    }

     void deviceExtensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            swapchain_extensions) //!< automatically add swapchain extensions 
    { 
        _requestedDeviceExtensions = extensions;
        _enableSwapchainExtension  = swapchain_extensions;

        // add swapchain device extension  to requested device extensions
        const std::string swapchain_ext_name = "VK_KHR_swapchain";
        if ( _enableSwapchainExtension ) {
            if ( std::find( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), swapchain_ext_name.c_str() ) == _requestedDeviceExtensions.end() )
              _requestedDeviceExtensions.push_back( swapchain_ext_name.c_str() );
        }
    }

    void run( void ); //!< Run Vulkan application

private: // private operations

    void initWindow( void );              //!< Initialize GLFW and create GLFW window
    void initVulkan( void );              //!< Set up Vulkan
    void mainLoop( void );                //!< Event loop
    void cleanup( void );                 //!< Cleanup GLFW
    void resize( int width, int height ); //!< Resize notification
    
    void recreateSwapChain( void );                  //!< recreate the entire swapchain (e.g. when the window was resized)
    void createSwapChain( bool initilaize );         //!< create the entire swapchain (e.g. when the window was resized)
    void cleanupSwapChain( void );                   //!< cleanup everything which will be recreated till swapchain is recreated
    void loadModel(void);                            //!< load scene
    void loadTexture(const std::string &file_name);  //!< load texture
    void updateUniformBuffer( uint32_t imageIndex ); //!< update the uniform buffer for the current image

    void drawFrame( void ); //! do the drawing

    static void framebufferResizeCallback( GLFWwindow* window, int width, int height );

private: // private attributes

    bool                     _verbose                   = false; //!< flag which controls log messages
    bool                     _enableAllValidationLayers = false; //!< flag which controls the usage of validation layers
    bool                     _enableValidationWarnings  = false; //!< flag which controls warning information
    bool                     _enableSurfaceExtensions   = false; //!< flag which controls automatically enabling of surface extensions
    bool                     _enableDebugExtensions     = false; //!< flag which controls automatically enabling of debug extensions
    bool                     _enableDebugInformation    = false; //!< flag which controls additional debug information
    bool                     _enableSwapchainExtension  = false; //!< flag which controls automatically enabling of swapchain device extensions
    bool                     _enable_depth_test         = false; //!< flag which controls the depth test
    bool                     _enable_face_culling       = false; //!< flag which controls the face culling
    bool                     _load_model                = false; //!< flag which controls loading of obj model
    std::vector<std::string> _requestedValidationLayers;         //!< list of requested validation layers
    std::vector<std::string> _excludedValidationLayers;          //!< list of excluded validation layers
    std::vector<std::string> _requestedExtensions;               //!< list of requested extensions, "VK_EXT_debug_report" is automatically added if any validation layer is requested
    std::vector<std::string> _requestedDeviceExtensions;         //!< list of requested device extensions

    GLFWwindow                          *_wnd = nullptr;         //!< GLFW window

    std::vector<Vertex>                  _vertices;              //!< model vertices
    std::vector<uint32_t>                _indices;               //!< model indices

    vk_utility::core::DebugPtr _debubCallback;
    
    size_t                  _currentFrame = 0;                          //!< current frame semaphore index
    bool                    _framebufferResized = false;                //!< state which indicates that the widow has been resized

    vk_utility::core::InstancePtr                                     _instance;                   // Vulkan instance handle
    vk_utility::device::SurfacePtr                                    _surface;                    // Vulkan surface handle
    vk_utility::device::PhysicalDevicePtr                             _physical_device;
    vk_utility::device::DevicePtr                                     _device;                     // Vulkan logical device handle 
    vk::Queue                      _graphicsQueue;            //!< Vulkan graphics queue handle 
    vk::Queue                      _presentQueue;             //!< Vulkan presentation queue handle 
    vk_utility::swap::SwapchainPtr                                    _swapchain;                  // Vulkan swap chain handle 
    std::vector<vk_utility::image::ImageViewPtr>                      _swapchain_image_views;      // Vulkan swap chain image handles
    vk_utility::core::RenderPassPtr                                   _render_pass;                // Vulkan render pass handle
    vk_utility::core::DescriptorSetLayoutPtr                          _descriptor_set_layout;      // Vulkan descriptor set layout
    vk_utility::core::DescriptorPoolPtr                               _descriptor_pool;            // Vulkan descriptor set pool
    std::vector<vk::DescriptorSet>                                    _descriptor_sets;            // Vulkan descriptor sets
    vk_utility::pipeline::PipelineLayoutPtr                           _pipeline_layout;            // Vulkan pipeline layout handle
    vk_utility::pipeline::PipelinePtr                                 _graphics_pipeline;          // Vulkan graphics pipeline handle
    std::vector<vk_utility::buffer::FramebufferPtr>                   _swapchain_framebuffers;     // Vulkan framebuffers
    vk_utility::command::CommandPoolPtr                               _command_pool;               // Vulkan command pool
    vk_utility::command::CommandBuffersPtr                            _command_buffers;            // Vulkan command buffers
    std::vector<vk_utility::core::SemaphorePtr>                       _image_available_semaphores; // Vulkan semaphore
    std::vector<vk_utility::core::SemaphorePtr>                       _render_finished_semaphores; // Vulkan semaphore
    std::vector<vk_utility::core::FencePtr>                           _in_flight_fences;           // Vulkan fence
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>               _vertex_buffers;             // Vulkan vertex buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>               _index_buffers;              // Vulkan index buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr>               _uniform_buffers;            // Vulkan uniform buffer
    std::vector<vk_utility::image::ImageViewAndImageMemoryPtr>        _depth_image_view_memorys;   // Vulkan depth image view memory
    std::vector<vk_utility::image::ImageViewAndImageMemoryPtr>        _color_image_view_memorys;   // Vulkan color image view memory
    std::vector<vk_utility::image::SamplerAndImageViewImageMemoryPtr> _texture_samplers;           // Vulkan texture sampler
};


CAppliction::CAppliction( 
  bool verbose ) //!< control of log messages
  : _verbose( verbose )
{}


CAppliction::~CAppliction()
{}


void CAppliction::run( void ) 
{     
    if ( _requestedValidationLayers.empty() && _enableAllValidationLayers == false )
        _enableAllValidationLayers = debug_true;

    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}


void CAppliction::initWindow( void ) 
{
    //! glfwInit() initializes the GLFW library. 
    if ( glfwInit() == GLFW_FALSE )
        throw CException( "error initializing GLFW" ); 

    //! Because GLFW was originally designed to create an OpenGL context,
    //! we need to tell it to not create an OpenGL context with a subsequent call:
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        
    //! Because handling resized windows takes special care that we'll look into later,
    //! disable it for now with another window hint call:
    //glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    //! The first three parameters specify the width, height and title of the window.
    //! The fourth parameter allows you to optionally specify a monitor to open the window on
    //! and the last parameter is only relevant to OpenGL.
    _wnd = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan window", nullptr, nullptr);
    if ( _wnd == nullptr )
        throw CException( "error initializing window" ); 

    //! window pointer for callbacks
    glfwSetWindowUserPointer(_wnd, this);

    //! resize call back 
    glfwSetFramebufferSizeCallback(_wnd, framebufferResizeCallback);
}


void CAppliction::loadTexture(const std::string& file_name)
{
    int tex_width, tex_height, tex_channels;
    stbi_uc* pixels = stbi_load(file_name.c_str(), &tex_width, &tex_height, &tex_channels, STBI_rgb_alpha);

    if (!pixels)
        throw CException("failed to load texture image!");

    auto single_time_command_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);

    _texture_samplers.emplace_back(vk_utility::image::SamplerAndImageViewImageMemory::NewPtr(
        *_device,
        *_command_pool,
        vk_utility::image::TextureFactoryDefault()
            .set_command_buffer_factory(&single_time_command_factory)
            .set_source_data(static_cast<uint32_t>(tex_width), static_cast<uint32_t>(tex_height), pixels)
            .set_physical_device(_physical_device)
            .set_graphics_queue(_graphicsQueue)));

    stbi_image_free(pixels);
}


void CAppliction::loadModel(void)
{
    if (_load_model == false)
    {
        _vertices = cube_vertices;
        _indices = cube_indices;
        return;
    }

    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string warn, err;

    if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, MODEL_PATH.c_str())) {
        throw std::runtime_error(warn + err);
    }

    std::unordered_map<Vertex, uint32_t> uniqueVertices{};

    for (const auto& shape : shapes) {
        for (const auto& index : shape.mesh.indices) {
            Vertex vertex{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = { 5.0f, 5.0f, 5.0f };

            if (uniqueVertices.count(vertex) == 0) {
                uniqueVertices[vertex] = static_cast<uint32_t>(_vertices.size());
                _vertices.push_back(vertex);
            }

            _indices.push_back(uniqueVertices[vertex]);
        }
    }

    auto single_time_command_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);

    _vertex_buffers.push_back(vk_utility::buffer::BufferAndMemory::NewPtr(
        *_device,
        vk_utility::buffer::BufferAndMemoryFactoryDefault()
        .set_buffer_factory(
            &vk_utility::buffer::BufferFactoryDefault()
            .set_buffer_size(sizeof(_vertices[0]) * _vertices.size())
            .set_vertex_buffer_usage())
        .set_buffer_memory_factory(
            &vk_utility::buffer::BufferDeviceMemoryFactory()
            .set_from_physical_device(*_device->get().physical_device()))));

    vk_utility::buffer::CopyDataToBufferStagingCommand()
        .set_command_buffer_factory(&single_time_command_factory)
        .set_physical_device(_physical_device)
        .set_source_data(sizeof(_vertices[0]) * _vertices.size(), _vertices.data())
        .set_destination_buffer(_vertex_buffers.back()->get().buffer())
        .execute_command(*_device, *_command_pool);

    _index_buffers.push_back(vk_utility::buffer::BufferAndMemory::NewPtr(
        *_device,
        vk_utility::buffer::BufferAndMemoryFactoryDefault()
        .set_buffer_factory(
            &vk_utility::buffer::BufferFactoryDefault()
            .set_buffer_size(sizeof(_indices[0]) * _indices.size())
            .set_index_buffer_usage())
        .set_buffer_memory_factory(
            &vk_utility::buffer::BufferDeviceMemoryFactory()
            .set_from_physical_device(*_device->get().physical_device()))));

    vk_utility::buffer::CopyDataToBufferStagingCommand()
        .set_command_buffer_factory(&single_time_command_factory)
        .set_physical_device(_physical_device)
        .set_source_data(sizeof(_indices[0]) * _indices.size(), _indices.data())
        .set_destination_buffer(_index_buffers.back()->get().buffer())
        .execute_command(*_device, *_command_pool);
}


void CAppliction::initVulkan( void )
{
    vk_utility::logging::Log log;

    //vk_utility::Init();


#if VK_UTILITY_DYNAMIC_LOADING == 1
    vk::DynamicLoader dl;
    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = dl.getProcAddress<PFN_vkGetInstanceProcAddr>("vkGetInstanceProcAddr");

    VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);
#endif

    if (Verbose())
         vk_utility::logging::LogList(log).log("GLFW extensions supported", vk_glfw_utility::core::Extensions().get_names());

    _instance = vk_utility::core::Instance::New(
        vk_utility::core::InstanceFactoryDefault()
            .verbose(Verbose())
            .title("Vulkan tutorial - utility")
            .validation_layers(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers)
            .extensions(_requestedExtensions, _enableDebugExtensions));

    _debubCallback = vk_utility::core::Debug::New(_instance, _enableDebugInformation, _enableValidationWarnings);

    _surface = vk_glfw_utility::device::SurfaceFactory(_wnd).New(_instance);

    if (Verbose())
      vk_utility::logging::LogList(log).log("physical device extensions are requested", _requestedDeviceExtensions);
    
    _physical_device = vk_utility::device::PhysicalDeviceSelctor::New()
        .rater(vk_utility::device::PhysicalDeviceRateDefault::New(_requestedDeviceExtensions, _enableSwapchainExtension))
        .verbose(Verbose())
        .select(_instance, _surface);

    vk_utility::core::ValidationLayers validation_layers;
    auto selected_validation_layers = validation_layers.select(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers);
    _device = vk_utility::device::DeviceFactoryDefault()
        .set_requested_device_extensions(_requestedDeviceExtensions)
        .set_requested_validation_layers(selected_validation_layers)
        .New(_physical_device);

    _graphicsQueue = _device->get().get_first_graphics_queue(); // TODO [...] vk_utility::Queue 
    _presentQueue = _device->get().get_first_graphics_queue();  // TODO [...] vk_utility::Queue 

    _descriptor_set_layout = vk_utility::core::DescriptorSetLayout::NewPtr(
        *_device,
        vk_utility::core::DescriptorSetLayoutFactoryDefault());

    createSwapChain(true);

    const int MAX_FRAMES_IN_FLIGHT = 2;
    auto semaphore_factory = vk_utility::core::SemaphoreFactoryDefault();
    auto fence_factory = vk_utility::core::FenceFactoryDefault();
    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++)
    {
        _image_available_semaphores.push_back(vk_utility::core::Semaphore::NewPtr(*_device, vk_utility::core::SemaphoreFactoryDefault()));
        _render_finished_semaphores.push_back(vk_utility::core::Semaphore::NewPtr(*_device, vk_utility::core::SemaphoreFactoryDefault()));
        _in_flight_fences.push_back(vk_utility::core::Fence::NewPtr(*_device, vk_utility::core::FenceFactoryDefault()));
    }
}


void CAppliction::mainLoop( void ) 
{
    //! To keep the application running until either an error occurs or the window is closed, we need to add an event loop 
    while (!glfwWindowShouldClose(_wnd)) {
        glfwPollEvents();

        drawFrame();

        //! we should wait for the logical device to finish operations before exiting mainLoop and destroying the window:
        _device->get()->waitIdle();

        //glfwWaitEvents();
    }
}


void CAppliction::cleanup( void ) 
{
    cleanupSwapChain();

    _descriptor_set_layout = nullptr;
    _texture_samplers.clear();
    _index_buffers.clear();
    _vertex_buffers.clear();
    _in_flight_fences.clear();
    _render_finished_semaphores.clear();
    _image_available_semaphores.clear();
    _command_pool = nullptr;
    _device = nullptr;
    _physical_device = nullptr;
    _surface = nullptr;
    _debubCallback = nullptr;
    _instance = nullptr;

    //! Once the window is closed, we need to clean up resources by destroying it and terminating GLFW itself. 
    glfwDestroyWindow(_wnd);
    _wnd = nullptr;
    glfwTerminate();
}


void CAppliction::framebufferResizeCallback( 
    GLFWwindow* window, //!< GLFW window handle (pointer)
    int         width,  //!< new width of the window
    int         height  //!< new height of the window
    ) 
{
    if ( window == nullptr )
        return;
    CAppliction *appPtr = (CAppliction*)glfwGetWindowUserPointer( window );
    if ( appPtr == nullptr )
        return;

    appPtr->resize( width, height );
}


void CAppliction::resize( 
    int width, //!< new width of the window
    int height //!< new height of the window
    ) 
{
  _framebufferResized = true;
}


void CAppliction::recreateSwapChain( void ) 
{    
    if ( !_device )
        return;

    //! We first call `vkDeviceWaitIdle`, because just like in the last chapter, we shouldn't touch resources that may still be in use.
    //! Obviously, the first thing we'll have to do is recreate the swap chain itself.
    //! The image views need to be recreated because they are based directly on the swap chain images.
    // !The render pass needs to be recreated because it depends on the format of the swap chain images.
    // !It is rare for the swap chain image format to change during an operation like a window resize, but it should still be handled.
    // !Viewport and scissor rectangle size is specified during graphics pipeline creation, so the pipeline also needs to be rebuilt.
    // !It is possible to avoid this by using dynamic state for the viewports and scissor rectangles.
    //! Finally, the framebuffers and command buffers also directly depend on the swap chain images.

    _device->get()->waitIdle();

    // pause till the window is minimized
    int width = 0, height = 0;
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(_wnd, &width, &height);
        glfwWaitEvents();
    }

    //pickPhysicalDevice();
    // update swap chain information
    _physical_device->get().evaluate_swapchain_support(*_surface);
    
    cleanupSwapChain();
    createSwapChain(false);
}


void CAppliction::createSwapChain(bool initilaize)
{
    auto single_time_command_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);

    vk::Format depthFormat = vk_utility::core::FormatSelector()
        .set_tiling(vk::ImageTiling::eOptimal)
        .set_feataures(vk::FormatFeatureFlagBits::eDepthStencilAttachment)
        .find_supported_format(*_physical_device, { vk::Format::eD32Sfloat, vk::Format::eD32SfloatS8Uint, vk::Format::eD24UnormS8Uint });

    _swapchain = vk_utility::swap::SwapchainFactoryDefault()
        .set_format_selector(std::make_shared<vk_utility::swap::SwapSurfaceFormatSelectorDefault>())
        .set_present_mode_selector(std::make_shared<vk_utility::swap::SwapPresentModeSelectorDefault>())
        .set_extent_selector(std::make_shared<vk_glfw_utility::swap::SwapExtentSelector>(_wnd))
        .New(_device, _surface);

    _swapchain_image_views = vk_utility::image::ImageView::NewPtrVector(
        *_device,
        vk_utility::image::SwapchainImageViewFactoryDefault()
            .set_swapchain(_swapchain));

    _render_pass = vk_utility::core::RenderPassFactoryDefault()
        .set_color_format(_swapchain->get().image_format())
        .set_depth_format(depthFormat)
        .set_sampple_count(_physical_device->get().get_max_usable_sample_count())
        .New(_device);

    _pipeline_layout = vk_utility::pipeline::PipelineLayout::New(_device, _descriptor_set_layout);

    auto vert_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_vert.spv")
        .New(_device);
    auto frag_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_frag.spv")
        .New(_device);
    auto bindingDescription = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    _graphics_pipeline = vk_utility::pipeline::PipelienFactoryDefault()
        .add_shader_module(vert_shader_module, vk::ShaderStageFlagBits::eVertex)
        .add_shader_module(frag_shader_module, vk::ShaderStageFlagBits::eFragment)
        .add_vertex_binding_description(bindingDescription)
        .add_attribute_descriptions(std::vector<vk::VertexInputAttributeDescription>(attributeDescriptions.begin(), attributeDescriptions.end()))
        .enable_face_culling(_enable_face_culling)
        .set_pipeline_layout(_pipeline_layout)
        .set_render_pass(_render_pass)
        .New(_device, _swapchain);

    _command_pool = vk_utility::command::CommandPool::NewPtr(
        _device->get(),
        vk_utility::command::CommandPoolFactoryDefault()
        .set_device_queue_information(_physical_device->get().get_queue_information_ptr()));

    vk::Format colorFormat = _swapchain->get().image_format();
    _color_image_view_memorys.emplace_back(
        vk_utility::image::ImageViewAndImageMemory::NewPtr(
            *_device,
            vk_utility::image::ImageViewAndImageMemoryFactoryDefault()
            .set_image_and_memory_factory(&vk_utility::image::ImageAndMemoryFactoryDefault()
                .set_image_factory(&vk_utility::image::ImageFactory2D()
                    .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
                    .set_format(colorFormat)
                    .set_mipmap_levels(1)
                    .set_samples(_physical_device->get().get_max_usable_sample_count())
                    .set_usage(vk::ImageUsageFlagBits::eTransientAttachment | vk::ImageUsageFlagBits::eColorAttachment))
                .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
                    .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
                    .set_from_physical_device(_device->get().physical_device())))
            .set_image_view_factory(&vk_utility::image::ImageViewFactoryDefault()
                .set_format(colorFormat)
                .set_aspect_flags(vk::ImageAspectFlagBits::eColor)
                .set_mipmap_levels(1))));

    _depth_image_view_memorys.emplace_back(
        vk_utility::image::ImageViewAndImageMemory::NewPtr(
            *_device,
            vk_utility::image::ImageViewAndImageMemoryFactoryDefault()
            .set_image_and_memory_factory(&vk_utility::image::ImageAndMemoryFactoryDefault()
                .set_image_factory(&vk_utility::image::ImageFactory2D()
                    .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
                    .set_format(depthFormat)
                    .set_mipmap_levels(1)
                    .set_samples(_physical_device->get().get_max_usable_sample_count())
                    .set_usage(vk::ImageUsageFlagBits::eDepthStencilAttachment))
                .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
                    .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
                    .set_from_physical_device(_device->get().physical_device())))
            .set_image_view_factory(&vk_utility::image::ImageViewFactoryDefault()
                .set_format(depthFormat)
                .set_aspect_flags(vk::ImageAspectFlagBits::eDepth)
                .set_mipmap_levels(1))));
    
    _swapchain_framebuffers = vk_utility::buffer::Framebuffer::NewPtrVector(
        *_device,
        vk_utility::buffer::SwapchainFramebufferFactoryDefault()
            .set_swapchain(_swapchain)
            .set_swapchain_image_views(_swapchain_image_views)
            .set_color_image_view(_color_image_view_memorys.front())
            .set_depth_image_view(_depth_image_view_memorys.front())
            .set_render_pass(_render_pass));

    if (initilaize)
    {
        loadTexture(_load_model ? TEXTURE_PATH : "../../../_data/wood.png");
        loadModel();
    }

    // We're going to copy new data to the uniform buffer every frame, so it doesn't really make any sense to have a staging buffer.
    // It would just add extra overhead in this case and likely degrade performance instead of improving it.

    // We should have multiple buffers, because multiple frames may be in flight at the same time and
    // we don't want to update the buffer in preparation of the next frame while a previous one is still reading from it!
    // We could either have a uniform buffer per frame or per swap chain image.
    // However, since we need to refer to the uniform buffer from the command buffer that we have per swap chain image,
    // it makes the most sense to also have a uniform buffer per swap chain image.

    vk::DeviceSize bufferSize = sizeof(UniformBufferObject);
    for (size_t i = 0; i < _swapchain->get().no_of_swapchain_images(); i++)
    {
        _uniform_buffers.push_back(vk_utility::buffer::BufferAndMemory::NewPtr(
            *_device, 
            vk_utility::buffer::BufferAndMemoryFactoryDefault()
                .set_buffer_factory(
                    &vk_utility::buffer::BufferFactoryDefault()
                        .set_buffer_size(bufferSize)
                        .set_coherent_uniform_buffer_usage())
                .set_buffer_memory_factory(
                    &vk_utility::buffer::BufferDeviceMemoryFactory()
                        .set_coherent_memory_properties()
                        .set_from_physical_device(_device->get().physical_device()))));
    }

    _descriptor_pool = vk_utility::core::DescriptorPool::NewPtr(
        *_device,
        vk_utility::core::DescriptorPoolFactoryDefault()
        .set_no_of_swapchain_images(_swapchain->get().no_of_swapchain_images()));

    _descriptor_sets = vk_utility::core::DescriptorSetsFactoryDefault()
        .set_no_of_swapchain_images(_swapchain->get().no_of_swapchain_images())
        .set_descriptor_set_layout(*_descriptor_set_layout)
        .set_descriptor_pool(*_descriptor_pool)
        .set_uniform_buffers(&_uniform_buffers, sizeof(UniformBufferObject))
        .set_texture_samplers(&_texture_samplers)
        .New(*_device);

    vk::IndexType index_type = sizeof(*_indices.data()) == 4 ? vk::IndexType::eUint32 : (sizeof(*_indices.data()) == 2 ? vk::IndexType::eUint16 : vk::IndexType::eUint8EXT);
    _command_buffers = vk_utility::command::CommandBuffers::NewPtr(
        *_device,
        *_command_pool,
        vk_utility::command::CommandBuffersFactoryDefault()
            .set_swapchain_framebuffers(&_swapchain_framebuffers)
            .set_render_pass(*_render_pass)
            .set_image_size(_swapchain->get().image_extent_2D())
            .set_graphics_pipeline(*_graphics_pipeline)
            .set_pipeline_layout(*_pipeline_layout)
            .set_descriptor_sets(&_descriptor_sets)
            .set_vertex_buffer(_vertex_buffers.back()->get().buffer())
            .set_index_buffer(_index_buffers.back()->get().buffer(), index_type, static_cast<uint32_t>(_indices.size())));
}


/******************************************************************//**
* \brief Cleanup everything which will be recreated till swapchain
* is recreated.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::cleanupSwapChain( void ) {

    _depth_image_view_memorys.clear();
    _color_image_view_memorys.clear();
    _uniform_buffers.clear();
    _descriptor_pool = nullptr,
    //! You don't need to explicitly clean up descriptor sets, because they will be automatically freed when the descriptor pool is destroyed.
    _descriptor_sets.clear();
    _swapchain_framebuffers.clear();
    _command_buffers = nullptr;
    _graphics_pipeline = nullptr;
    _pipeline_layout = nullptr;
    _render_pass = nullptr;
    _swapchain_image_views.clear();
    _swapchain = nullptr;
}


/******************************************************************//**
* \brief   do the drawing
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::drawFrame( void )
{
    //! The `vkWaitForFences` function takes an array of fences and waits for either any or all of them to be signaled before returning.
    //! The `VK_TRUE` we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter.
    //! Just like `vkAcquireNextImageKHR` this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the vkResetFences call.

    std::vector<vk::Fence> fences{ *_in_flight_fences[_currentFrame] };
    auto result = _device->get()->waitForFences(fences, VK_TRUE, std::numeric_limits<uint64_t>::max());

    //-------------------------------------------
    // Acquiring an image from the swap chain
    //-------------------------------------------

    //! The first two parameters of `vkAcquireNextImageKHR` are the logical device and the swap chain from which we wish to acquire an image.
    //! The third parameter specifies a timeout in nanoseconds for an image to become available.
    //! Using the maximum value of a 64 bit unsigned integer disables the timeout.

    //! The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image.
    //! That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both.
    //! We're going to use our imageAvailableSemaphore for that purpose here.

    //! The last parameter specifies a variable to output the index of the swap chain image that has become available.
    //! The index refers to the `vk::Image` in our swapChainImages array.

    uint32_t imageIndex;
    vk::Result acquireNextImageResult;
    result = _device->get()->acquireNextImageKHR(*_swapchain, std::numeric_limits<uint64_t>::max(), *_image_available_semaphores[_currentFrame], vk::Fence(), &imageIndex);
    acquireNextImageResult = result;
    
    if (acquireNextImageResult == vk::Result::eErrorOutOfDateKHR || acquireNextImageResult == vk::Result::eSuboptimalKHR || _framebufferResized) {
        _framebufferResized = false;
        recreateSwapChain();
        return;
    } 

    result = _device->get()->resetFences(1, &fences[0]);


    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------
    
    updateUniformBuffer(imageIndex);

    //-------------------------------------------
    // Submitting the command buffer
    //-------------------------------------------
    
    //! The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
    //! We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment.
    //! That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. 
    //! Each entry in the waitStages array corresponds to the semaphore with the same index in pWaitSemaphores.

    //! The next two parameters specify which command buffers to actually submit for execution.
    //! As mentioned earlier, we should submit the command buffer that binds the swap chain image we just acquired as color attachment.

    //! The signalSemaphoreCount and pSignalSemaphores parameters specify which semaphores to signal once the command buffer(s) have finished execution.
    //! In our case we're using the renderFinishedSemaphore for that purpose.

    std::vector<vk::Semaphore> waitSemaphores{*_image_available_semaphores[_currentFrame]};
    std::vector<vk::Semaphore> signalSemaphores{*_render_finished_semaphores[_currentFrame]};
    std::vector<vk::PipelineStageFlags> waitStages{vk::PipelineStageFlagBits::eColorAttachmentOutput};
    std::vector<vk::CommandBuffer> commandbuffers{_command_buffers->handle()[imageIndex]};

    vk::SubmitInfo submitInfo(waitSemaphores, waitStages, commandbuffers, signalSemaphores);

    result = _graphicsQueue.submit(1, &submitInfo, *_in_flight_fences[_currentFrame]);
 
    //-------------------------------------------
    // Presentation
    //-------------------------------------------
    
    //! The next two parameters specify the swap chains to present images to and the index of the image for each swap chain.
    //! This will almost always be a single one.

    //! There is one last optional parameter called pResults.
    //! It allows you to specify an array of `vk::Result` values to check for every individual swap chain if presentation was successful. 
    //! It's not necessary if you're only using a single swap chain, because you can simply use the return value of the present function.

    std::vector<vk::SwapchainKHR> swapChains{_swapchain->handle()};
    std::vector<uint32_t> imageIndexs{imageIndex};
    std::vector<vk::Result> resutl;

    vk::PresentInfoKHR presentInfo(signalSemaphores, swapChains, imageIndexs, resutl);

    result = _presentQueue.presentKHR(presentInfo);

    //-------------------------------------------
    // Frames in flight
    //-------------------------------------------
    
    //! If you run your application with validation layers enabled and you monitor the memory usage of your application, you may notice that it is slowly growing.
    //! The reason for this is that the application is rapidly submitting work in the drawFrame function, but doesn't actually check if any of it finishes.
    //! If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work.
    //! Worse, even, is that we are reusing the imageAvailableSemaphore and renderFinishedSemaphore for multiple frames at the same time.

    //! The easy way to solve this is to wait for work to finish right after submitting it, for example by using vkQueueWaitIdle.
    //! However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now.
    //! The stages that the current frame has already progressed through are idle and could already be used for a next frame.

    //vkQueuePresentKHR(_presentQueue, &presentInfo);
    //vkQueueWaitIdle(_presentQueue);


    _currentFrame = (_currentFrame + 1) % _image_available_semaphores.size();
}


/******************************************************************//**
* \brief   update the uniform buffer for the current image
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::updateUniformBuffer( uint32_t imageIndex )
{
    if ( !_device )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------

    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    UniformBufferObject ubo = {};
    ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = glm::perspective(glm::radians(45.0f), _swapchain->get().image_width_2D() / (float) _swapchain->get().image_height_2D(), 0.1f, 10.0f);

    // GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
    // The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the projection matrix.
    // If you don't do this, then the image will be rendered upside down.
    ubo.proj[1][1] *= -1;

    _uniform_buffers[imageIndex]->get().memory().copy(&ubo);
}


} // VulkanLoader


using HelloTriangleApplication = VulkanLoader::CAppliction;


int main() 
{    
    static bool verbose                      = true;
    static bool enable_all_validation_layers = false;
    static bool enable_surface_extensions    = true;
    static bool enable_swapchain_extensions  = true;
    static bool enable_validation_warnings   = true;
    static bool enable_debug_extensions      = true;
    static bool enable_debug_information     = false;
    static bool enable_depth_test            = true;
    static bool enable_face_culling          = false;
    static bool load_model                   = true;
    
    HelloTriangleApplication app( verbose );

    const std::vector<std::string> validationLayers = {
        //"VK_LAYER_LUNARG_api_dump",
        "VK_LAYER_KHRONOS_validation",
        "VK_LAYER_LUNARG_monitor",
        "VK_LAYER_LUNARG_screenshot",
        "VK_LAYER_NV_optimus"
    };
    const std::vector<std::string> excludeValidationLayers = {
        "VK_LAYER_LUNARG_device_simulation",
        "VK_LAYER_LUNARG_vktrace",
        "VK_LAYER_RENDERDOC_Capture" //!< causes instance creation fail; why?
    };

    app.scene(load_model);
    app.layers(validationLayers, enable_all_validation_layers, excludeValidationLayers);
    app.settings(enable_depth_test, enable_face_culling);

    const std::vector<std::string> extensions = {
        "VK_KHR_win32_surface", // seems to be strongly required for win32 application (at least for GLFW)
    };
    app.extensions( 
      extensions,
      enable_surface_extensions,
      enable_validation_warnings,
      enable_debug_extensions,
      enable_debug_information );

    const std::vector<std::string> device_extensions = {};
    app.deviceExtensions( 
      device_extensions,
      enable_swapchain_extensions );

    bool exit_success = true;
    try {
        app.run();
    } catch (const std::runtime_error& e) {
        std::cerr << e.what() << std::endl;
        exit_success = false;
    }

    return exit_success ? EXIT_SUCCESS : EXIT_FAILURE;
}