#include <stdafx.h>


// Vulkan

//! Vulkan is included by GLFW library
//#include <vulkan/vulkan.h>


// GLM

#define GLM_ENABLE_EXPERIMENTAL

#define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/hash.hpp>


// STB

#define STB_IMAGE_IMPLEMENTATION
//#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>


// TINYOBJLOADER

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>


// Vulkan

#include <vk_utility_vulkan_include.h>
#include <vk_utility_parameter_helper.h>
#include <vk_utility_validation_layers.h>
#include <vk_utility_extensions.h>
#include <vk_utility_instance.h>
#include <vk_utility_instance_factory.h>
#include <vk_utility_debug.h>
#include <vk_utility_surface.h>
#include <vk_utility_physical_device.h>
#include <vk_utility_physical_device_extensions.h>
#include <vk_utility_physical_device_rate_default.h>
#include <vk_utility_device.h>
#include <vk_utility_device_factory.h>
#include <vk_utility_device_factory_default.h>
#include <vk_utility_device_memory.h>
#include <vk_utility_buffer.h>
#include <vk_utility_buffer_and_memory.h>
#include <vk_utility_buffer_operator_copy_data_to_memory.h>
#include <vk_utility_buffer_operator_copy_data_staging.h>
#include <vk_utility_buffer_operator_copy_buffer.h>
#include <vk_utility_logging.h>
#include <vk_utility_logging_physical_device.h>
#include <vk_utility_render_pass.h>
#include <vk_utility_render_pass_factory.h>
#include <vk_utility_render_pass_factory_default.h>
#include <vk_utility_descriptor_set_layout.h>
#include <vk_utility_descriptor_set_layout_factory.h>
#include <vk_utility_descriptor_set_layout_factory_default.h>
#include <vk_utility_swap_surface_format_selector.h>
#include <vk_utility_swap_surface_fromat_selector_default.h>
#include <vk_utility_swap_present_mode_selector.h>
#include <vk_utility_swap_present_mode_selector_default.h>
#include <vk_utility_swap_extent_selector.h>
#include <vk_utility_swapchain.h>
#include <vk_utility_swapchain_factory.h>
#include <vk_utility_swapchain_factory_default.h>
#include <vk_utility_shader_module.h>
#include <vk_utility_shader_module_factory_spirv_file.h>
#include <vk_utility_shader_stage_create_information.h>
#include <vk_utility_pipeline.h>
#include <vk_utility_pipeline_layout.h>
#include <vk_utility_pipeline_factory_default.h>
#include <vk_utility_image_view.h>
#include <vk_utility_image_view_memory.h>
#include <vk_utility_image_view_factory_default.h>
#include <vk_utility_framebuffer.h>
#include <vk_utility_framebuffer_factory_default.h>
#include <vk_utility_command_pool.h>
#include <vk_utility_command_pool_factory_default.h>
#include <vk_utility_command_buffer.h>
#include <vk_utility_command_buffer_factory_single_time_command.h>
#include <vk_utility_image_factory_2d.h>
#include <vk_utility_image_device_memory_factory.h>
#include <vk_utility_image_and_memory.h>
#include <vk_utility_image_and_memory_factory_default.h>


// GLFW

#include <vk_glfw_utility_include.h>
#include <vk_glfw_utility_extensions.h>
#include <vk_glfw_utility_surface_factory.h>
#include <vk_glfw_utility_swap_extent_selector.h>


// STL

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <tuple>
#include <array>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <chrono>
#include <cmath>
#include <math.h>


const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;


const std::string MODEL_PATH = "../../../../../model/viking_room/viking_room.obj";
const std::string TEXTURE_PATH = "../../../../../model/viking_room/viking_room.png";



struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    bool operator==(const Vertex& other) const {
        return pos == other.pos && color == other.color && texCoord == other.texCoord;
    }

    static vk::VertexInputBindingDescription getBindingDescription( void );
    static std::array<vk::VertexInputAttributeDescription, 3> getAttributeDescriptions( void );
};


namespace std {
    template<> struct hash<Vertex> {
        size_t operator()(Vertex const& vertex) const {
            return ((hash<glm::vec3>()(vertex.pos) ^
                   (hash<glm::vec3>()(vertex.color) << 1)) >> 1) ^
                   (hash<glm::vec2>()(vertex.texCoord) << 1);
        }
    };
}


vk::VertexInputBindingDescription Vertex::getBindingDescription( void ) {
    
    vk::VertexInputBindingDescription bindingDescription(0, sizeof(Vertex), vk::VertexInputRate::eVertex);
    return bindingDescription;
}

std::array<vk::VertexInputAttributeDescription, 3> Vertex::getAttributeDescriptions( void ) {
    
    std::array<vk::VertexInputAttributeDescription, 3> attributeDescriptions
    {
        vk::VertexInputAttributeDescription(0, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, pos)),
        vk::VertexInputAttributeDescription(1, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, color)),
        vk::VertexInputAttributeDescription(2, 0, vk::Format::eR32G32B32Sfloat, offsetof(Vertex, texCoord))
    };

    return attributeDescriptions;
}

const std::vector<Vertex> cube_vertices = {
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 0.0f}},
    {{-1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {1.0f, 1.0f, 0.0f}, {1.0f, 1.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{-1.0f,  1.0f, -1.0f}, {1.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},
    {{ 1.0f,  1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 0.0f}},
    {{ 1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
    {{-1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 0.0f}},
    {{ 1.0f, -1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 0.0f}},
    {{ 1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {1.0f, 1.0f}},
    {{-1.0f,  1.0f,  1.0f}, {1.0f, 0.5f, 0.0f}, {0.0f, 1.0f}}
};

const std::vector<uint32_t> cube_indices = {
    0, 1, 2, 0, 2, 3,
    4, 5, 6, 4, 6, 7,
    8, 9, 10, 8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23
};

struct UniformBufferObject {
    alignas(16) glm::mat4 model;
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
};

namespace VulkanLoader {

#ifdef _DEBUG
const bool debug_true = true;
#else
const bool debug_true = false;
#endif


class CException 
    : public std::runtime_error 
{
public:

    explicit CException( const char *what ) : std::runtime_error( what ) {}
    explicit CException( const std::string &what ) : std::runtime_error( what ) {}
};


class CopyBufferHelper;


/******************************************************************//**
* \brief   Vulkan application object.
*
* The setup of the Vulkan application follows widely the official
* Vulkan tutorial.
* [https://vulkan-tutorial.com/Introduction]
* 
* \author  gernot
* \date    2018-05-10
* \version 1.0
**********************************************************************/
class CAppliction 
{
    friend class CopyBufferHelper;

public: // public operations
    
    CAppliction( bool verbose );
    virtual ~CAppliction();

    bool Verbose( void ) const { return _verbose; }

    void scene(bool load_model)
    {
        _load_model = load_model;
    }

    void layers( 
        const std::vector<std::string> &layerNames,         //!< explicit names of validation layer which should be added
        bool                            all_layers,         //!< enable all existing validation layers
        const std::vector<std::string> &excludeLayerNames ) //!< exclude this validations layers in any case
    { 
      _requestedValidationLayers = layerNames;
      _enableAllValidationLayers = all_layers;
      _excludedValidationLayers  = excludeLayerNames;
    }

    void settings(bool enable_depth_test, bool enable_face_culling)
    {
        _enable_depth_test   = enable_depth_test;
        _enable_face_culling = enable_face_culling;
    }

    void extensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            surface_extensions,   //!< automatically add surface extensions 
        bool                            validation_warnings,  //!< add validation warnings 
        bool                            debug_extensions,     //!< automatically add debug extensions 
        bool                            debug_information)    //!< automatically enable additional debug information
    { 
        _requestedExtensions      = extensions;
        _enableSurfaceExtensions  = surface_extensions;
        _enableValidationWarnings = validation_warnings;
        _enableDebugExtensions    = debug_extensions;
        _enableDebugInformation   = debug_information;

        // add surface extension to the requested extensions
        const std::string surface_ext_name = "VK_KHR_surface";
        if ( _enableSurfaceExtensions ) {
            if ( std::find( _requestedExtensions.begin(), _requestedExtensions.end(), surface_ext_name.c_str() ) == _requestedExtensions.end() )
                _requestedExtensions.push_back( surface_ext_name.c_str() );
            // "VK_KHR_win32_surface" ???
        }
    }

     void deviceExtensions( 
        const std::vector<std::string> &extensions,           //!< explicit names of validation layer which should be added
        bool                            swapchain_extensions) //!< automatically add swapchain extensions 
    { 
        _requestedDeviceExtensions = extensions;
        _enableSwapchainExtension  = swapchain_extensions;

        // add swapchain device extension  to requested device extensions
        const std::string swapchain_ext_name = "VK_KHR_swapchain";
        if ( _enableSwapchainExtension ) {
            if ( std::find( _requestedDeviceExtensions.begin(), _requestedDeviceExtensions.end(), swapchain_ext_name.c_str() ) == _requestedDeviceExtensions.end() )
              _requestedDeviceExtensions.push_back( swapchain_ext_name.c_str() );
        }
    }

    void run( void ); //!< Run Vulkan application

private: // private operations

    void initWindow( void );              //!< Initialize GLFW and create GLFW window
    void initVulkan( void );              //!< Set up Vulkan
    void mainLoop( void );                //!< Event loop
    void cleanup( void );                 //!< Cleanup GLFW
    void resize( int width, int height ); //!< Resize notification
    
    void recreateSwapChain( void );                  //!< recreate the entire swapchain (e.g. when the window was resized)
    void createSwapChain( bool initilaize );         //!< create the entire swapchain (e.g. when the window was resized)
    void cleanupSwapChain( void );                   //!< cleanup everything which will be recreated till swapchain is recreated
    void createColorResources(void);                 //!< create the color image
    void createDepthResources(void);                 //!< create the depth image
    void loadModel(void);                            //!< load scene
    void createTextureImage( void );                 //!< create texture image
    void createTextureImageView( void );             //!< create texture image view
    void createTextureSampler( void );               //!< create texture sampler
    void createDescriptorPool( void );               //!< create descriptor pool 
    void createDescriptorSets( void );               //!< create descriptor sets
    void createCommandBuffers( void );               //!< create command buffers
    void createSyncObjects( void );                  //!< create semaphores and fences
    void updateUniformBuffer( uint32_t imageIndex ); //!< update the uniform buffer for the current image

    void drawFrame( void ); //! do the drawing
                                                 //!< create shader module from byte code
    //! handle image layout transition
    void transitionImageLayout(vk::Image image, vk::Format format, vk::ImageLayout oldLayout, vk::ImageLayout newLayout, uint32_t mipLevels);
    //! copy buffer to image
    void copyBufferToImage( vk::Buffer buffer, vk::Image image, uint32_t width, uint32_t height );
    //! find supported format
    vk::Format findSupportedFormat(const std::vector<vk::Format> &candidates, vk::ImageTiling tiling, vk::FormatFeatureFlags features);
    //! find depth format
    vk::Format findDepthFormat();
    //! generate mipmaps
    void generateMipmaps(vk::Image image, vk::Format imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels);

    static void framebufferResizeCallback( GLFWwindow* window, int width, int height );

private: // private attributes

    bool                     _verbose                   = false; //!< flag which controls log messages
    bool                     _enableAllValidationLayers = false; //!< flag which controls the usage of validation layers
    bool                     _enableValidationWarnings  = false; //!< flag which controls warning information
    bool                     _enableSurfaceExtensions   = false; //!< flag which controls automatically enabling of surface extensions
    bool                     _enableDebugExtensions     = false; //!< flag which controls automatically enabling of debug extensions
    bool                     _enableDebugInformation    = false; //!< flag which controls additional debug information
    bool                     _enableSwapchainExtension  = false; //!< flag which controls automatically enabling of swapchain device extensions
    bool                     _enable_depth_test         = false; //!< flag which controls the depth test
    bool                     _enable_face_culling       = false; //!< flag which controls the face culling
    bool                     _load_model                = false; //!< flag which controls loading of obj model
    std::vector<std::string> _requestedValidationLayers;         //!< list of requested validation layers
    std::vector<std::string> _excludedValidationLayers;          //!< list of excluded validation layers
    std::vector<std::string> _requestedExtensions;               //!< list of requested extensions, "VK_EXT_debug_report" is automatically added if any validation layer is requested
    std::vector<std::string> _requestedDeviceExtensions;         //!< list of requested device extensions

    GLFWwindow                          *_wnd = nullptr;         //!< GLFW window

    std::vector<Vertex>                  _vertices;              //!< model vertices
    std::vector<uint32_t>                _indices;               //!< model indices

    vk_utility::core::DebugPtr _debubCallback;
    
    size_t                  _currentFrame = 0;                          //!< current frame semaphore index
    bool                    _framebufferResized = false;                //!< state which indicates that the widow has been resized

    vk_utility::core::InstancePtr                       _instance;                   //!< Vulkan instance handle
    vk_utility::device::SurfacePtr                      _surface;                    //!< Vulkan surface handle
    vk_utility::device::PhysicalDevicePtr               _physical_device;
    vk_utility::device::DevicePtr                       _device;                     //!< Vulkan logical device handle 
    vk::Queue                      _graphicsQueue;            //!< Vulkan graphics queue handle 
    vk::Queue                      _presentQueue;             //!< Vulkan presentation queue handle 
    vk_utility::swap::SwapchainPtr                      _swapchain;                  //!< Vulkan swap chain handle 
    std::vector<vk_utility::image::ImageViewPtr>        _swapchain_image_views;      //!< Vulkan swap chain image handles
    vk_utility::core::RenderPassPtr                     _render_pass;                //!< Vulkan render pass handle
    vk_utility::core::DescriptorSetLayoutPtr            _descriptor_set_layout;      //!< Vulkan descriptor set layout
    vk::DescriptorPool             _descriptorPool;           //!< Vulkan descriptor set pool
    std::vector<vk::DescriptorSet> _descriptorSets;           //!< Vulkan descriptor sets
    vk_utility::pipeline::PipelineLayoutPtr             _pipeline_layout;            //!< Vulkan pipeline layout handle
    vk_utility::pipeline::PipelinePtr                   _graphics_pipeline;          //!< Vulkan graphics pipeline handle
    std::vector<vk_utility::buffer::FramebufferPtr>     _swapchain_framebuffers;     //!< Vulkan framebuffers
    vk_utility::command::CommandPoolPtr                 _command_pool;               //!< Vulkan command pool
    std::vector<vk::CommandBuffer> _commandBuffers;           //!< Vulkan command buffers
    std::vector<vk::Semaphore>     _imageAvailableSemaphores; //!< Vulkan semaphore
    std::vector<vk::Semaphore>     _renderFinishedSemaphores; //!< Vulkan semaphore
    std::vector<vk::Fence>         _inFlightFences;           //!< Vulkan fence
    std::vector<vk_utility::buffer::BufferAndMemoryPtr> _vertex_buffers;              //!< Vulkan vertex buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr> _index_buffers;               //!< Vulkan index buffer
    std::vector<vk_utility::buffer::BufferAndMemoryPtr> _uniform_buffers;             //!< Vulkan uniform buffer
    std::vector<vk_utility::image::ImageViewMemoryPtr>  _depth_image_view_memory;     //!< Vulkan depth image view memory
    std::vector<vk_utility::image::ImageViewMemoryPtr>  _color_image_view_memory;     //!< Vulkan color image view memory
    std::vector<uint32_t> _texture_image_mipmap_level;  //!< mipmap levels TODO $$$ add to vk_utility::image::ImageViewMemory
    std::vector<vk_utility::image::ImageViewMemoryPtr>  _texture_image_view_memory;   //!< Vulkan texture image view memory
    std::vector<vk::Sampler>       _textureSampler;           //!< Vulkan texture sampler
};


class CopyBufferHelper
    : public vk_utility::buffer::BufferOperatorCopyBuffer
{
private: 
    CAppliction &_app;

public:
    CopyBufferHelper(CAppliction &app)
        : _app(app)
    {}
    
    virtual CopyBufferHelper &copy(vk_utility::buffer::BufferAndMemoryPtr destination_buffer, vk_utility::buffer::BufferAndMemoryPtr source_buffer) override
    {
        //! TODO $$$
        //! [Transfer queue](https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer)
        //! The buffer copy command requires a queue family that supports transfer operations, which is indicated using VK_QUEUE_TRANSFER_BIT.
        //! The good news is that any queue family with VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT capabilities already implicitly support VK_QUEUE_TRANSFER_BIT operations.
        //! The implementation is not required to explicitly list it in queueFlags in those cases.
        //!
        //! If you like a challenge, then you can still try to use a different queue family specifically for transfer operations. 
        //! It will require you to make the following modifications to your program:
        //! - Modify QueueFamilyIndices and findQueueFamilies to explicitly look for a queue family with the VK_QUEUE_TRANSFER bit, but not the VK_QUEUE_GRAPHICS_BIT.
        //! - Modify createLogicalDevice to request a handle to the transfer queue
        //! - Create a second command pool for command buffers that are submitted on the transfer queue family
        //! - Change the sharingMode of resources to be VK_SHARING_MODE_CONCURRENT and specify both the graphics and transfer queue families
        //! - Submit any transfer commands like vkCmdCopyBuffer (which we'll be using in this chapter) to the transfer queue instead of the graphics queue

        
        //! Contents of buffers are transferred using the vkCmdCopyBuffer command.
        //! It takes the source and destination buffers as arguments, and an array of regions to copy.
        //! The regions are defined in `vk::BufferCopy` structures and consist of a source buffer offset, destination buffer offset and size.
        //! It is not possible to specify VK_WHOLE_SIZE here, unlike the vkMapMemory command.

        auto command_buffer_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
            .set_graphics_queue(_app._graphicsQueue);
        auto command_buffer = vk_utility::command::CommandBuffer::NewPtr(_app._device->get(), _app._command_pool->get(), command_buffer_factory);


        std::vector<vk::BufferCopy> copyRegions{vk::BufferCopy(0, 0, destination_buffer->buffer().size())};
        command_buffer->get()->copyBuffer(source_buffer->buffer(), destination_buffer->buffer(), copyRegions);
        
        command_buffer_factory.End(command_buffer->get());

        return *this;
    }
};



/******************************************************************//**
* \brief   ctor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::CAppliction( 
  bool verbose ) //!< control of log messages
  : _verbose( verbose )
{}


/******************************************************************//**
* \brief   dtor
* 
* \author  gernot
* \date    2017-11-16
* \version 1.0
**********************************************************************/
CAppliction::~CAppliction()
{}


/******************************************************************//**
* \brief   Run Vulkan application
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::run( void ) {
     
    if ( _requestedValidationLayers.empty() && _enableAllValidationLayers == false )
        _enableAllValidationLayers = debug_true;

    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}

/******************************************************************//**
* \brief   Initialize GLFW and create GLFW window
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initWindow( void ) {

    //! glfwInit() initializes the GLFW library. 
    if ( glfwInit() == GLFW_FALSE )
        throw CException( "error initializing GLFW" ); 

    //! Because GLFW was originally designed to create an OpenGL context,
    //! we need to tell it to not create an OpenGL context with a subsequent call:
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        
    //! Because handling resized windows takes special care that we'll look into later,
    //! disable it for now with another window hint call:
    //glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    //! The first three parameters specify the width, height and title of the window.
    //! The fourth parameter allows you to optionally specify a monitor to open the window on
    //! and the last parameter is only relevant to OpenGL.
    _wnd = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan window", nullptr, nullptr);
    if ( _wnd == nullptr )
        throw CException( "error initializing window" ); 

    //! window pointer for callbacks
    glfwSetWindowUserPointer(_wnd, this);

    //! resize call back 
    glfwSetFramebufferSizeCallback(_wnd, framebufferResizeCallback);
}


/******************************************************************//**
* \brief   Set up Vulkan
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::initVulkan( void )
{

    vk_utility::logging::Log log;

    //vk_utility::Init();


#if VK_UTILITY_DYNAMIC_LOADING == 1
    vk::DynamicLoader dl;
    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = dl.getProcAddress<PFN_vkGetInstanceProcAddr>("vkGetInstanceProcAddr");

    VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);
#endif

    if (Verbose())
         vk_utility::logging::LogList(log).log("GLFW extensions supported", vk_glfw_utility::core::Extensions().get_names());

    _instance = vk_utility::core::InstanceFactory()
        .verbose(Verbose())
        .title("Vulkan tutorial - utility")
        .validation_layers(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers)
        .extensions(_requestedExtensions, _enableDebugExtensions)
        .New();

    _debubCallback = vk_utility::core::Debug::New(_instance, _enableDebugInformation, _enableValidationWarnings);

    _surface = vk_glfw_utility::device::SurfaceFactory(_wnd).New(_instance);

    if (Verbose())
      vk_utility::logging::LogList(log).log("physical device extensions are requested", _requestedDeviceExtensions);
    
    _physical_device = vk_utility::device::PhysicalDeviceSelctor::New()
        .rater(vk_utility::device::PhysicalDeviceRateDefault::New(_requestedDeviceExtensions, _enableSwapchainExtension))
        .verbose(Verbose())
        .select(_instance, _surface);

    vk_utility::core::ValidationLayers validation_layers;
    auto selected_validation_layers = validation_layers.select(_enableAllValidationLayers, _requestedValidationLayers, _excludedValidationLayers);
    _device = vk_utility::device::DeviceFactoryDefault()
        .set_requested_device_extensions(_requestedDeviceExtensions)
        .set_requested_validation_layers(selected_validation_layers)
        .New(_physical_device);

    _graphicsQueue = _device->get().get_first_graphics_queue(); // TODO [...] vk_utility::Queue 
    _presentQueue = _device->get().get_first_graphics_queue();  // TODO [...] vk_utility::Queue 

    _descriptor_set_layout = vk_utility::core::DescriptorSetLayoutFactoryDefault().New(_device);

    createSwapChain(true);

    createSyncObjects();

    if ( _physical_device == nullptr )
        return;
    
    if ( Verbose() ) {

        std::cout << std::endl;
        std::cout << "instance handle:               " << std::hex << _instance->handle() << "h" << std::endl;
        std::cout << "surface handle:                " << std::hex << _surface->handle()  << "h" << std::endl;
        std::cout << "device handle:                 " << std::hex << _device->handle() << "h" << std::endl;
        std::cout << "graphics queue handle:         " << std::hex << _graphicsQueue << "h; index: " << std::dec << _physical_device->get().get_queue_information()._graphics[0] << std::endl;
        std::cout << "presentation queue handle:     " << std::hex << _presentQueue  << "h; index: " << std::dec << _physical_device->get().get_queue_information()._surface_support[0] << std::endl;
        std::cout << "swap chain handle:             " << std::hex << _swapchain->handle() << "h" << std::endl;
        std::cout << "swap chain image handles:      " << std::hex << _swapchain->get().get_swapchain_images()[0].handle() << "h";
        for ( size_t i= 1; i < _swapchain->get().get_swapchain_images().size(); ++ i )
            std::cout << ", " << std::hex << _swapchain->get().get_swapchain_images()[i].handle() << "h";
        std::cout << std::endl;
        std::cout << "swap chain color space:        " << std::dec << (int)_swapchain->get().image_color_space() << std::endl;
        std::cout << "swap chain format:             " << std::dec << (int)_swapchain->get().image_format() << std::endl;
        std::cout << "swap chain presentation mode:  " << std::hex << (int)_swapchain->get().present_mode() << "h" << std::endl;
        std::cout << "swap chain 2D extent:          " << std::dec << "(" << _swapchain->get().image_width_2D() << ", " << _swapchain->get().image_height_2D() << ")" << std::endl;
        std::cout << "swap chain image view handles: " << std::hex << _swapchain_image_views[0]->handle() << "h";
        for ( size_t i= 1; i < _swapchain_image_views.size(); ++ i )
            std::cout << ", " << std::hex << _swapchain_image_views[i]->handle() << "h";
        std::cout << std::endl;
        std::cout << "render pass handle:            " << std::hex << _render_pass->handle() << "h" << std::endl;
        std::cout << "descriptor set layout handle:  " << std::hex << _descriptor_set_layout->handle() << "h" << std::endl;
        std::cout << "descriptor pool handle:        " << std::hex << _descriptorPool << "h" << std::endl;
        std::cout << "pipeline layout handle:        " << std::hex << _pipeline_layout->handle() << "h" << std::endl;
        std::cout << "graphics pipeline handle:      " << std::hex << _graphics_pipeline->handle() << "h" << std::endl;
        std::cout << "swap chain framebuffers:       " << std::hex << _swapchain_framebuffers[0]->handle() << "h";
        for ( size_t i= 1; i < _swapchain_framebuffers.size(); ++ i )
            std::cout << ", " << std::hex << _swapchain_framebuffers[i]->handle() << "h";
        std::cout << std::endl;
        std::cout << "command pool handle:           " << std::hex << _command_pool->handle() << "h" << std::endl;
        std::cout << "command buffer handles:        " << std::hex << _commandBuffers[0] << "h";
        for ( size_t i= 1; i < _commandBuffers.size(); ++ i )
            std::cout << ", " << std::hex << _commandBuffers[i] << "h";
        std::cout << std::endl;
        std::cout << "image semaphore handles:       " << std::hex << _imageAvailableSemaphores[0] << "h";
        for ( size_t i= 1; i < _imageAvailableSemaphores.size(); ++ i )
            std::cout << ", " << std::hex << _imageAvailableSemaphores[i] << "h";
        std::cout << std::endl;
        std::cout << "render semaphore handles:      " << std::hex << _renderFinishedSemaphores[0] << "h";
        for ( size_t i= 1; i < _renderFinishedSemaphores.size(); ++ i )
            std::cout << ", " << std::hex << _renderFinishedSemaphores[i] << "h";
        std::cout << std::endl;
        std::cout << "in fight fence handles:        " << std::hex << _inFlightFences[0] << "h";
        for ( size_t i= 1; i < _inFlightFences.size(); ++ i )
            std::cout << ", " << std::hex << _inFlightFences[i] << "h";
        std::cout << std::endl;

        std::cout << std::dec << std::endl;
    }
}


/******************************************************************//**
* \brief   Event loop
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::mainLoop( void ) {

    //! To keep the application running until either an error occurs or the window is closed, we need to add an event loop 
    while (!glfwWindowShouldClose(_wnd)) {
        glfwPollEvents();

        drawFrame();

        //! we should wait for the logical device to finish operations before exiting mainLoop and destroying the window:
        _device->get()->waitIdle();

        //glfwWaitEvents();
    }
}


/******************************************************************//**
* \brief   Cleanup GLFW
* 
* \author  gernot
* \date    2017-09-30
* \version 1.0
**********************************************************************/
void CAppliction::cleanup( void ) {

    cleanupSwapChain();

    _descriptor_set_layout = nullptr;

    if (_device)
    {
        for (auto textureSampler : _textureSampler) {
             _device->get()->destroySampler(textureSampler);
        }
        _textureSampler.clear();
        _texture_image_view_memory.clear();
        _texture_image_mipmap_level.clear();
        
        _index_buffers.clear();
        _vertex_buffers.clear();
        
        for (auto inFghtFence : _inFlightFences) {
             _device->get()->destroyFence(inFghtFence);
        }
        _inFlightFences.clear();

        for (auto finishSemaphore : _renderFinishedSemaphores) {
             _device->get()->destroySemaphore(finishSemaphore);
        }
        _renderFinishedSemaphores.clear();

        for (auto imageSemaphore : _imageAvailableSemaphores) {
             _device->get()->destroySemaphore(imageSemaphore);
        }
        _imageAvailableSemaphores.clear();
    }
  
    _command_pool = nullptr;
    _device = nullptr;
    _physical_device = nullptr;
    _surface = nullptr;
    _debubCallback = nullptr;
    _instance = nullptr;

    //! Once the window is closed, we need to clean up resources by destroying it and terminating GLFW itself. 
    glfwDestroyWindow(_wnd);
    _wnd = nullptr;
    glfwTerminate();
}


/******************************************************************//**
* \brief Resize notification.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::framebufferResizeCallback( 
    GLFWwindow* window, //!< GLFW window handle (pointer)
    int         width,  //!< new width of the window
    int         height  //!< new height of the window
    ) {

    if ( window == nullptr )
        return;
    CAppliction *appPtr = (CAppliction*)glfwGetWindowUserPointer( window );
    if ( appPtr == nullptr )
        return;

    appPtr->resize( width, height );
}


/******************************************************************//**
* \brief Resize notification  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::resize( 
    int width, //!< new width of the window
    int height //!< new height of the window
    ) {

  _framebufferResized = true;
}


/******************************************************************//**
* \brief Recreate the entire swapchain (e.g. when the window was resized). 
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::recreateSwapChain( void ) {
    
    if ( !_device )
        return;

    //! We first call `vkDeviceWaitIdle`, because just like in the last chapter, we shouldn't touch resources that may still be in use.
    //! Obviously, the first thing we'll have to do is recreate the swap chain itself.
    //! The image views need to be recreated because they are based directly on the swap chain images.
    // !The render pass needs to be recreated because it depends on the format of the swap chain images.
    // !It is rare for the swap chain image format to change during an operation like a window resize, but it should still be handled.
    // !Viewport and scissor rectangle size is specified during graphics pipeline creation, so the pipeline also needs to be rebuilt.
    // !It is possible to avoid this by using dynamic state for the viewports and scissor rectangles.
    //! Finally, the framebuffers and command buffers also directly depend on the swap chain images.

    _device->get()->waitIdle();

    // pause till the window is minimized
    int width = 0, height = 0;
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(_wnd, &width, &height);
        glfwWaitEvents();
    }

    //pickPhysicalDevice();
    // update swap chain information
    _physical_device->get().evaluate_swapchain_support(*_surface);
    
    cleanupSwapChain();
    createSwapChain(false);
}


void CAppliction::createSwapChain(bool initilaize)
{
    _swapchain = vk_utility::swap::SwapchainFactoryDefault()
        .set_format_selector(std::make_shared<vk_utility::swap::SwapSurfaceFormatSelectorDefault>())
        .set_present_mode_selector(std::make_shared<vk_utility::swap::SwapPresentModeSelectorDefault>())
        .set_extent_selector(std::make_shared<vk_glfw_utility::swap::SwapExtentSelector>(_wnd))
        .New(_device, _surface);

    _swapchain_image_views = vk_utility::image::ImageViewFactoryDefault()
        .set_swapchain(_swapchain)
        .New(_device);

    _render_pass = vk_utility::core::RenderPassFactoryDefault()
        .set_color_format(_swapchain->get().image_format())
        .set_depth_format(findDepthFormat())
        .set_sampple_count(_physical_device->get().get_max_usable_sample_count())
        .New(_device);

    _pipeline_layout = vk_utility::pipeline::PipelineLayout::New(_device, _descriptor_set_layout);

    auto vert_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_vert.spv")
        .New(_device);
    auto frag_shader_module = vk_utility::shader::ShaderModuleFactorySpirVFile()
        .set_source_file("shaders/shader_1_frag.spv")
        .New(_device);
    auto bindingDescription = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    _graphics_pipeline = vk_utility::pipeline::PipelienFactoryDefault()
        .add_shader_module(vert_shader_module, vk::ShaderStageFlagBits::eVertex)
        .add_shader_module(frag_shader_module, vk::ShaderStageFlagBits::eFragment)
        .add_vertex_binding_description(bindingDescription)
        .add_attribute_descriptions(std::vector<vk::VertexInputAttributeDescription>(attributeDescriptions.begin(), attributeDescriptions.end()))
        .enable_face_culling(_enable_face_culling)
        .set_pipeline_layout(_pipeline_layout)
        .set_render_pass(_render_pass)
        .New(_device, _swapchain);

    _command_pool = vk_utility::command::CommandPool::NewPtr(
        _device->get(),
        vk_utility::command::CommandPoolFactoryDefault()
        .set_device_queue_information(_physical_device->get().get_queue_information_ptr()));

    createColorResources();
    createDepthResources();
    
    _swapchain_framebuffers = vk_utility::buffer::FramebufferFactoryDefault()
        .set_swapchain(_swapchain)
        .set_swapchain_image_views(_swapchain_image_views)
        .set_color_image_view(_color_image_view_memory.front())
        .set_depth_image_view(_depth_image_view_memory.front())
        .set_render_pass(_render_pass)
        .New(_device->get());

    if (initilaize)
    {
        createTextureImage();
        createTextureSampler();

        loadModel();
    
        _vertex_buffers.push_back(vk_utility::buffer::BufferAndMemory::New(
            _device, 
            vk_utility::buffer::BufferAndMemoryInformation::NewVertex(sizeof(_vertices[0]) * _vertices.size()), 
            _vertices, 
            vk_utility::buffer::BufferOperatorCopyDataStaging::New(_device, std::make_shared<CopyBufferHelper>(*this))));
        _index_buffers.push_back(vk_utility::buffer::BufferAndMemory::New(
            _device, 
            vk_utility::buffer::BufferAndMemoryInformation::NewIndex(sizeof(_indices[0]) * _indices.size()), 
            _indices,
            vk_utility::buffer::BufferOperatorCopyDataStaging::New(_device, std::make_shared<CopyBufferHelper>(*this))));
    }

    // We're going to copy new data to the uniform buffer every frame, so it doesn't really make any sense to have a staging buffer.
    // It would just add extra overhead in this case and likely degrade performance instead of improving it.

    // We should have multiple buffers, because multiple frames may be in flight at the same time and
    // we don't want to update the buffer in preparation of the next frame while a previous one is still reading from it!
    // We could either have a uniform buffer per frame or per swap chain image.
    // However, since we need to refer to the uniform buffer from the command buffer that we have per swap chain image,
    // it makes the most sense to also have a uniform buffer per swap chain image.

    vk::DeviceSize bufferSize = sizeof(UniformBufferObject);
    for (size_t i = 0; i < _swapchain->get().no_of_swapchain_images(); i++)
    {
        _uniform_buffers.push_back(vk_utility::buffer::BufferAndMemory::New(
            _device, vk_utility::buffer::BufferAndMemoryInformation::NewCoherentUniform(bufferSize)));
    }

    createDescriptorPool();
    createDescriptorSets();
    createCommandBuffers();
}


/******************************************************************//**
* \brief Cleanup everything which will be recreated till swapchain
* is recreated.  
* 
* \author  gernot
* \date    2018-11-03
* \version 1.0
**********************************************************************/
void CAppliction::cleanupSwapChain( void ) {

    if ( !_device )
        return;

    _depth_image_view_memory.clear();
    _color_image_view_memory.clear();
    
    _uniform_buffers.clear();
   
    if (_descriptorPool)
        _device->get()->destroyDescriptorPool(_descriptorPool);
    _descriptorPool = vk::DescriptorPool();

    //! You don't need to explicitly clean up descriptor sets, because they will be automatically freed when the descriptor pool is destroyed.
    _descriptorSets.clear();


    _swapchain_framebuffers.clear();

    if (_command_pool)
        _device->get()->freeCommandBuffers(_command_pool->get(), _commandBuffers);
    _commandBuffers.clear();

    _graphics_pipeline = nullptr;
    _pipeline_layout = nullptr;
    _render_pass = nullptr;

    _swapchain_image_views.clear();

    _swapchain = nullptr;
}

    
/******************************************************************//**
* \brief Handle image layout transition.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::transitionImageLayout( 
    vk::Image       image,     //!< I -
    vk::Format      format,    //!< I -
    vk::ImageLayout oldLayout, //!< I -
    vk::ImageLayout newLayout, //!< I -
    uint32_t      mipLevels  //!< I -
    )
{
    auto command_buffer_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);
    auto command_buffer = vk_utility::command::CommandBuffer::NewPtr(_device->get(), _command_pool->get(), command_buffer_factory);

    //-------------------------------------------
    // Layout transitions
    //-------------------------------------------

    //! One of the most common ways to perform layout transitions is using an image memory barrier.
    //! A pipeline barrier like that is generally used to synchronize access to resources,
    //! like ensuring that a write to a buffer completes before reading from it,
    //! but it can also be used to transition image layouts and transfer queue family ownership when VK_SHARING_MODE_EXCLUSIVE is used.
    
    //! There is an equivalent buffer memory barrier to do this for buffers.
    //! The first two fields specify layout transition.
    //! It is possible to use VK_IMAGE_LAYOUT_UNDEFINED as oldLayout if you don't care about the existing contents of the image.
    //! If you are using the barrier to transfer queue family ownership, then these two fields should be the indices of the queue families.
    //! They must be set to VK_QUEUE_FAMILY_IGNORED if you don't want to do this (not the default value!).
    //! The image and subresourceRange specify the image that is affected and the specific part of the image.
    //! Our image is not an array and does not have mipmapping levels, so only one level and layer are specified.
    //! Barriers are primarily used for synchronization purposes, so you must specify which types of operations that involve the resource must happen before the barrier,
    //! and which operations that involve the resource must wait on the barrier.
    //! We need to do that despite already using vkQueueWaitIdle to manually synchronize.
    //! The right values depend on the old and new layout, so we'll get back to this once we've figured out which transitions we're going to use.

    //! All types of pipeline barriers are submitted using the same function.
    //! The first parameter after the command buffer specifies in which pipeline stage the operations occur that should happen before the barrier.
    //! The second parameter specifies the pipeline stage in which operations will wait on the barrier.
    //! The pipeline stages that you are allowed to specify before and after the barrier depend on how you use the resource before and after the barrier.
    //! The allowed values are listed in this table of the specification. 
    //! For example, if you're going to read from a uniform after the barrier,
    //! you would specify a usage of VK_ACCESS_UNIFORM_READ_BIT and the earliest shader that will read from the uniform as pipeline stage,
    //! for example VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT.
    //! It would not make sense to specify a non-shader pipeline stage for this type of usage and the validation layers will warn you when you specify a pipeline stage that does not match the type of usage.
    //! The third parameter is either 0 or VK_DEPENDENCY_BY_REGION_BIT.
    //! The latter turns the barrier into a per-region condition. 
    //! That means that the implementation is allowed to already begin reading from the parts of a resource that were written so far, for example.
    //! The last three pairs of parameters reference arrays of pipeline barriers of the three available types:
    //! memory barriers, buffer memory barriers, and image memory barriers like the one we're using here.
    //! Note that we're not using the `vk::Format` parameter yet, but we'll be using that one for special transitions in the depth buffer chapter.
   

    //-------------------------------------------
    // Transition barrier masks
    //-------------------------------------------
    
    //! There are two transitions we need to handle:
    //!     Undefined transfer destination: transfer writes that don't need to wait on anything
    //!     transfer destination shader reading: shader reads should wait on transfer writes, specifically the shader reads in the fragment shader, because that's where we're going to use the texture

    //! As you can see in the aforementioned table, transfer writes must occur in the pipeline transfer stage.
    //! Since the writes don't have to wait on anything, you may specify an empty access mask and the earliest possible pipeline stage VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT for the pre-barrier operations.
    //! It should be noted that VK_PIPELINE_STAGE_TRANSFER_BIT is not a real stage within the graphics and compute pipelines.
    //! It is more of a pseudo-stage where transfers happen. See the documentation for more information and other examples of pseudo-stages.
    //! The image will be written in the same pipeline stage and subsequently read by the fragment shader, which is why we specify shader reading access in the fragment shader pipeline stage.
    //! If we need to do more transitions in the future, then we'll extend the function.
    //! The application should now run successfully, although there are of course no visual changes yet.
    //! One thing to note is that command buffer submission results in implicit VK_ACCESS_HOST_WRITE_BIT synchronization at the beginning.
    //1 Since the transitionImageLayout function executes a command buffer with only a single command, you could use this implicit synchronization and set srcAccessMask to 0 if you ever needed a VK_ACCESS_HOST_WRITE_BIT dependency in a layout transition.
    //! It's up to you if you want to be explicit about it or not, but I'm personally not a fan of relying on these OpenGL-like "hidden" operations.
    //! There is actually a special type of image layout that supports all operations, VK_IMAGE_LAYOUT_GENERAL.
    //! The problem with it, of course, is that it doesn't necessarily offer the best performance for any operation.
    //! It is required for some special cases, like using an image as both input and output, or for reading an image after it has left the preinitialized layout.
    //! All of the helper functions that submit commands so far have been set up to execute synchronously by waiting for the queue to become idle.
    //! For practical applications it is recommended to combine these operations in a single command buffer and execute them asynchronously for higher throughput, especially the transitions and copy in the createTextureImage function.
    //! Try to experiment with this by creating a setupCommandBuffer that the helper functions record commands into, and add a flushSetupCommands to execute the commands that have been recorded so far.
    //! It's best to do this after the texture mapping works to check if the texture resources are still set up correctly.

    vk::ImageSubresourceRange subresourceRange(vk::ImageAspectFlagBits::eColor, 0, mipLevels, 0, 1);
    vk::PipelineStageFlags sourceStage;
    vk::PipelineStageFlags destinationStage;
    vk::AccessFlags srcAccessMask{};
    vk::AccessFlags dstAccessMask{};

    if (oldLayout == vk::ImageLayout::eUndefined && newLayout == vk::ImageLayout::eTransferDstOptimal)
    {
        dstAccessMask = vk::AccessFlagBits::eTransferWrite;
        sourceStage = vk::PipelineStageFlagBits::eTopOfPipe;
        destinationStage = vk::PipelineStageFlagBits::eTransfer;
    } 
    else if (oldLayout == vk::ImageLayout::eTransferDstOptimal && newLayout == vk::ImageLayout::eShaderReadOnlyOptimal)
    {
        srcAccessMask = vk::AccessFlagBits::eTransferWrite;
        dstAccessMask = vk::AccessFlagBits::eShaderRead;
        sourceStage = vk::PipelineStageFlagBits::eTransfer;
        destinationStage = vk::PipelineStageFlagBits::eFragmentShader;
    }
    else
    {
        throw std::invalid_argument("unsupported layout transition!");
    }

    vk::ImageMemoryBarrier barrier
    (
        srcAccessMask,
        dstAccessMask,
        oldLayout,
        newLayout,
        VK_QUEUE_FAMILY_IGNORED,
        VK_QUEUE_FAMILY_IGNORED,
        image,
        subresourceRange
    );

    command_buffer->get()->pipelineBarrier(
        sourceStage, destinationStage,
        vk::DependencyFlags(),
        0, nullptr,
        0, nullptr,
        1, &barrier
    );
    command_buffer_factory.End(command_buffer->get());
}


/******************************************************************//**
* \brief Copy buffer to image.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::copyBufferToImage(
    vk::Buffer buffer, //!< I - 
    vk::Image  image,  //!< I - 
    uint32_t width,  //!< I - 
    uint32_t height  //!< I - 
    )
{
    auto command_buffer_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);
    auto command_buffer = vk_utility::command::CommandBuffer::NewPtr(_device->get(), _command_pool->get(), command_buffer_factory);

    //-------------------------------------------
    // Copying buffer to image
    //-------------------------------------------

    //! The bufferOffset specifies the byte offset in the buffer at which the pixel values start.
    //! The bufferRowLength and bufferImageHeight fields specify how the pixels are laid out in memory.
    //! For example, you could have some padding bytes between rows of the image.
    //! Specifying 0 for both indicates that the pixels are simply tightly packed like they are in our case. 
    //! The imageSubresource, imageOffset and imageExtent fields indicate to which part of the image we want to copy the pixels.

   vk::ImageSubresourceLayers imageSubresource
    (
        vk::ImageAspectFlagBits::eColor,
        0,
        0,
        1
    );

    vk::Offset3D imageOffset(0, 0, 0);
    vk::Extent3D imageExtent(width, height, 1);

    vk::BufferImageCopy region
    (
        0,
        0,
        0,
        imageSubresource,
        imageOffset,
        imageExtent
    );

    //! The fourth parameter indicates which layout the image is currently using.
    //! I'm assuming here that the image has already been transitioned to the layout that is optimal for copying pixels to.
    //! Right now we're only copying one chunk of pixels to the whole image, but it's possible to specify an array of `vk::BufferImageCopy` to perform many different copies from this buffer to the image in one operation.

    command_buffer->get()->copyBufferToImage(
        buffer,
        image,
        vk::ImageLayout::eTransferDstOptimal,
        1,
        &region
    );
    command_buffer_factory.End(command_buffer->get());
}


/******************************************************************//**
* \brief find supported format
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
vk::Format CAppliction::findSupportedFormat(const std::vector<vk::Format>& candidates, vk::ImageTiling tiling, vk::FormatFeatureFlags features) {
    
    //! Creating a depth image is fairly straightforward. It should have the same resolution as the color attachment, 
    //! defined by the swap chain extent, an image usage appropriate for a depth attachment, optimal tiling and device local memory. 
    //! The only question is: what is the right format for a depth image? The format must contain a depth component, indicated by _D??_ in the VK_FORMAT_.

    //! Unlike the texture image, we don't necessarily need a specific format, because we won't be directly accessing the texels from the program. 
    //! It just needs to have a reasonable accuracy, at least 24 bits is common in real-world applications. There are several formats that fit this requirement:
    //!
    //! VK_FORMAT_D32_SFLOAT: 32-bit float for depth
    //! VK_FORMAT_D32_SFLOAT_S8_UINT: 32-bit signed float for depth and 8 bit stencil component
    //! VK_FORMAT_D24_UNORM_S8_UINT: 24-bit float for depth and 8 bit stencil component
    
    for (vk::Format format : candidates) {
        vk::FormatProperties props = _physical_device->get()->getFormatProperties(format);

        if (tiling == vk::ImageTiling::eLinear && (props.linearTilingFeatures & features) == features) {
            return format;
        } else if (tiling == vk::ImageTiling::eOptimal && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }

    throw std::runtime_error("failed to find supported format!");
}


/******************************************************************//**
* \brief Find depth format. 
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
vk::Format CAppliction::findDepthFormat() {
    return findSupportedFormat(
        { vk::Format::eD32Sfloat, vk::Format::eD32SfloatS8Uint, vk::Format::eD24UnormS8Uint },
        vk::ImageTiling::eOptimal,
        vk::FormatFeatureFlagBits::eDepthStencilAttachment
    );
}


/******************************************************************//**
* \brief Create color image.  
* 
* \author  gernot
* \date    2020-06-01
* \version 1.0
**********************************************************************/
void CAppliction::createColorResources(void) {

    if ( !_device )
        throw CException("no logical vulkan device!");

    vk::Format colorFormat = _swapchain->get().image_format();

    auto image_and_memory = vk_utility::image::ImageAndMemory::NewPtr(
        _device->get(),
        vk_utility::image::ImageAndMemoryFactoryDefault()
        .set_image_factory(&vk_utility::image::ImageFactory2D()
            .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
            .set_format(colorFormat)
            .set_mipmap_levels(1)
            .set_samples(_physical_device->get().get_max_usable_sample_count())
            .set_usage(vk::ImageUsageFlagBits::eTransientAttachment | vk::ImageUsageFlagBits::eColorAttachment))
        .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
            .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
            .set_from_physical_device(_device->get().physical_device()))
    );

    auto image_view = vk_utility::image::ImageView::New(_device, *image_and_memory->image(), colorFormat, vk::ImageAspectFlagBits::eColor, 1);
    
    _color_image_view_memory.emplace_back(vk_utility::image::ImageViewMemory::New(image_and_memory->detach_device_memory(), image_and_memory->detach_image(), image_view));
}


/******************************************************************//**
* \brief Create depth image.  
* 
* \author  gernot
* \date    2020-05-31
* \version 1.0
**********************************************************************/
void CAppliction::createDepthResources( void )
{
    if ( !_device )
        throw CException("no logical vulkan device!");

    vk::Format depthFormat = findDepthFormat();

    auto image_and_memory = vk_utility::image::ImageAndMemory::NewPtr(
        _device->get(),
        vk_utility::image::ImageAndMemoryFactoryDefault()
        .set_image_factory(&vk_utility::image::ImageFactory2D()
            .set_size(_swapchain->get().image_width_2D(), _swapchain->get().image_height_2D())
            .set_format(depthFormat)
            .set_mipmap_levels(1)
            .set_samples(_physical_device->get().get_max_usable_sample_count())
            .set_usage(vk::ImageUsageFlagBits::eDepthStencilAttachment))
        .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
            .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
            .set_from_physical_device(_device->get().physical_device()))
    );

    auto image_view = vk_utility::image::ImageView::New(_device, *image_and_memory->image(), depthFormat, vk::ImageAspectFlagBits::eDepth, 1);
 
    _depth_image_view_memory.emplace_back(vk_utility::image::ImageViewMemory::New(image_and_memory->detach_device_memory(), image_and_memory->detach_image(), image_view));
}


/******************************************************************//**
* \brief Create texture image.  
* 
* \author  gernot
* \date    2019-05-05
* \version 1.0
**********************************************************************/
void CAppliction::createTextureImage( void ) {

    if ( !_device )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Loading an image
    //-------------------------------------------
    
    std::string image_name = "../../../_data/wood.png";
    if (_load_model)
        image_name = TEXTURE_PATH;

    int texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(image_name.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
    vk::DeviceSize imageSize = (size_t)texWidth * texHeight * 4;

    if (!pixels) {
        throw CException("failed to load texture image!");
    }


    //-------------------------------------------
    // Staging buffer
    //-------------------------------------------

    //! We're now going to create a buffer in host visible memory so that we can use vkMapMemory and copy the pixels to it.
    //! Add variables for this temporary buffer to the createTextureImage function:
    //! The buffer should be in host visible memory so that we can map it and it should be usable as a transfer source so that we can copy it to an image later on:
    //! We can then directly copy the pixel values that we got from the image loading library to the buffer:

    auto staging_buffer = vk_utility::buffer::BufferAndMemory::New(
        _device, vk_utility::buffer::BufferAndMemoryInformation::NewStaging(imageSize), pixels, vk_utility::buffer::BufferOperatorCopyDataToMemory::New());
    stbi_image_free( pixels );

    uint32_t mipLevels = static_cast<uint32_t>(std::floor(std::log2(std::max(texWidth, texHeight)))) + 1;
    _texture_image_mipmap_level.push_back(mipLevels);

    vk::ImageUsageFlags usage_flags = vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled;
    if (_texture_image_mipmap_level.back() > 1)
        usage_flags |= vk::ImageUsageFlagBits::eTransferSrc;

    auto image_and_memory = vk_utility::image::ImageAndMemory::NewPtr(
        _device->get(),
        vk_utility::image::ImageAndMemoryFactoryDefault()
        .set_image_factory(&vk_utility::image::ImageFactory2D()
            .set_size(texWidth, texHeight)
            .set_format(vk::Format::eR8G8B8A8Srgb)
            .set_mipmap_levels(_texture_image_mipmap_level.back())
            .set_samples(vk::SampleCountFlagBits::e1)
            .set_usage(usage_flags))
        .set_device_memory_factory(&vk_utility::image::ImageDeviceMemoryFactory()
            .set_memory_properties(vk::MemoryPropertyFlagBits::eDeviceLocal)
            .set_from_physical_device(_device->get().physical_device()))
    );

    //-------------------------------------------
    // Preparing the texture image
    //-------------------------------------------
 
    //! Copy the staging buffer to the texture image. This involves two steps:
    //!     Transition the texture image to VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    //!     Execute the buffer to image copy operation

    //! The image was created with the VK_IMAGE_LAYOUT_UNDEFINED layout, so that one should be specified as old layout when transitioning textureImage.
    //! Remember that we can do this because we don't care about its contents before performing the copy operation.

    transitionImageLayout(*image_and_memory->image(), vk::Format::eR8G8B8A8Unorm, vk::ImageLayout::eUndefined, vk::ImageLayout::eTransferDstOptimal, _texture_image_mipmap_level.back());
    copyBufferToImage(staging_buffer->buffer(), *image_and_memory->image(), static_cast<uint32_t>(texWidth), static_cast<uint32_t>(texHeight));

    //! To be able to start sampling from the texture image in the shader, we need one last transition to prepare it for shader access:
    //transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps
    if (_texture_image_mipmap_level.back() == 1)
        transitionImageLayout(*image_and_memory->image(), vk::Format::eR8G8B8A8Unorm, vk::ImageLayout::eTransferDstOptimal, vk::ImageLayout::eShaderReadOnlyOptimal, 1);

    staging_buffer->destroy();

     if (_texture_image_mipmap_level.back() > 1)
         generateMipmaps(*image_and_memory->image(), vk::Format::eR8G8B8A8Srgb, texWidth, texHeight, _texture_image_mipmap_level.back());

    auto image_view = 
         vk_utility::image::ImageView::New(_device, *image_and_memory->image(), vk::Format::eR8G8B8A8Srgb, vk::ImageAspectFlagBits::eColor, _texture_image_mipmap_level.back());

    _texture_image_view_memory.emplace_back(vk_utility::image::ImageViewMemory::New(image_and_memory->detach_device_memory(), image_and_memory->detach_image(), image_view));
}


/******************************************************************//**
* \brief Generate mipmaps
* 
* \author  gernot
* \date    2020-06-01
* \version 1.0
**********************************************************************/
void CAppliction::generateMipmaps(vk::Image image, vk::Format imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels)
{
    // Check if image format supports linear blitting
    vk::FormatProperties formatProperties = _physical_device->get()->getFormatProperties(imageFormat);

    if (!(formatProperties.optimalTilingFeatures & vk::FormatFeatureFlagBits::eSampledImageFilterLinear)) {
        throw std::runtime_error("texture image format does not support linear blitting!");
    }

    auto command_buffer_factory = vk_utility::command::CommandBufferFactorySingleTimeCommand()
        .set_graphics_queue(_graphicsQueue);
    auto command_buffer = vk_utility::command::CommandBuffer::NewPtr(_device->get(), _command_pool->get(), command_buffer_factory);

    vk::ImageSubresourceRange subresourceRange(vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1);
    vk::ImageMemoryBarrier barrier
    (
        vk::AccessFlags{},
        vk::AccessFlags{},
        vk::ImageLayout::eUndefined,
        vk::ImageLayout::eUndefined,
        VK_QUEUE_FAMILY_IGNORED,
        VK_QUEUE_FAMILY_IGNORED,
        image,
        subresourceRange
    );

    //! We're going to make several transitions, so we'll reuse this `vk::ImageMemoryBarrier`. 
    //! The fields set above will remain the same for all barriers. subresourceRange.miplevel, oldLayout, newLayout, srcAccessMask, and dstAccessMask will be changed for each transition.

    int32_t mipWidth = texWidth;
    int32_t mipHeight = texHeight;

    for (uint32_t i = 1; i < mipLevels; i++) {

        //! This loop will record each of the `vk::CmdBlitImage` commands. Note that the loop variable starts at 1, not 0.

        barrier.subresourceRange.setBaseMipLevel(i - 1);
        barrier
            .setOldLayout(vk::ImageLayout::eTransferDstOptimal)
            .setNewLayout(vk::ImageLayout::eTransferSrcOptimal)
            .setSrcAccessMask(vk::AccessFlagBits::eTransferWrite)
            .setDstAccessMask(vk::AccessFlagBits::eTransferRead);

        command_buffer->get()->pipelineBarrier(
            vk::PipelineStageFlagBits::eTransfer, vk::PipelineStageFlagBits::eTransfer, vk::DependencyFlags(),
            0, nullptr,
            0, nullptr,
            1, &barrier);

        //! First, we transition level i - 1 to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL.
        //! This transition will wait for level i - 1 to be filled, either from the previous blit command, or from vkCmdCopyBufferToImage.
        //! The current blit command will wait on this transition.

        vk::ImageSubresourceLayers srcSubresource(vk::ImageAspectFlagBits::eColor, i - 1, 0, 1);
        std::array<vk::Offset3D, 2> srcOffsets{vk::Offset3D(0, 0, 0), vk::Offset3D(mipWidth, mipHeight, 1)};
        vk::ImageSubresourceLayers dstSubresource(vk::ImageAspectFlagBits::eColor, i, 0, 1);
        std::array<vk::Offset3D, 2> dstOffsets{vk::Offset3D(0, 0, 0), vk::Offset3D(mipWidth > 1 ? mipWidth / 2 : 1, mipHeight > 1 ? mipHeight / 2 : 1, 1)};
        vk::ImageBlit blit
        (
            srcSubresource,
            srcOffsets,
            dstSubresource,
            dstOffsets
        );

        //! Next, we specify the regions that will be used in the blit operation. 
        //! The source mipmap level is i - 1 and the destination mipmap level is i. 
        //! The two elements of the srcOffsets array determine the 3D region that data will be blitted from.
        //! dstOffsets determines the region that data will be blitted to. 
        //! The X and Y dimensions of the dstOffsets[1] are divided by two since each mipmap level is half the size of the previous level.
        //! The Z dimension of srcOffsets[1] and dstOffsets[1] must be 1, since a 2D image has a depth of 1.

        command_buffer->get()->blitImage(
            image, vk::ImageLayout::eTransferSrcOptimal,
            image, vk::ImageLayout::eTransferDstOptimal,
            1, &blit,
            vk::Filter::eLinear);

        //! Now, we record the blit command. Note that textureImage is used for both the srcImage and dstImage parameter. 
        //! This is because we're blitting between different levels of the same image.
        //! The source mipmap level was just transitioned to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL and the destination level is still in VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL from createTextureImage.

        //! The last parameter allows us to specify a `vk::Filter` to use in the blit. 
        //! We have the same filtering options here that we had when making the `vk::Sampler`. 
        //! We use the VK_FILTER_LINEAR to enable interpolation.

        barrier
            .setOldLayout(vk::ImageLayout::eTransferSrcOptimal)
            .setNewLayout(vk::ImageLayout::eShaderReadOnlyOptimal)
            .setSrcAccessMask(vk::AccessFlagBits::eTransferRead)
            .setDstAccessMask(vk::AccessFlagBits::eShaderRead);

        command_buffer->get()->pipelineBarrier(
            vk::PipelineStageFlagBits::eTransfer, vk::PipelineStageFlagBits::eFragmentShader, vk::DependencyFlags(),
            0, nullptr,
            0, nullptr,
            1, &barrier);

        if (mipWidth > 1) mipWidth /= 2;
        if (mipHeight > 1) mipHeight /= 2;

        //! At the end of the loop, we divide the current mipmap dimensions by two. 
        //! We check each dimension before the division to ensure that dimension never becomes 0. 
        //! This handles cases where the image is not square, since one of the mipmap dimensions would reach 1 before the other dimension. 
        //! When this happens, that dimension should remain 1 for all remaining levels.
    }

    //! Before we end the command buffer, we insert one more pipeline barrier. 
    //! This barrier transitions the last mipmap level from VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL. 
    //! This wasn't handled by the loop, since the last mipmap level is never blitted from.

    barrier.subresourceRange.setBaseMipLevel(mipLevels - 1);
    barrier
        .setOldLayout(vk::ImageLayout::eTransferDstOptimal)
        .setNewLayout(vk::ImageLayout::eShaderReadOnlyOptimal)
        .setSrcAccessMask(vk::AccessFlagBits::eTransferWrite)
        .setDstAccessMask(vk::AccessFlagBits::eShaderRead);

    command_buffer->get()->pipelineBarrier(
        vk::PipelineStageFlagBits::eTransfer, vk::PipelineStageFlagBits::eFragmentShader, vk::DependencyFlags(),
        0, nullptr,
        0, nullptr,
        1, &barrier);
    command_buffer_factory.End(command_buffer->get());
}


/******************************************************************//**
* \brief Create texture sampler. 
* 
* \author  gernot
* \date    2020-05-26
* \version 1.0
**********************************************************************/
void CAppliction::createTextureSampler( void )
{
    if ( !_device )
        throw CException("no logical vulkan device!");

    //! Samplers are configured through a `vk::SamplerCreateInfo` structure, which specifies all filters and transformations that it should apply.

    //! The magFilter and minFilter fields specify how to interpolate texels that are magnified or minified.
    //! Magnification concerns the oversampling problem describes above, and minification concerns under-sampling.
    //! The choices are VK_FILTER_NEAREST and VK_FILTER_LINEAR, corresponding to the modes demonstrated in the images above.

    //! The addressing mode can be specified per axis using the addressMode fields.
    //! The available values are listed below. Most of these are demonstrated in the image above.
    //! Note that the axes are called U, V and W instead of X, Y and Z. This is a convention for texture space coordinates.
    //! 
    //! - VK_SAMPLER_ADDRESS_MODE_REPEAT: Repeat the texture when going beyond the image dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: Like repeat, but inverts the coordinates to mirror the image when going beyond the dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: Take the color of the edge closest to the coordinate beyond the image dimensions.
    //! - VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: Like clamp to edge, but instead uses the edge opposite to the closest edge.
    //! - VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: Return a solid color when sampling beyond the dimensions of the image.
    //! 
    //! It doesn't really matter which addressing mode we use here, because we're not going to sample outside of the image in this tutorial. 
    //! However, the repeat mode is probably the most common mode, because it can be used to tile textures like floors and walls.

    //! These two fields specify if anisotropic filtering should be used. There is no reason not to use this unless performance is a concern.
    //! The maxAnisotropy field limits the amount of texel samples that can be used to calculate the final color. 
    //! A lower value results in better performance, but lower quality results. There is no graphics hardware available today that will use more than 16 samples, because the difference is negligible beyond that point.

    //! The borderColor field specifies which color is returned when sampling beyond the image with clamp to border addressing mode. 
    //! It is possible to return black, white or transparent in either float or int formats. You cannot specify an arbitrary color.

    //! The unnormalizedCoordinates field specifies which coordinate system you want to use to address texels in an image. 
    //! If this field is VK_TRUE, then you can simply use coordinates within the [0, texWidth) and [0, texHeight) range.
    //! If it is VK_FALSE, then the texels are addressed using the [0, 1) range on all axes. 
    //! Real-world applications almost always use normalized coordinates, because then it's possible to use textures of varying resolutions with the exact same coordinates.

    //! If a comparison function is enabled, then texels will first be compared to a value, and the result of that comparison is used in filtering operations. This is mainly used for percentage-closer filtering on shadow maps.
    //! We'll look at this in a future chapter.

    vk::SamplerCreateInfo samplerInfo
    (
        vk::SamplerCreateFlags{},
        vk::Filter::eLinear,
        vk::Filter::eLinear,
        vk::SamplerMipmapMode::eLinear,
        vk::SamplerAddressMode::eRepeat,
        vk::SamplerAddressMode::eRepeat,
        vk::SamplerAddressMode::eRepeat,
        0.0f,
        VK_TRUE,
        16.0f,
        VK_FALSE,
        vk::CompareOp::eAlways,
        0.0f, // static_cast<float>(_textureImageMipmapLevel.back() / 2)
        static_cast<float>(_texture_image_mipmap_level.back()),
        vk::BorderColor::eIntOpaqueBlack,
        VK_FALSE
    );

    
    //! All of these fields apply to mipmapping. We will look at mipmapping in a later chapter,
    //! but basically it's another type of filter that can be applied.
    
    _textureSampler.push_back(_device->get()->createSampler(samplerInfo));
}


/******************************************************************//**
* \brief Load scene.  
* 
* \author  gernot
* \date    2018-11-04
* \version 1.0
**********************************************************************/
void CAppliction::loadModel(void) {

    if (_load_model == false)
    {
        _vertices = cube_vertices;
        _indices = cube_indices;
        return;
    }


    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string warn, err;

    if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, MODEL_PATH.c_str())) {
        throw std::runtime_error(warn + err);
    }

    std::unordered_map<Vertex, uint32_t> uniqueVertices{};

    for (const auto& shape : shapes) {
        for (const auto& index : shape.mesh.indices) {
            Vertex vertex{};

            vertex.pos = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2]
            };

            vertex.texCoord = {
                attrib.texcoords[2 * index.texcoord_index + 0],
                1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
            };

            vertex.color = {5.0f, 5.0f, 5.0f};

            if (uniqueVertices.count(vertex) == 0) {
                uniqueVertices[vertex] = static_cast<uint32_t>(_vertices.size());
                _vertices.push_back(vertex);
            }

            _indices.push_back(uniqueVertices[vertex]);
        }
    }
}


/******************************************************************//**
* \brief Create uniform buffers.  
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorPool(void) {

    if (!_device)
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Descriptor pool
    //------------------------------------------- 

    //! Descriptor sets can't be created directly, they must be allocated from a pool like command buffers.
    //! The equivalent for descriptor sets is unsurprisingly called a descriptor pool.
    //! We'll write a new function createDescriptorPool to set it up


    //! We first need to describe which descriptor types our descriptor sets are going to contain and how many of them, using `vk::DescriptorPoolSize` structures.

    std::vector<vk::DescriptorPoolSize> poolSizes
    {
        vk::DescriptorPoolSize(vk::DescriptorType::eUniformBuffer, _swapchain->get().no_of_swapchain_images()),
        vk::DescriptorPoolSize(vk::DescriptorType::eCombinedImageSampler, _swapchain->get().no_of_swapchain_images()),
    };

    //! We will allocate one of these descriptors for every frame. This pool size structure is referenced by the main `vk::DescriptorPoolCreateInfo`:
    //! Aside from the maximum number of individual descriptors that are available, we also need to specify the maximum number of descriptor sets that may be allocated:

    vk::DescriptorPoolCreateInfo poolInfo
    (
        vk::DescriptorPoolCreateFlags{},
        _swapchain->get().no_of_swapchain_images(),
        poolSizes
    );

    _descriptorPool = _device->get()->createDescriptorPool(poolInfo);
}


/******************************************************************//**
* \brief Create descriptor sets.
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::createDescriptorSets( void ) {

    if (!_device)
        throw CException("no logical vulkan device!");
    if (!_descriptorPool)
        throw CException("no descriptor pool!");
    if (_uniform_buffers.size() < _swapchain->get().no_of_swapchain_images())
        throw CException("missing uniform buffers");

    //-------------------------------------------
    // Descriptor set
    //------------------------------------------- 

    //! A descriptor set allocation is described with a `vk::DescriptorSetAllocateInfo` structures.
    //! You need to specify the descriptor pool to allocate from, the number of descriptor sets to allocate, and the descriptor layout to base them on:
    
    std::vector<vk::DescriptorSetLayout> layouts(_swapchain->get().no_of_swapchain_images(), _descriptor_set_layout->get());
    vk::DescriptorSetAllocateInfo allocInfo(_descriptorPool, layouts);

    _descriptorSets = _device->get()->allocateDescriptorSets(allocInfo);

    //! The descriptor sets have been allocated now, but the descriptors within still need to be configured.
    //! We'll now add a loop to populate every descriptor:

    //! Descriptors that refer to buffers, like our uniform buffer descriptor, are configured with a `vk::DescriptorBufferInfo` structures.
    // This structure specifies the buffer and the region within it that contains the data for the descriptor.

    for (size_t i = 0; i < _swapchain->get().no_of_swapchain_images(); i++) {

        std::vector<vk::WriteDescriptorSet> descriptorWrites;

        //! If you're overwriting the whole buffer, like we are in this case, then it is also possible to use the VK_WHOLE_SIZE value for the range.
        //! The configuration of descriptors is updated using the vkUpdateDescriptorSets function, which takes an array of `vk::WriteDescriptorSet` structures as parameter.

        //! The first two fields specify the descriptor set to update and the binding.
        //! We gave our uniform buffer binding index 0. Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update.
        //! We're not using an array, so the index is simply 0.

        //! We need to specify the type of descriptor again.
        //! It's possible to update multiple descriptors at once in an array, starting at index dstArrayElement.
        //! The descriptorCount field specifies how many array elements you want to update.

        std::vector<vk::DescriptorImageInfo> image_infos;
        std::vector<vk::DescriptorBufferInfo> bufferInfos
        { 
            vk::DescriptorBufferInfo(_uniform_buffers[i]->buffer(), 0, sizeof(UniformBufferObject))
        };
        std::vector<vk::BufferView> texel_buffer_view;
        descriptorWrites.push_back(
            vk::WriteDescriptorSet
            (
                _descriptorSets[i],
                0,
                0,
                vk::DescriptorType::eUniformBuffer,
                image_infos,
                bufferInfos,
                texel_buffer_view
            ));

        //! The last field references an array with descriptorCount structures that actually configure the descriptors.
        //! It depends on the type of descriptor which one of the three you actually need to use.
        //! The pBufferInfo field is used for descriptors that refer to buffer data, pImageInfo is used for descriptors that refer to image data,
        //! and pTexelBufferView is used for descriptors that refer to buffer views.
        //! Our descriptor is based on buffers, so we're using pBufferInfo.

        for (size_t j = 0; j < _texture_image_view_memory.size(); ++j)
        {
            vk::DescriptorImageInfo imageInfo(_textureSampler[j], *_texture_image_view_memory[j]->get().image_view(),  vk::ImageLayout::eShaderReadOnlyOptimal);

            descriptorWrites.push_back(
                vk::WriteDescriptorSet
                (
                    _descriptorSets[i],
                    1,
                    0,
                    1,
                    vk::DescriptorType::eCombinedImageSampler,
                    &imageInfo,
                    nullptr,
                    nullptr
                ));
        }

        _device->get()->updateDescriptorSets(descriptorWrites, nullptr);

        //! The updates are applied using vkUpdateDescriptorSets. It accepts two kinds of arrays as parameters:
        //! an array of `vk::WriteDescriptorSet` and an array of `vk::CopyDescriptorSet`. 
        //! The latter can be used to copy descriptors to each other, as its name implies.
    }
}


/******************************************************************//**
* \brief   create command buffers.
* 
* \author  gernot
* \date    2018-05-25
* \version 1.0
**********************************************************************/
void CAppliction::createCommandBuffers( void ) {

    if (!_device)
        throw CException("no logical vulkan device!");
    if (!_command_pool)
        throw CException("no vulkan command pool!");
   

    //-------------------------------------------
    // Command buffer allocation
    //-------------------------------------------

    //! The level parameter specifies if the allocated command buffers are primary or secondary command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_PRIMARY`: Can be submitted to a queue for execution, but cannot be called from other command buffers.
    //! - `VK_COMMAND_BUFFER_LEVEL_SECONDARY`: Cannot be submitted directly, but can be called from primary command buffers.

    _commandBuffers.resize(_swapchain_framebuffers.size());
    
    vk::CommandBufferAllocateInfo allocInfo(_command_pool->get(), vk::CommandBufferLevel::ePrimary, (uint32_t)_commandBuffers.size());

    _commandBuffers = _device->get()->allocateCommandBuffers(allocInfo);


    //-------------------------------------------
    // Starting command buffer recording
    //-------------------------------------------

    //! The flags parameter specifies how we're going to use the command buffer. The following values are available:
    //! - `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`: The command buffer will be rerecorded right after executing it once.
    //! - `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`: This is a secondary command buffer that will be entirely within a single render pass.
    //! - `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`: The command buffer can be resubmitted while it is also already pending execution.

    for (size_t i = 0; i < _commandBuffers.size(); i++)
    {
        vk::CommandBufferBeginInfo beginInfo(vk::CommandBufferUsageFlagBits::eSimultaneousUse, nullptr);

        _commandBuffers[i].begin(beginInfo);

        //! We have used the last flag because we may already be scheduling the drawing commands for the next frame while the last frame is not finished yet.
        //! The pInheritanceInfo parameter is only relevant for secondary command buffers. It specifies which state to inherit from the calling primary command buffers.

        //! If the command buffer was already recorded once, then a call to vkBeginCommandBuffer will implicitly reset it.
        //! It's not possible to append commands to a buffer at a later time.
       

        //-------------------------------------------
        // Starting a render pass
        //-------------------------------------------

        //! The render pass can now begin. All of the functions that record commands can be recognized by their vkCmd prefix.
        //! They all return void, so there will be no error handling until we've finished recording.

        //! The first parameters are the render pass itself and the attachments to bind. 
        //! We created a framebuffer for each swap chain image that specifies it as color attachment.

        //! The next two parameters define the size of the render area.
        //! The render area defines where shader loads and stores will take place.
        //! The pixels outside this region will have undefined values.
        //! It should match the size of the attachments for best performance.

        //! The last two parameters define the clear values to use for VK_ATTACHMENT_LOAD_OP_CLEAR, which we used as load operation for the color attachment.
        //! I've defined the clear color to simply be black with 100% opacity.

        std::vector<vk::ClearValue> clearValues
        {
            vk::ClearValue(vk::ClearColorValue(std::array<float, 4>{0.0f, 0.0f, 0.0f, 1.0f})),
            vk::ClearValue(vk::ClearDepthStencilValue(1.0f, 0))
        };

        vk::RenderPassBeginInfo renderPassInfo
        (
            _render_pass->handle(),
            _swapchain_framebuffers[i]->handle(),
            vk::Rect2D(vk::Offset2D(0, 0), _swapchain->get().image_extent_2D()),
            clearValues
        );


        //! The first parameter for every command is always the command buffer to record the command to.
        //! The second parameter specifies the details of the render pass we've just provided. The final parameter controls how the drawing commands within the render pass will be provided.
        //! It can have one of two values:
        //! - `VK_SUBPASS_CONTENTS_INLINE`: The render pass commands will be embedded in the primary command buffer itself and no secondary command buffers will be executed.
        //! - `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`: The render pass commands will be executed from secondary command buffers.

        _commandBuffers[i].beginRenderPass(renderPassInfo, vk::SubpassContents::eInline);


        //-------------------------------------------
        // Basic drawing commands
        //-------------------------------------------
        
        //! The second parameter specifies if the pipeline object is a graphics or compute pipeline.
    
        _commandBuffers[i].bindPipeline(vk::PipelineBindPoint::eGraphics, *_graphics_pipeline);

        //! The actual vkCmdDraw function is a bit anticlimactic, but it's so simple because of all the information we specified in advance.
        //! It has the following parameters, aside from the command buffer:
        //! - vertexCount: Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.
        //! - instanceCount: Used for instanced rendering, use 1 if you're not doing that.
        //! - firstVertex: Used as an offset into the vertex buffer, defines the lowest value of gl_VertexIndex.
        //! - firstInstance: Used as an offset for instanced rendering, defines the lowest value of gl_InstanceIndex.

        //! The `vkCmdBindVertexBuffers` function is used to bind vertex buffers to bindings, like the one we set up in the previous chapter.
        //! The first two parameters, besides the command buffer, specify the offset and number of bindings we're going to specify vertex buffers for.
        //! The last two parameters specify the array of vertex buffers to bind and the byte offsets to start reading vertex data from.
        //! You should also change the call to vkCmdDraw to pass the number of vertices in the buffer as opposed to the hardcoded number 3.

        std::vector<vk::Buffer> vertexBuffers = { _vertex_buffers.back()->buffer() };
        std::vector<vk::DeviceSize> offsets = { 0 };
        _commandBuffers[i].bindVertexBuffers(0, vertexBuffers, offsets);

        // vkCmdDraw(_commandBuffers[i], static_cast<uint32_t>(vertices.size()), 1, 0, 0);


        //-------------------------------------------
        // Using an index buffer
        //-------------------------------------------

        //! Using an index buffer for drawing involves two changes to createCommandBuffers.
        //! We first need to bind the index buffer, just like we did for the vertex buffer.
        //! The difference is that you can only have a single index buffer.
        //! It's unfortunately not possible to use different indices for each vertex attribute,
        //! so we do still have to completely duplicate vertex data even if just one attribute varies.

        //! An index buffer is bound with vkCmdBindIndexBuffer which has the index buffer, a byte offset into it,
        //! and the type of index data as parameters. As mentioned before, the possible types are VK_INDEX_TYPE_UINT16 and VK_INDEX_TYPE_UINT32.

        vk::IndexType index_type = sizeof(*_indices.data()) == 4 ? vk::IndexType::eUint32 : (sizeof(*_indices.data()) == 2 ? vk::IndexType::eUint16 : vk::IndexType::eUint8EXT);
        _commandBuffers[i].bindIndexBuffer(_index_buffers.back()->buffer(), 0, index_type);

    
        //-------------------------------------------
        // Using descriptor sets
        //-------------------------------------------

        //! Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines.
        //! Therefore we need to specify if we want to bind descriptor sets to the graphics or compute pipeline.
        //! The next parameter is the layout that the descriptors are based on.
        //! The next three parameters specify the index of the first descriptor set, the number of sets to bind, and the array of sets to bind. We'll get back to this in a moment.
        //! The last two parameters specify an array of offsets that are used for dynamic descriptors.

        _commandBuffers[i].bindDescriptorSets(vk::PipelineBindPoint::eGraphics, *_pipeline_layout, 0, 1, &_descriptorSets[i], 0, nullptr);


        //! Just binding an index buffer doesn't change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer.
        //! Remove the vkCmdDraw line and replace it with vkCmdDrawIndexed:

        vkCmdDrawIndexed(_commandBuffers[i], static_cast<uint32_t>(_indices.size()), 1, 0, 0, 0);


        //-------------------------------------------
        // Finishing up
        //-------------------------------------------

        _commandBuffers[i].endRenderPass();
        _commandBuffers[i].end();
    }    
}


/******************************************************************//**
* \brief   create semaphores 
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::createSyncObjects( void ) {

    if ( !_device )
        throw CException("no logical vulkan device!");


    //! The drawFrame function will perform the following operations:
    //! - Acquire an image from the swap chain
    //! - Execute the command buffer with that image as attachment in the framebuffer
    //! - Return the image to the swap chain for presentation

    //! Each of these events is set in motion using a single function call, but they are executed asynchronously.
    //! The function calls will return before the operations are actually finished and the order of execution is also undefined.
    //! That is unfortunate, because each of the operations depends on the previous one finishing.

    //! There are two ways of synchronizing swap chain events: fences and semaphores.
    //! They're both objects that can be used for coordinating operations by having one operation signal and another operation wait for a fence or semaphore to go from the unsignaled to signaled state.

    //! The difference is that the state of fences can be accessed from your program using calls like `vkWaitForFences` and semaphores cannot be.
    //! Fences are mainly designed to synchronize your application itself with rendering operation, whereas semaphores are used to synchronize operations within or across command queues.


    //-------------------------------------------
    // Semaphores
    //-------------------------------------------

    const int MAX_FRAMES_IN_FLIGHT = 2;

    _imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    _renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    _inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

    vk::SemaphoreCreateInfo semaphoreInfo = {};
    
    vk::FenceCreateInfo fenceInfo = {};
    
    //! initialize in the signaled state as if we had rendered an initial frame that finished
    fenceInfo.flags = vk::FenceCreateFlagBits::eSignaled;

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        _imageAvailableSemaphores[i] = _device->get()->createSemaphore(semaphoreInfo);
        _renderFinishedSemaphores[i] = _device->get()->createSemaphore(semaphoreInfo);
        _inFlightFences[i] = _device->get()->createFence(fenceInfo);
    }

}


/******************************************************************//**
* \brief   do the drawing
* 
* \author  gernot
* \date    2018-05-27
* \version 1.0
**********************************************************************/
void CAppliction::drawFrame( void ) {

    //! The `vkWaitForFences` function takes an array of fences and waits for either any or all of them to be signaled before returning.
    //! The `VK_TRUE` we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter.
    //! Just like `vkAcquireNextImageKHR` this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the vkResetFences call.

    auto result = _device->get()->waitForFences(1, &_inFlightFences[_currentFrame], VK_TRUE, std::numeric_limits<uint64_t>::max());

    //-------------------------------------------
    // Acquiring an image from the swap chain
    //-------------------------------------------

    //! The first two parameters of `vkAcquireNextImageKHR` are the logical device and the swap chain from which we wish to acquire an image.
    //! The third parameter specifies a timeout in nanoseconds for an image to become available.
    //! Using the maximum value of a 64 bit unsigned integer disables the timeout.

    //! The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image.
    //! That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both.
    //! We're going to use our imageAvailableSemaphore for that purpose here.

    //! The last parameter specifies a variable to output the index of the swap chain image that has become available.
    //! The index refers to the `vk::Image` in our swapChainImages array.

    uint32_t imageIndex;
    vk::Result acquireNextImageResult;
    result = _device->get()->acquireNextImageKHR(*_swapchain, std::numeric_limits<uint64_t>::max(), _imageAvailableSemaphores[_currentFrame], vk::Fence(), &imageIndex);
    acquireNextImageResult = result;
    
    if (acquireNextImageResult == vk::Result::eErrorOutOfDateKHR || acquireNextImageResult == vk::Result::eSuboptimalKHR || _framebufferResized) {
        _framebufferResized = false;
        recreateSwapChain();
        return;
    } 

    result = _device->get()->resetFences(1, &_inFlightFences[_currentFrame]);


    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------
    
    updateUniformBuffer(imageIndex);

    //-------------------------------------------
    // Submitting the command buffer
    //-------------------------------------------
    
    //! The first three parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
    //! We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment.
    //! That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. 
    //! Each entry in the waitStages array corresponds to the semaphore with the same index in pWaitSemaphores.

    //! The next two parameters specify which command buffers to actually submit for execution.
    //! As mentioned earlier, we should submit the command buffer that binds the swap chain image we just acquired as color attachment.

    //! The signalSemaphoreCount and pSignalSemaphores parameters specify which semaphores to signal once the command buffer(s) have finished execution.
    //! In our case we're using the renderFinishedSemaphore for that purpose.

    std::vector<vk::Semaphore> waitSemaphores{_imageAvailableSemaphores[_currentFrame]};
    std::vector<vk::Semaphore> signalSemaphores{_renderFinishedSemaphores[_currentFrame]};
    std::vector<vk::PipelineStageFlags> waitStages{vk::PipelineStageFlagBits::eColorAttachmentOutput};
    std::vector<vk::CommandBuffer> commandbuffers{_commandBuffers[imageIndex]};

    vk::SubmitInfo submitInfo(waitSemaphores, waitStages, commandbuffers, signalSemaphores);

    result = _graphicsQueue.submit(1, &submitInfo, _inFlightFences[_currentFrame]);
 
    //-------------------------------------------
    // Presentation
    //-------------------------------------------
    
    //! The next two parameters specify the swap chains to present images to and the index of the image for each swap chain.
    //! This will almost always be a single one.

    //! There is one last optional parameter called pResults.
    //! It allows you to specify an array of `vk::Result` values to check for every individual swap chain if presentation was successful. 
    //! It's not necessary if you're only using a single swap chain, because you can simply use the return value of the present function.

    std::vector<vk::SwapchainKHR> swapChains{_swapchain->handle()};
    std::vector<uint32_t> imageIndexs{imageIndex};
    std::vector<vk::Result> resutl;

    vk::PresentInfoKHR presentInfo(signalSemaphores, swapChains, imageIndexs, resutl);

    result = _presentQueue.presentKHR(presentInfo);

    //-------------------------------------------
    // Frames in flight
    //-------------------------------------------
    
    //! If you run your application with validation layers enabled and you monitor the memory usage of your application, you may notice that it is slowly growing.
    //! The reason for this is that the application is rapidly submitting work in the drawFrame function, but doesn't actually check if any of it finishes.
    //! If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work.
    //! Worse, even, is that we are reusing the imageAvailableSemaphore and renderFinishedSemaphore for multiple frames at the same time.

    //! The easy way to solve this is to wait for work to finish right after submitting it, for example by using vkQueueWaitIdle.
    //! However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now.
    //! The stages that the current frame has already progressed through are idle and could already be used for a next frame.

    //vkQueuePresentKHR(_presentQueue, &presentInfo);
    //vkQueueWaitIdle(_presentQueue);


    _currentFrame = (_currentFrame + 1) % _imageAvailableSemaphores.size();
}


/******************************************************************//**
* \brief   update the uniform buffer for the current image
* 
* \author  gernot
* \date    2019-05-04
* \version 1.0
**********************************************************************/
void CAppliction::updateUniformBuffer( uint32_t imageIndex )
{
    if ( !_device )
        throw CException("no logical vulkan device!");

    //-------------------------------------------
    // Updating uniform data
    //-------------------------------------------

    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    UniformBufferObject ubo = {};
    ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = glm::perspective(glm::radians(45.0f), _swapchain->get().image_width_2D() / (float) _swapchain->get().image_height_2D(), 0.1f, 10.0f);

    // GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
    // The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the projection matrix.
    // If you don't do this, then the image will be rendered upside down.
    ubo.proj[1][1] *= -1;

    _uniform_buffers[imageIndex]->memory().copy(&ubo);
}


} // VulkanLoader


using HelloTriangleApplication = VulkanLoader::CAppliction;


int main() {
    
    static bool verbose                      = true;
    static bool enable_all_validation_layers = false;
    static bool enable_surface_extensions    = true;
    static bool enable_swapchain_extensions  = true;
    static bool enable_validation_warnings   = true;
    static bool enable_debug_extensions      = true;
    static bool enable_debug_information     = false;
    static bool enable_depth_test            = true;
    static bool enable_face_culling          = false;
    static bool load_model                   = true;
    
    HelloTriangleApplication app( verbose );

    const std::vector<std::string> validationLayers = {
        //"VK_LAYER_LUNARG_api_dump",
        "VK_LAYER_KHRONOS_validation",
        "VK_LAYER_LUNARG_monitor",
        "VK_LAYER_LUNARG_screenshot",
        "VK_LAYER_NV_optimus"
    };
    const std::vector<std::string> excludeValidationLayers = {
        "VK_LAYER_LUNARG_device_simulation",
        "VK_LAYER_LUNARG_vktrace",
        "VK_LAYER_RENDERDOC_Capture" //!< causes instance creation fail; why?
    };

    app.scene(load_model);
    app.layers(validationLayers, enable_all_validation_layers, excludeValidationLayers);
    app.settings(enable_depth_test, enable_face_culling);

    const std::vector<std::string> extensions = {
        "VK_KHR_win32_surface", // seems to be strongly required for win32 application (at least for GLFW)
    };
    app.extensions( 
      extensions,
      enable_surface_extensions,
      enable_validation_warnings,
      enable_debug_extensions,
      enable_debug_information );

    const std::vector<std::string> device_extensions = {};
    app.deviceExtensions( 
      device_extensions,
      enable_swapchain_extensions );

    bool exit_success = true;
    try {
        app.run();
    } catch (const std::runtime_error& e) {
        std::cerr << e.what() << std::endl;
        exit_success = false;
    }

    return exit_success ? EXIT_SUCCESS : EXIT_FAILURE;
}